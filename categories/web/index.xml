<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on HOREB EVAN JEKYULLL BLOG</title><link>https://jekyulll.github.io/categories/web/</link><description>Recent content in Web on HOREB EVAN JEKYULLL BLOG</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 17 Apr 2025 04:05:47 +0800</lastBuildDate><atom:link href="https://jekyulll.github.io/categories/web/index.xml" rel="self" type="application/rss+xml"/><item><title>304 Not Modified 是怎么检测的？</title><link>https://jekyulll.github.io/post/web-304-not-modified-%E6%98%AF%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E7%9A%84/</link><pubDate>Thu, 17 Apr 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/web-304-not-modified-%E6%98%AF%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E7%9A%84/</guid><description>&lt;p>&lt;strong>最终判断逻辑由服务端完成&lt;/strong>。&lt;/p>
&lt;p>• &lt;strong>浏览器行为&lt;/strong>（客户端）：
• 浏览器会缓存资源（如 HTML、图片、CSS 等），并根据服务端之前返回的响应头（如 &lt;code>Cache-Control&lt;/code>、&lt;code>Expires&lt;/code>、&lt;code>ETag&lt;/code>、&lt;code>Last-Modified&lt;/code>）决定是否发起&lt;strong>条件请求&lt;/strong>。
• 当缓存过期或页面刷新（非强制刷新）时，浏览器会向服务端发送一个带有&lt;strong>验证头&lt;/strong>的请求，例如：
◦ &lt;code>If-None-Match&lt;/code>（对应服务端之前返回的 &lt;code>ETag&lt;/code>）
◦ &lt;code>If-Modified-Since&lt;/code>（对应服务端之前返回的 &lt;code>Last-Modified&lt;/code>）&lt;/p></description></item><item><title>Nginx 的多进程模型</title><link>https://jekyulll.github.io/post/web-nginx-%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Fri, 21 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/web-nginx-%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>在Web服务器领域，Nginx凭借其高并发、低资源消耗的特点脱颖而出。其核心设计选择之一便是&lt;strong>多进程模型&lt;/strong>。这一设计看似与传统多线程模型背道而驰，却恰恰成就了Nginx的卓越性能。本文将从技术原理、场景适配、架构权衡等角度，深度解析Nginx偏爱多进程的底层逻辑。&lt;/p></description></item><item><title>流计算中的反向压力模型与 Reactive Streams --C++实现</title><link>https://jekyulll.github.io/post/web-%E6%B5%81%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E5%8E%8B%E5%8A%9B%E6%A8%A1%E5%9E%8B%E4%B8%8E-reactive-streams---c++%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 21 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/web-%E6%B5%81%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E5%8E%8B%E5%8A%9B%E6%A8%A1%E5%9E%8B%E4%B8%8E-reactive-streams---c++%E5%AE%9E%E7%8E%B0/</guid><description>&lt;h2 id="一反向压力backpressure的核心意义">一、反向压力（Backpressure）的核心意义&lt;/h2>
&lt;p>在流式计算中，数据生产者的生成速率与消费者的处理速率往往不匹配。若生产者速度远高于消费者，无限制的缓冲会导致&lt;strong>内存溢出&lt;/strong>或&lt;strong>系统崩溃&lt;/strong>。反向压力（Backpressure）机制通过动态调节数据流速，实现生产者与消费者的&lt;strong>速率适配&lt;/strong>，从而保证系统的稳定性与资源可控性。&lt;/p></description></item><item><title>解析LRU与LFU算法及C++实现</title><link>https://jekyulll.github.io/post/web-%E8%A7%A3%E6%9E%90lru%E4%B8%8Elfu%E7%AE%97%E6%B3%95%E5%8F%8Ac++%E5%AE%9E%E7%8E%B0/</link><pubDate>Sun, 16 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/web-%E8%A7%A3%E6%9E%90lru%E4%B8%8Elfu%E7%AE%97%E6%B3%95%E5%8F%8Ac++%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>在计算机系统中，缓存是提升性能的核心技术之一。当内存资源有限时，如何高效淘汰无用数据、保留热点数据？**LRU（最近最少使用）&lt;strong>和&lt;/strong>LFU（最不频繁使用）**算法为此提供了经典解决方案。本文将从原理到实践，详解这两种算法，并附完整C++实现代码。&lt;/p></description></item><item><title>【AI】半衰期算法在后端的应用</title><link>https://jekyulll.github.io/post/web-%E5%8D%8A%E8%A1%B0%E6%9C%9F%E7%AE%97%E6%B3%95%E5%9C%A8%E5%90%8E%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8/</link><pubDate>Mon, 10 Mar 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/web-%E5%8D%8A%E8%A1%B0%E6%9C%9F%E7%AE%97%E6%B3%95%E5%9C%A8%E5%90%8E%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8/</guid><description>&lt;p>在后端开发中，半衰期算法常用于动态调整数据权重的场景，其核心是通过时间衰减机制平衡实时性与历史价值。以下是其典型应用及实现逻辑：&lt;/p>
&lt;h3 id="一算法原理与公式">一、算法原理与公式&lt;/h3>
&lt;p>半衰期算法基于放射性衰变公式：&lt;strong>M * (1/2)^(t/T)&lt;/strong>，其中：
• &lt;strong>M&lt;/strong>：初始值（如点击量）
• &lt;strong>t&lt;/strong>：时间间隔（如天数）
• &lt;strong>T&lt;/strong>：半衰期周期（如7天）
该公式使数据权重随时间呈指数衰减，例如7天半衰期意味着权重每天减少约10%。&lt;/p></description></item><item><title>web 访问认证机制</title><link>https://jekyulll.github.io/post/web-web-%E8%AE%BF%E9%97%AE%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 17 Feb 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/web-web-%E8%AE%BF%E9%97%AE%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</guid><description>&lt;p>&lt;a href="https://time.geekbang.org/column/article/398410">25 | 认证机制：应用程序如何进行访问认证？&lt;/a>讲得非常好，图文结合。&lt;/p>
&lt;p>&lt;strong>IAM&lt;/strong>：身份识别与访问管理（Identity and Access Management）。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>认证&lt;/strong>（Authentication，英文缩写 &lt;strong>authn&lt;/strong>）：用来验证某个用户是否具有访问系统的权限。如果认证通过，该用户就可以访问系统，从而创建、修改、删除、查询平台支持的资源。&lt;/li>
&lt;li>&lt;strong>授权&lt;/strong>（Authorization，英文缩写 &lt;strong>authz&lt;/strong>）：用来验证某个用户是否具有访问某个资源的权限，如果授权通过，该用户就能对资源做增删改查等操作。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>认证证明了你是谁，授权决定了你能做什么。&lt;/p></description></item></channel></rss>