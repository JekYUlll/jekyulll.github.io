<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Os on HOREB EVAN JEKYULLL BLOG</title><link>https://jekyulll.github.io/tags/os/</link><description>Recent content in Os on HOREB EVAN JEKYULLL BLOG</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 29 Apr 2025 21:05:47 +0800</lastBuildDate><atom:link href="https://jekyulll.github.io/tags/os/index.xml" rel="self" type="application/rss+xml"/><item><title>[linux] TODO 守护进程，setsid，Linux三个id，权限</title><link>https://jekyulll.github.io/post/linux-todo-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8Bsetsidlinux%E4%B8%89%E4%B8%AAid%E6%9D%83%E9%99%90/</link><pubDate>Tue, 29 Apr 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/linux-todo-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8Bsetsidlinux%E4%B8%89%E4%B8%AAid%E6%9D%83%E9%99%90/</guid><description>&lt;p>复习：&lt;a href="https://blog.csdn.net/JMW1407/article/details/108412836">【Linux】守护进程（ Daemon）的定义，作用，创建流程&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/liaowenxiong/article/details/116401524">Linux 命令之 &lt;code>locale&lt;/code> &amp;ndash; 设置和显示程序运行的语言环境&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>使用 &lt;code>locale&lt;/code> 命令来设置和显示程序运行的语言环境，&lt;code>locale&lt;/code> 会根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统定义一个软件运行时的语言环境。&lt;br>
&lt;code>locale&lt;/code> 由ANSI C提供支持。&lt;code>locale&lt;/code> 的命名规则为&lt;code>&amp;lt;语言&amp;gt;_&amp;lt;地区&amp;gt;.&amp;lt;字符集编码&amp;gt;&lt;/code>。&lt;/p></description></item><item><title>Linux 守护进程</title><link>https://jekyulll.github.io/post/linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link><pubDate>Tue, 29 Apr 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</guid><description>&lt;p>复习：&lt;a href="https://blog.csdn.net/JMW1407/article/details/108412836">【Linux】守护进程（ Daemon）的定义，作用，创建流程&lt;/a>。&lt;/p>
&lt;p>编写守护进程的一般步骤步骤：&lt;/p>
&lt;ol>
&lt;li>在父进程中执行&lt;code>fork&lt;/code>并&lt;code>exit&lt;/code>退出；&lt;/li>
&lt;li>在子进程中调用&lt;code>setsid&lt;/code>函数创建新的会话；&lt;/li>
&lt;li>在子进程中调用&lt;code>chdir&lt;/code>函数，让根目录&lt;code>/&lt;/code>成为子进程的工作目录；&lt;/li>
&lt;li>在子进程中调用&lt;code>umask&lt;/code>函数，设置进程的&lt;code>umask&lt;/code>为&lt;code>0&lt;/code>；&lt;/li>
&lt;li>在子进程中关闭任何不需要的文件描述符。&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://blog.csdn.net/Change_Improve/article/details/106107317">Linux—umask（创建文件时的掩码）用法详解&lt;/a>。&lt;/p></description></item><item><title>Linux 的CPU保护环，三环和零环</title><link>https://jekyulll.github.io/post/linux-linux-%E7%9A%84cpu%E4%BF%9D%E6%8A%A4%E7%8E%AF%E4%B8%89%E7%8E%AF%E5%92%8C%E9%9B%B6%E7%8E%AF/</link><pubDate>Sun, 30 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/linux-linux-%E7%9A%84cpu%E4%BF%9D%E6%8A%A4%E7%8E%AF%E4%B8%89%E7%8E%AF%E5%92%8C%E9%9B%B6%E7%8E%AF/</guid><description>&lt;p>Linux系统中的“三环”和“零环”概念源自CPU的&lt;strong>保护环&lt;/strong>（Protection Rings）机制，是操作系统实现权限隔离和安全保护的核心设计。&lt;/p></description></item><item><title>fork出的子进程是否继承文件描述符表？</title><link>https://jekyulll.github.io/post/linux-fork%E5%87%BA%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/</link><pubDate>Sat, 29 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/linux-fork%E5%87%BA%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/</guid><description>&lt;p>当通过 &lt;code>fork()&lt;/code> 创建子进程时，子进程会获得父进程文件描述符表的&lt;u>完整副本&lt;/u>。这意味着子进程的文件描述符表中每个条目指向的 系统级文件表项（File Table Entry）与父进程相同。
父子进程共享文件表项中的文件偏移量（Offset）、打开模式（Read/Write Flags）、文件状态标志等信息。例如，如果父进程写入文件后移动了偏移量，子进程会从新的偏移位置继续操作。&lt;/p></description></item><item><title>Linux里fork出子进程的时候，哪些内容是共享的？</title><link>https://jekyulll.github.io/post/linux-linux%E9%87%8Cfork%E5%87%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84/</link><pubDate>Thu, 27 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/linux-linux%E9%87%8Cfork%E5%87%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84/</guid><description>&lt;h3 id="一共享的内容">&lt;strong>一、共享的内容&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>文件描述符与文件状态&lt;/strong>&lt;br>
子进程会继承父进程已打开的文件描述符表，包括文件偏移量、打开模式（如读写权限）和文件状态标志（如&lt;code>O_APPEND&lt;/code>）。例如，若父进程打开了一个文件并写入数据，子进程可通过相同的文件描述符继续操作，且两者的写入位置（偏移量）会相互影响。&lt;br>
• &lt;strong>示例场景&lt;/strong>：父进程向文件写入“Parent”，子进程写入“Child”，最终文件内容会按操作顺序合并（如“ParentChild”或“ChildParent”），具体取决于调度顺序。&lt;/p></description></item><item><title>【AI】mmap 和零拷贝</title><link>https://jekyulll.github.io/post/linux-mmap-%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link><pubDate>Fri, 07 Mar 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/linux-mmap-%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid><description>&lt;p>mmap（Memory Mapping）是Unix/Linux系统中的一种重要机制，它允许将文件或设备直接映射到进程的虚拟地址空间，从而将文件操作与内存操作高效结合。以下从核心机制、与IO的关系、与内存分配的关系三个方面详细解析：&lt;/p></description></item><item><title>内核的用户态和内核态</title><link>https://jekyulll.github.io/post/linux-%E5%86%85%E6%A0%B8%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</link><pubDate>Fri, 07 Mar 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/linux-%E5%86%85%E6%A0%B8%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</guid><description>&lt;p>线程的管理和调度涉及用户态与内核态的协作，不同编程语言和操作系统对线程的处理方式也有所差异。&lt;/p>
&lt;hr>
&lt;h3 id="一线程概念的双重性用户态与内核态的交织">一、线程概念的双重性：用户态与内核态的交织&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>用户态线程（用户级线程）&lt;/strong>&lt;br>
用户态线程由用户空间的线程库直接管理，内核对其无感知。这类线程的创建、调度、同步等操作完全在用户空间完成，无需内核介入。&lt;br>
存在明显局限性：&lt;br>
• &lt;strong>阻塞问题&lt;/strong>：若一个用户态线程因系统调用阻塞（如I/O操作），整个进程的所有线程都会被阻塞；
• &lt;strong>多核利用率低&lt;/strong>：内核无法将用户态线程调度到多个CPU核心上运行。&lt;/p></description></item><item><title>进程、线程、协程的资源消耗简述</title><link>https://jekyulll.github.io/post/linux-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%E7%AE%80%E8%BF%B0/</link><pubDate>Fri, 07 Mar 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/linux-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%E7%AE%80%E8%BF%B0/</guid><description>&lt;p>&lt;strong>一、线程切换 vs 进程切换&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>地址空间与页表&lt;/strong>&lt;br>
进程拥有独立的虚拟地址空间和页表，切换进程时需更新页表并刷新 &lt;strong>TLB（地址转换缓存）&lt;/strong>，导致内存访问速度下降。而线程共享进程的地址空间和页表，切换时无需此操作，TLB 缓存保持有效。&lt;/p></description></item><item><title>在运行的时候，修改并且覆盖该二进制文件会如何？</title><link>https://jekyulll.github.io/post/linux-%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E4%BF%AE%E6%94%B9%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E8%AF%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BC%9A%E5%A6%82%E4%BD%95/</link><pubDate>Thu, 06 Mar 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/linux-%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E4%BF%AE%E6%94%B9%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E8%AF%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BC%9A%E5%A6%82%E4%BD%95/</guid><description>&lt;blockquote>
&lt;p>Linux上有个二进制程序一直在运行，修改代码后重新编译把原来的二进制程序覆盖了，会怎么样？
该问题来自一道天美后台开发面试题：&lt;a href="https://zhuanlan.zhihu.com/p/677307438">天美一面 后台开发（凉） - 牛客面经的文章 - 知乎&lt;/a>。此处尝试进行回答。&lt;/p></description></item><item><title>C++ 同一进程的线程之间共享哪些资源？</title><link>https://jekyulll.github.io/post/cpp-c++-%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</link><pubDate>Sat, 08 Feb 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/cpp-c++-%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</guid><description>&lt;p>同一进程内的线程共享的资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>代码段&lt;/strong>：存放程序的可执行指令，所有线程共享相同的代码段，因此任何线程都可以执行程序中的函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据段&lt;/strong>：包含全局变量和静态变量，这些变量在程序运行期间只有一个实例，所有线程都可以访问和修改它们。&lt;/p></description></item><item><title>运行时是把整个动态库都加载到内存中吗？</title><link>https://jekyulll.github.io/post/cpp-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%98%AF%E6%8A%8A%E6%95%B4%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93%E9%83%BD%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%90%97/</link><pubDate>Sat, 08 Feb 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/post/cpp-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%98%AF%E6%8A%8A%E6%95%B4%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93%E9%83%BD%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%90%97/</guid><description>&lt;p>在 C++ 中，动态库（如 &lt;code>.dll&lt;/code> 或 &lt;code>.so&lt;/code> 文件）在加载时，操作系统会将整个库文件映射到进程的地址空间中。
&lt;u>具体的函数和数据只有在被实际使用时才会被加载到内存中。&lt;/u>
(动态库作为一个整体被映射，但其中的各个部分仅在需要时才占用物理内存。)&lt;/p></description></item></channel></rss>