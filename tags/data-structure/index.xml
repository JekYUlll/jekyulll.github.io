<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data Structure on Welcome to my Blog ⬆️</title><link>https://jekyulll.github.io/tags/data-structure/</link><description>Recent content in Data Structure on Welcome to my Blog ⬆️</description><generator>Hugo</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Tue, 21 Jan 2025 12:05:47 +0800</lastBuildDate><atom:link href="https://jekyulll.github.io/tags/data-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>写个相对现代的 C++ 二叉搜索树</title><link>https://jekyulll.github.io/posts/cpp-%E5%86%99%E4%B8%AA%E7%9B%B8%E5%AF%B9%E7%8E%B0%E4%BB%A3%E7%9A%84-c++-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Tue, 21 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E5%86%99%E4%B8%AA%E7%9B%B8%E5%AF%B9%E7%8E%B0%E4%BB%A3%E7%9A%84-c++-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;optional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">concept&lt;/span> Comparable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">requires&lt;/span>(T a, T b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { a &lt;span style="color:#f92672">&amp;lt;&lt;/span> b } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>convertible_to&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { a &lt;span style="color:#f92672">&amp;gt;&lt;/span> b } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>convertible_to&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { a &lt;span style="color:#f92672">==&lt;/span> b } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>convertible_to&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">concept&lt;/span> Streamable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">requires&lt;/span>(T a, std&lt;span style="color:#f92672">::&lt;/span>ostream&lt;span style="color:#f92672">&amp;amp;&lt;/span> os) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { os &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> a } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>same_as&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>ostream&lt;span style="color:#f92672">&amp;amp;&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>Comparable K, Streamable V&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PairBSTree&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> Pair &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair _pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> _left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> _right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> _pair(pair), _left(&lt;span style="color:#66d9ef">nullptr&lt;/span>), _right(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode(Pair&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> pair)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> _pair(std&lt;span style="color:#f92672">::&lt;/span>move(pair)), _left(&lt;span style="color:#66d9ef">nullptr&lt;/span>), _right(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>TreeNode() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> _root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">build_&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair : nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Insert(pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">build_&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&amp;amp;&lt;/span> nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair : nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Insert(std&lt;span style="color:#f92672">::&lt;/span>move(pair));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">destroy_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destroy_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destroy_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> search_(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node, K key) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node &lt;span style="color:#f92672">||&lt;/span> key &lt;span style="color:#f92672">==&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (key &lt;span style="color:#f92672">&amp;lt;&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">search_&lt;/span>(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">search_&lt;/span>(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">insert_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node, &lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TreeNode(pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> key &lt;span style="color:#f92672">=&lt;/span> pair.first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (key &lt;span style="color:#f92672">==&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair &lt;span style="color:#f92672">=&lt;/span> pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (key &lt;span style="color:#f92672">&amp;lt;&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> insert_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left, pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> insert_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right, pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> go_to_max_(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> go_to_min_(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">delete_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node, K key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> search_(node, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> max_in_left &lt;span style="color:#f92672">=&lt;/span> go_to_max_(target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair &lt;span style="color:#f92672">=&lt;/span> max_in_left&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 常规的递归，把整个左子树当做新的树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// delete_(target-&amp;gt;_left, max_in_left-&amp;gt;_pair.first);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 2. 直接传入 max_in_left 即可
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// delete_(max_in_left, max_in_left-&amp;gt;_pair.first);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 3. 实际上不需要递归，因为 max_in_left 是左边最大的值，一定没有右子树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> TreeNode&lt;span style="color:#f92672">*&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> max_in_left&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> max_in_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_in_left &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 我开始时候的代码（有误）：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// auto&amp;amp; max_in_left = go_to_max_(node-&amp;gt;_left); // 应该是
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// current-&amp;gt;_left current-&amp;gt;_pair = max_in_left-&amp;gt;_pair; delete
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// (max_in_left); max_in_left = nullptr;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 第三种和我开始时候的逻辑类似
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 但我当时忘了保留 max_in_left 的左子树（如果存在）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">normal_print_func_&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pair.second &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; | &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">in_order_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&lt;/span> node, std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span>)&lt;span style="color:#f92672">&amp;gt;&lt;/span> func) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in_order_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left, func);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in_order_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right, func);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree() &lt;span style="color:#f92672">:&lt;/span> _root(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> pairs) &lt;span style="color:#f92672">:&lt;/span> _root(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build_(pairs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&amp;amp;&lt;/span> pairs) &lt;span style="color:#f92672">:&lt;/span> _root(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build_(std&lt;span style="color:#f92672">::&lt;/span>move(pairs));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>PairBSTree() { destroy_(_root); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>V&lt;span style="color:#f92672">&amp;gt;&lt;/span> Search(K key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> node &lt;span style="color:#f92672">=&lt;/span> search_(_root, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>nullopt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Insert&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair) { insert_(_root, pair); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Delete&lt;/span>(K key) { delete_(_root, key); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">InOrder&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>(Pair)&lt;span style="color:#f92672">&amp;gt;&lt;/span> func &lt;span style="color:#f92672">=&lt;/span> normal_print_func_) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in_order_(_root, func);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">[[nodiscard]]&lt;/span> size_t Size() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InOrder([&lt;span style="color:#f92672">&amp;amp;&lt;/span>size](std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span>) { &lt;span style="color:#f92672">++&lt;/span>size; });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">[[nodiscard]]&lt;/span> V Max() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> _root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> go_to_max_(temp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">[[nodiscard]]&lt;/span> V Min() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> _root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> go_to_min_(temp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> pairs &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Bob&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Jack&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Lucy&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">23&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Evan&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Gorge&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Lily&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Mono&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">90&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Rick&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">14&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Lance&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">76&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Molly&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">24&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Stan&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">11&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Scot&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">54&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Mint&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">37&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Biance&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">35&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Cower&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Brick&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree tree(pairs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Name of 9: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tree.Search(&lt;span style="color:#ae81ff">9&lt;/span>).value_or(&lt;span style="color:#e6db74">&amp;#34;nothing&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tree.Size() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// std::cout &amp;lt;&amp;lt; &amp;#34;Min: &amp;#34; &amp;lt;&amp;lt; tree.Min() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// std::cout &amp;lt;&amp;lt; &amp;#34;Max: &amp;#34; &amp;lt;&amp;lt; tree.Max() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.InOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.Delete(&lt;span style="color:#ae81ff">15&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tree.Size() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.InOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> names_in_order;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.InOrder([&lt;span style="color:#f92672">&amp;amp;&lt;/span>names_in_order](std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> pair) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pair.second &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; -- &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> names_in_order.push_back(pair.second);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Redis 数据结构之超日志 HyperLogLog</title><link>https://jekyulll.github.io/posts/redis-redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B6%85%E6%97%A5%E5%BF%97-hyperloglog/</link><pubDate>Wed, 08 Jan 2025 10:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/redis-redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B6%85%E6%97%A5%E5%BF%97-hyperloglog/</guid><description>&lt;p>Redis 在 2.8.9 版本添加了 HyperLogLog （HLL）。&lt;br>
HyperLogLog 是一种高效的基数估算工具，通过概率算法和哈希化技术，在常数空间内提供了基数的估算。&lt;/p>
&lt;p>&lt;em>eg&lt;/em>.&lt;/p>
&lt;ul>
&lt;li>统计一个网站的独立用户数。&lt;/li>
&lt;li>统计一个日志中的独立 IP 数量。&lt;/li>
&lt;li>计算一个流中的独立事件数。&lt;/li>
&lt;/ul>
&lt;p>传统的做法是将所有元素存储在集合中，然后进行去重、计数。但当集合的元素数量非常大时，这种方法会占用大量内存，甚至无法存储所有数据。&lt;br>
HyperLogLog 有一定误差，但对于海量数据来说，它的内存开销极低且精度足够高，非常适合用于大数据处理、流量统计、去重计数等场景。&lt;/p>
&lt;p>Redis 中的 HyperLogLog 支持以下操作：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>PFADD&lt;/code>&lt;/strong>：将元素添加到 HyperLogLog 中，Redis 会对元素进行哈希处理，并更新相应的桶。&lt;/li>
&lt;li>&lt;strong>&lt;code>PFCOUNT&lt;/code>&lt;/strong>：返回一个或多个 HyperLogLog 键的基数估算。&lt;/li>
&lt;li>&lt;strong>&lt;code>PFMERGE&lt;/code>&lt;/strong>：合并多个 HyperLogLog 键的基数估算。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="核心思想">核心思想&lt;/h3>
&lt;p>HyperLogLog 使用概率算法，通过哈希化数据并记录哈希值的前导零数量来估算基数。&lt;/p>
&lt;h5 id="1-哈希函数与二进制表示">&lt;strong>1. 哈希函数与二进制表示&lt;/strong>&lt;/h5>
&lt;p>为了将集合中的元素映射为哈希值，HyperLogLog 使用了 &lt;strong>哈希函数&lt;/strong>。假设我们使用一个 &lt;strong>m-bit&lt;/strong> 的哈希函数，它会把输入数据映射到一个包含 m 位二进制数字的哈希值。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;ul>
&lt;li>假设我们将一个元素哈希成 &lt;code>10111001101100010101010101101010&lt;/code> 这样的 32 位二进制数字。&lt;/li>
&lt;li>这个哈希值的前导零数量就是我们关心的指标。对于这个例子，假设前导零的数量为 3。&lt;/li>
&lt;/ul>
&lt;h5 id="2-关键点记录前导零的数量">&lt;strong>2. 关键点：记录前导零的数量&lt;/strong>&lt;/h5>
&lt;p>HyperLogLog 并不直接存储每个哈希值，而是计算每个哈希值的前导零的数量，把这个值保存在一个桶（通过哈希值的某些位进行映射）中。&lt;/p>
&lt;h5 id="3-桶与桶编号">&lt;strong>3. 桶与桶编号&lt;/strong>&lt;/h5>
&lt;p>为了优化空间，HyperLogLog 使用多个桶来存储不同的哈希值。每个桶的索引是由哈希值的某些位生成的。假设我们有一个桶数量为 &lt;code>b&lt;/code> 的 HyperLogLog。我们将哈希值的前 &lt;code>log2(b)&lt;/code> 位作为桶的索引，其余的位用于计算前导零数量。&lt;/p>
&lt;ul>
&lt;li>例如，如果我们有 16 个桶（&lt;code>b = 16&lt;/code>），则桶的索引由哈希值的前 4 位决定（因为 &lt;code>log2(16) = 4&lt;/code>）。如果哈希值的前 4 位为 &lt;code>1100&lt;/code>，那么该哈希值将被映射到第 12 号桶（因为 &lt;code>1100&lt;/code> 二进制对应 12）。&lt;/li>
&lt;/ul>
&lt;h5 id="4-计算基数估算">&lt;strong>4. 计算基数估算&lt;/strong>&lt;/h5>
&lt;p>HyperLogLog 会计算所有桶中记录的前导零最大值的平均值。然后根据这个平均值来估算整个数据集的基数。&lt;br>
其数学公式如下：&lt;/p></description></item></channel></rss>