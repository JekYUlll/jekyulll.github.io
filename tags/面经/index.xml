<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面经 on Welcome to my Blog ⬆️</title><link>https://jekyulll.github.io/tags/%E9%9D%A2%E7%BB%8F/</link><description>Recent content in 面经 on Welcome to my Blog ⬆️</description><generator>Hugo</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 06 Mar 2025 18:05:47 +0800</lastBuildDate><atom:link href="https://jekyulll.github.io/tags/%E9%9D%A2%E7%BB%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>在运行的时候，修改并且覆盖该二进制文件会如何？</title><link>https://jekyulll.github.io/posts/linux-%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E4%BF%AE%E6%94%B9%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E8%AF%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BC%9A%E5%A6%82%E4%BD%95/</link><pubDate>Thu, 06 Mar 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E4%BF%AE%E6%94%B9%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E8%AF%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BC%9A%E5%A6%82%E4%BD%95/</guid><description>&lt;blockquote>
&lt;p>Linux上有个二进制程序一直在运行，修改代码后重新编译把原来的二进制程序覆盖了，会怎么样？
该问题来自一道天美后台开发面试题：&lt;a href="https://zhuanlan.zhihu.com/p/677307438">天美一面 后台开发（凉） - 牛客面经的文章 - 知乎&lt;/a>。此处尝试进行回答。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>第一想法一般是：“原程序被操作系统加载进内存，不会受到影响。”&lt;br>
系统会创建一个新的&lt;code>inode&lt;/code>指向新文件，而正在运行的进程仍会继续使用旧的&lt;code>inode&lt;/code>对应的代码段。&lt;/p>
&lt;p>但实际上拓展到一个问题：“二进制文件会全部加载到内存吗？”&lt;/p>
&lt;p>ELF二进制文件在加载时，操作系统通常采用按需分页的机制，只将当前需要的部分加载到物理内存，而不是一次性加载整个文件。虚拟内存映射允许文件的部分内容驻留在磁盘，直到被访问时才调入内存。&lt;br>
同时，动态链接库的延迟加载和内存映射文件技术（&lt;code>mmap&lt;/code>）也帮助减少实际内存占用。因此，如果二进制文件很大，不会全部加载到物理内存中，而是按需加载，利用虚拟内存管理技术优化资源使用。&lt;/p>
&lt;p>但是：真的会在运行时加载新的内容吗？&lt;/p>
&lt;p>ELF文件在启动时如何决定哪些内容加载到内存？主要依赖于其&lt;strong>程序头表&lt;/strong>（Program Header Table）​中定义的段（Segment）信息。程序头表由多个&lt;code>Elf64_Phdr&lt;/code>结构体组成，每个结构体描述了一个需要加载到内存的段（如代码段、数据段、动态链接信息段等）。这些段通常包含多个&lt;em>节&lt;/em>（Section）的集合。&lt;/p>
&lt;p>覆盖原文件后，旧文件的磁盘空间不会被立即释放，需等待所有关联进程结束后才能回收（通过&lt;code>lsof&lt;/code>可查看占用进程）。&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>：&lt;br>
​已运行的进程不受影响：Linux通过&lt;code>inode&lt;/code>标识文件，旧进程继续执行内存中已加载的旧代码，与原磁盘文件解耦。&lt;/p>
&lt;hr>
&lt;h3 id="1-elf文件的按需加载机制">1. &lt;strong>ELF文件的按需加载机制&lt;/strong>&lt;/h3>
&lt;p>ELF二进制文件通过&lt;strong>程序头表（Program Header Table）&lt;strong>中的&lt;code>PT_LOAD&lt;/code>段描述需要加载的代码和数据区域。内核的&lt;code>load_elf_binary()&lt;/code>函数会将这些段映射到进程的虚拟地址空间，但实际物理内存的占用是&lt;/strong>按需分页&lt;/strong>的：
• 仅当程序访问某个页（通常4KB大小）时，才会触发缺页异常，将对应内容从磁盘加载到物理内存。
• 未使用的代码或数据（如未执行的函数）可能永远不会被加载到物理内存中。&lt;/p>
&lt;h3 id="2-虚拟内存映射与内存优化">2. &lt;strong>虚拟内存映射与内存优化&lt;/strong>&lt;/h3>
&lt;p>• &lt;strong>虚拟内存优势&lt;/strong>：ELF文件通过&lt;code>mmap()&lt;/code>系统调用映射到虚拟地址空间，此时文件内容并不直接占用物理内存，而是由内核通过页表管理。
• &lt;strong>写时复制（Copy-on-Write）&lt;/strong>：对于只读段（如代码段），多个进程可以共享同一物理内存页；对于可写段，修改时才会复制新页。&lt;/p>
&lt;h3 id="3-动态链接与延迟加载">3. &lt;strong>动态链接与延迟加载&lt;/strong>&lt;/h3>
&lt;p>动态链接库（如&lt;code>.so&lt;/code>文件）在程序运行时通过&lt;code>ld-linux&lt;/code>动态加载器按需载入。例如：
• 首次调用某个库函数时，动态链接器才会加载对应的代码段到内存。
• 部分库可能仅在特定条件下被使用，从而减少初始内存占用。&lt;/p>
&lt;h3 id="4-大文件的实际内存占用">4. &lt;strong>大文件的实际内存占用&lt;/strong>&lt;/h3>
&lt;p>• &lt;strong>物理内存限制&lt;/strong>：若二进制文件极大（如8GB），但程序实际执行的代码路径有限，物理内存占用可能远小于文件大小。
• &lt;strong>交换空间（Swap）&lt;/strong>：当物理内存不足时，操作系统会将不活跃的内存页交换到磁盘，腾出空间供当前进程使用。&lt;/p></description></item><item><title>C++ 同一进程的线程之间共享哪些资源？</title><link>https://jekyulll.github.io/posts/cpp-c++-%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</link><pubDate>Sat, 08 Feb 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</guid><description>&lt;p>同一进程内的线程共享的资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>代码段&lt;/strong>：存放程序的可执行指令，所有线程共享相同的代码段，因此任何线程都可以执行程序中的函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据段&lt;/strong>：包含全局变量和静态变量，这些变量在程序运行期间只有一个实例，所有线程都可以访问和修改它们。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>堆&lt;/strong>：用于动态内存分配，线程可以在堆上分配和释放内存，因此堆上的数据对所有线程可见。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>打开的文件&lt;/strong>：如果程序在运行过程中打开了文件，文件描述符等信息在进程地址空间中保存，所有线程都可以访问这些打开的文件。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>每个线程的私有资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>栈&lt;/strong>：每个线程都有自己的栈空间，用于存储函数的局部变量、返回地址等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>寄存器&lt;/strong>：线程在执行过程中使用的寄存器集是独立的，包括程序计数器（PC）等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>线程局部存储（Thread Local Storage）&lt;/strong>：存放线程私有的全局变量，即使变量名相同，不同线程访问的也是各自独立的副本。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;em>注意&lt;/em>：虽然栈是线程私有的，但由于线程间没有严格的内存隔离机制，一个线程可以通过指针访问和修改另一个线程的栈数据。&lt;/p></description></item><item><title>运行时是把整个动态库都加载到内存中吗？</title><link>https://jekyulll.github.io/posts/cpp-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%98%AF%E6%8A%8A%E6%95%B4%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93%E9%83%BD%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%90%97/</link><pubDate>Sat, 08 Feb 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%98%AF%E6%8A%8A%E6%95%B4%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93%E9%83%BD%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%90%97/</guid><description>&lt;p>在 C++ 中，动态库（如 &lt;code>.dll&lt;/code> 或 &lt;code>.so&lt;/code> 文件）在加载时，操作系统会将整个库文件映射到进程的地址空间中。
&lt;u>具体的函数和数据只有在被实际使用时才会被加载到内存中。&lt;/u>
(动态库作为一个整体被映射，但其中的各个部分仅在需要时才占用物理内存。)&lt;/p>
&lt;p>另外：&lt;br>
C++ 提供了&lt;strong>显式运行时链接&lt;/strong>的机制，程序可以在运行时根据需要动态加载库的特定部分。(&lt;code>dlopen&lt;/code>、&lt;code>dlsym&lt;/code> 等函数)程序可以在运行时按需加载特定的符号（函数或变量）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;dlfcn.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">dlopen&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>filename, &lt;span style="color:#66d9ef">int&lt;/span> flag);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>flag&lt;/code>：指定加载选项：
- &lt;code>RTLD_LAZY&lt;/code>：延迟解析符号，即在实际使用时才解析。&lt;br>
- &lt;code>RTLD_NOW&lt;/code>：立即解析所有未定义的符号。如果无法解析，&lt;code>dlopen&lt;/code> 将返回 &lt;code>NULL&lt;/code>。&lt;br>
- &lt;code>RTLD_GLOBAL&lt;/code>：使加载的库中的符号在后续加载的其他库中可见。&lt;br>
- &lt;code>RTLD_LOCAL&lt;/code>：与 &lt;code>RTLD_GLOBAL&lt;/code> 相反，加载的库中的符号对后续加载的库不可见（这是默认行为）。&lt;/p></description></item></channel></rss>