<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome to My Blog on Horeb's Blog ⬆️</title><link>https://jekyulll.github.io/posts/</link><description>Recent content in Welcome to My Blog on Horeb's Blog ⬆️</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sun, 22 Dec 2024 21:05:47 +0800</lastBuildDate><atom:link href="https://jekyulll.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>实验室服务器使用教程</title><link>https://jekyulll.github.io/posts/normal-%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link><pubDate>Sat, 18 Oct 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/normal-%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid><description>&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>&lt;span style="color: red;">&lt;strong>校外访问请通过校园 VPN&lt;/strong>&lt;/span>&lt;/p>
&lt;h3 id="写作目的">写作目的&lt;/h3>
&lt;p>实验室近期新购置了一台深度学习服务器，供成员进行模型训练、仿真和计算任务。为了帮助大家快速上手、规范使用、避免资源浪费或系统损坏，特编写此教程。内容涵盖服务器的基本概念、各操作系统下的连接方式、Conda 环境的使用，以及图形化（远程桌面）操作方法。&lt;/p>
&lt;h3 id="适用人群">适用人群&lt;/h3>
&lt;ul>
&lt;li>对 Linux 或命令行不熟悉的同学；&lt;/li>
&lt;li>需要进行深度学习、有限元仿真或数据处理的研究生。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="二什么是深度学习服务器">二、什么是“深度学习服务器”&lt;/h2>
&lt;p>深度学习服务器是一台高性能计算机，通常配备多块 GPU（图形处理器）、大容量显存、内存和高速存储。
通常安装Linux系统 ，一般&lt;strong>不直接接显示器&lt;/strong>，而是通过网络远程访问（SSH 或远程桌面）。&lt;/p>
&lt;h3 id="主要用途">主要用途&lt;/h3>
&lt;ul>
&lt;li>深度学习训练（如 PyTorch、TensorFlow）；&lt;/li>
&lt;li>大规模有限元仿真（Abaqus、ANSYS、COMSOL）；&lt;/li>
&lt;li>数据分析、图像识别、模型优化等。&lt;/li>
&lt;/ul>
&lt;h3 id="系统与软件环境">系统与软件环境&lt;/h3>
&lt;ul>
&lt;li>操作系统：Ubuntu 22.04 LTS&lt;/li>
&lt;li>已安装软件：CUDA、cuDNN、Anaconda、Python、JupyterLab&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="三账户与登录信息">三、账户与登录信息&lt;/h2>
&lt;h3 id="账户申请">账户申请&lt;/h3>
&lt;p>新用户请联系实验室管理员开通。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>账户命名规则&lt;/strong>
实验室统一以&lt;em>姓名全拼&lt;/em>作为用户名，例如：&lt;/p>
&lt;ul>
&lt;li>张三 → &lt;em>zhangsan&lt;/em>&lt;/li>
&lt;li>李四 → &lt;em>lisi&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>初始密码&lt;/strong>
所有新账户的初始密码为：&lt;code>123456&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="-手动修改密码必做">🔐 手动修改密码（必做）&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>登录服务器后（见后续教程），在终端输入：&lt;/p>
&lt;pre tabindex="0">&lt;code>passwd
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>系统会提示：&lt;/p>
&lt;pre tabindex="0">&lt;code>Changing password for user zhangsan.
(current) UNIX password:
&lt;/code>&lt;/pre>&lt;p>输入当前密码（即 &lt;code>123456&lt;/code>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接着输入新密码两次（系统不会显示输入内容，但实际上输进去了）：&lt;/p>
&lt;pre tabindex="0">&lt;code>Enter new UNIX password:
Retype new UNIX password:
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>如果两次输入一致，会显示：&lt;/p>
&lt;pre tabindex="0">&lt;code>password updated successfully
&lt;/code>&lt;/pre>&lt;p>表示修改成功。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="网络访问">网络访问&lt;/h3>
&lt;hr>
&lt;h2 id="四连接方式">四、连接方式&lt;/h2>
&lt;h3 id="一windows-用户">（一）Windows 用户&lt;/h3>
&lt;p>此处推荐三个用于连接的终端工具（就是黑窗口，理论上cmd即可，但不够易用）：&lt;/p></description><content type="html"><![CDATA[<h2 id="一前言">一、前言</h2>
<p><span style="color: red;"><strong>校外访问请通过校园 VPN</strong></span></p>
<h3 id="写作目的">写作目的</h3>
<p>实验室近期新购置了一台深度学习服务器，供成员进行模型训练、仿真和计算任务。为了帮助大家快速上手、规范使用、避免资源浪费或系统损坏，特编写此教程。内容涵盖服务器的基本概念、各操作系统下的连接方式、Conda 环境的使用，以及图形化（远程桌面）操作方法。</p>
<h3 id="适用人群">适用人群</h3>
<ul>
<li>对 Linux 或命令行不熟悉的同学；</li>
<li>需要进行深度学习、有限元仿真或数据处理的研究生。</li>
</ul>
<hr>
<h2 id="二什么是深度学习服务器">二、什么是“深度学习服务器”</h2>
<p>深度学习服务器是一台高性能计算机，通常配备多块 GPU（图形处理器）、大容量显存、内存和高速存储。
通常安装Linux系统 ，一般<strong>不直接接显示器</strong>，而是通过网络远程访问（SSH 或远程桌面）。</p>
<h3 id="主要用途">主要用途</h3>
<ul>
<li>深度学习训练（如 PyTorch、TensorFlow）；</li>
<li>大规模有限元仿真（Abaqus、ANSYS、COMSOL）；</li>
<li>数据分析、图像识别、模型优化等。</li>
</ul>
<h3 id="系统与软件环境">系统与软件环境</h3>
<ul>
<li>操作系统：Ubuntu 22.04 LTS</li>
<li>已安装软件：CUDA、cuDNN、Anaconda、Python、JupyterLab</li>
</ul>
<hr>
<h2 id="三账户与登录信息">三、账户与登录信息</h2>
<h3 id="账户申请">账户申请</h3>
<p>新用户请联系实验室管理员开通。</p>
<ol>
<li>
<p><strong>账户命名规则</strong>
实验室统一以<em>姓名全拼</em>作为用户名，例如：</p>
<ul>
<li>张三 → <em>zhangsan</em></li>
<li>李四 → <em>lisi</em></li>
</ul>
</li>
<li>
<p><strong>初始密码</strong>
所有新账户的初始密码为：<code>123456</code></p>
</li>
</ol>
<hr>
<h3 id="-手动修改密码必做">🔐 手动修改密码（必做）</h3>
<ol>
<li>
<p>登录服务器后（见后续教程），在终端输入：</p>
<pre tabindex="0"><code>passwd
</code></pre></li>
<li>
<p>系统会提示：</p>
<pre tabindex="0"><code>Changing password for user zhangsan.
(current) UNIX password:
</code></pre><p>输入当前密码（即 <code>123456</code>）。</p>
</li>
<li>
<p>接着输入新密码两次（系统不会显示输入内容，但实际上输进去了）：</p>
<pre tabindex="0"><code>Enter new UNIX password:
Retype new UNIX password:
</code></pre></li>
<li>
<p>如果两次输入一致，会显示：</p>
<pre tabindex="0"><code>password updated successfully
</code></pre><p>表示修改成功。</p>
</li>
</ol>
<h3 id="网络访问">网络访问</h3>
<hr>
<h2 id="四连接方式">四、连接方式</h2>
<h3 id="一windows-用户">（一）Windows 用户</h3>
<p>此处推荐三个用于连接的终端工具（就是黑窗口，理论上cmd即可，但不够易用）：</p>
<ul>
<li><a href="https://mobaxterm.mobatek.net/">MobaXterm</a></li>
<li><a href="https://www.netsarang.com/en/xshell/">XShell</a></li>
<li><a href="https://termius.com/">Terminus</a></li>
</ul>
<p>此处仅演示MobaXterm。</p>
<hr>
<h3 id="二macos-用户">（二）macOS 用户</h3>
<p><strong>SSH连接</strong>
打开“终端”：</p>
<pre tabindex="0"><code>ssh username@服务器IP
</code></pre><p><strong>文件传输</strong>
可使用命令行：</p>
<pre tabindex="0"><code>scp localfile username@服务器IP:/home/username/
</code></pre><p>或使用图形化工具 Cyberduck / FileZilla。</p>
<p><strong>远程桌面</strong></p>
<ul>
<li>
<p>从 App Store 安装 “Microsoft Remote Desktop”。</p>
</li>
<li>
<p>或安装 XQuartz 后使用命令：</p>
<pre tabindex="0"><code>ssh -X username@服务器IP
</code></pre><p>实现 X11 图形转发。</p>
</li>
</ul>
<hr>
<h3 id="三linux-用户">（三）Linux 用户</h3>
<p><strong>SSH连接</strong></p>
<pre tabindex="0"><code>ssh username@服务器IP
</code></pre><p><strong>文件传输</strong></p>
<pre tabindex="0"><code>scp localfile username@服务器IP:/home/username/
</code></pre><p><strong>远程桌面</strong></p>
<ul>
<li>
<p>使用 Remmina 或 rdesktop 工具。</p>
</li>
<li>
<p>或使用 X11 转发：</p>
<pre tabindex="0"><code>ssh -X username@服务器IP
</code></pre></li>
</ul>
<hr>
<h2 id="五anaconda-与-python-环境管理">五、Anaconda 与 Python 环境管理</h2>
<h3 id="1-anaconda-简介">1. Anaconda 简介</h3>
<p>Anaconda 是一个 Python 环境与包管理工具，可方便地创建独立环境、安装依赖，避免不同项目间的冲突。</p>
<h3 id="2-常用命令">2. 常用命令</h3>
<table>
  <thead>
      <tr>
          <th>操作</th>
          <th>命令示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>创建新环境</td>
          <td><code>conda create -n myenv python=3.10</code></td>
      </tr>
      <tr>
          <td>激活环境</td>
          <td><code>conda activate myenv</code></td>
      </tr>
      <tr>
          <td>安装包</td>
          <td><code>conda install numpy pandas pytorch</code></td>
      </tr>
      <tr>
          <td>查看环境</td>
          <td><code>conda env list</code></td>
      </tr>
      <tr>
          <td>删除环境</td>
          <td><code>conda remove -n myenv --all</code></td>
      </tr>
  </tbody>
</table>
<h3 id="3-推荐做法">3. 推荐做法</h3>
<p>管理员会准备一个预装常用框架（PyTorch、TensorFlow）的基础环境：</p>
<pre tabindex="0"><code>conda create -n myenv --clone dl_env
</code></pre><p>这样可快速获得标准配置。</p>
<h3 id="4-使用-jupyterlab可选">4. 使用 JupyterLab（可选）</h3>
<p>在服务器上启动：</p>
<pre tabindex="0"><code>jupyter lab --no-browser --port=8888
</code></pre><p>然后在本地终端执行：</p>
<pre tabindex="0"><code>ssh -L 8888:localhost:8888 username@服务器IP
</code></pre><p>本地浏览器访问：</p>
<pre tabindex="0"><code>http://localhost:8888
</code></pre><hr>
<h2 id="六远程桌面与图形化软件">六、远程桌面与图形化软件</h2>
<h3 id="1-适用场景">1. 适用场景</h3>
<p>用于运行图形化仿真软件（Abaqus、ANSYS、COMSOL、Matlab 等）。</p>
<h3 id="2-配置方式由管理员完成">2. 配置方式（由管理员完成）</h3>
<ul>
<li>启用 <code>xrdp</code> 服务；</li>
<li>为每个用户创建独立桌面会话。</li>
</ul>
<h3 id="3-用户连接方式">3. 用户连接方式</h3>
<table>
  <thead>
      <tr>
          <th>系统</th>
          <th>工具</th>
          <th>登录方式</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Windows</td>
          <td>远程桌面连接 (mstsc)</td>
          <td>输入 IP、用户名、密码</td>
      </tr>
      <tr>
          <td>macOS</td>
          <td>Microsoft Remote Desktop</td>
          <td>App Store 可下载</td>
      </tr>
      <tr>
          <td>Linux</td>
          <td>Remmina</td>
          <td>支持 RDP 协议</td>
      </tr>
  </tbody>
</table>
<h3 id="4-注意事项">4. 注意事项</h3>
<ul>
<li>远程桌面会占用 GPU 和内存资源，不建议长时间挂起。</li>
<li>深度学习训练任务应通过命令行执行。</li>
</ul>
<hr>
<h2 id="七文件管理与备份">七、文件管理与备份</h2>
<h3 id="1-目录说明">1. 目录说明</h3>
<table>
  <thead>
      <tr>
          <th>路径</th>
          <th>用途</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>/home/username</td>
          <td>用户个人目录</td>
      </tr>
      <tr>
          <td>/data</td>
          <td>公共数据集或模型</td>
      </tr>
      <tr>
          <td>/workspace</td>
          <td>项目工作区（可按课题分目录）</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="八服务器使用规范">八、服务器使用规范</h2>
<ol>
<li>
<p>不要在系统目录（<code>/</code>、<code>/root</code>）下操作。</p>
</li>
<li>
<p>运行长时间任务时请使用：</p>
<pre tabindex="0"><code>nohup python train.py &gt; log.txt 2&gt;&amp;1 &amp;
</code></pre><p>或在 tmux 会话中执行。</p>
</li>
<li>
<p>请勿重启服务器。</p>
</li>
<li>
<p>任务结束后释放显存和进程。</p>
</li>
<li>
<p>请勿安装系统级软件，如需<code>sudo</code>权限请在群里询问。</p>
</li>
</ol>
<hr>
<h2 id="九常见问题faq">九、常见问题（FAQ）</h2>
<table>
  <thead>
      <tr>
          <th>问题</th>
          <th>解决方法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>SSH 连不上</td>
          <td>检查网络/VPN，确认端口22是否开放</td>
      </tr>
      <tr>
          <td>GPU 已占满</td>
          <td>使用 <code>nvidia-smi</code> 查看使用者，协商使用</td>
      </tr>
      <tr>
          <td>Conda 包冲突</td>
          <td>新建独立环境</td>
      </tr>
      <tr>
          <td>Jupyter 无法访问</td>
          <td>检查端口转发是否正确</td>
      </tr>
      <tr>
          <td>远程桌面卡顿</td>
          <td>降低分辨率或关闭3D加速</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="十附录">十、附录</h2>
<h3 id="常用命令速查">常用命令速查</h3>
<pre tabindex="0"><code>nvidia-smi          # 查看GPU
pwd                 # 显示当前路径
ls -lh              # 列出文件
scp localfile user@ip:/home/user/   # 上传文件
conda create -n myenv python=3.10   # 创建新环境
</code></pre><h3 id="管理员联系方式">管理员联系方式</h3>
<p><img src="images/wechat.jpg" alt="微信"></p>
<h3 id="推荐学习资料">推荐学习资料</h3>
<ul>
<li>Linux命令快速入门：<a href="https://wangchujiang.com/linux-command/">https://wangchujiang.com/linux-command/</a></li>
<li>Anaconda官方文档：<a href="https://docs.anaconda.com/">https://docs.anaconda.com/</a></li>
<li>PyTorch教程：<a href="https://pytorch.org/tutorials/">https://pytorch.org/tutorials/</a></li>
</ul>
<hr>
<h3 id="参考文档">参考文档</h3>
<p><a href="https://zhuanlan.zhihu.com/p/422462131">实验室GPU管理神器Determined - 吕昱峰的文章 - 知乎</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/1908296804832879701">实验室服务器管理经验 - PurRigiN的文章 - 知乎</a>。</p>
<p><a href="https://blog.csdn.net/qq_38356397/article/details/103166234">手把手教你如何连上实验室的服务器</a>。</p>
<p><a href="https://blog.csdn.net/qq_44773719/article/details/104352965">Mac下使用SSH连接远程Linux服务器</a>。</p>
<p><a href="https://ajohn.top/article/bes1sa4i/">实验室服务器使用教程（用户篇）</a>。</p>
<p><a href="https://github.com/yurizzzzz/TJU-ServerDoc">yurizzzzz/TJU-ServerDoc 天津大学实验室服务器使用和管理</a>。</p>
<p>非常好 👍，这是一个非常重要的安全环节。
我在原教程的逻辑结构里帮你加上**“初次登录与修改密码”**部分，同时优化了一些上下衔接，使它自然融入第“三章：账户与登录信息”中。下面是修订后的完整段落（你可以直接替换原文对应章节）。</p>
<hr>
<h2 id="三账户与登录信息-1">三、账户与登录信息</h2>
<h3 id="-账户申请与登录方式">🪪 账户申请与登录方式</h3>
<ol start="5">
<li>
<p>建议密码：</p>
<ul>
<li>至少 8 位；</li>
<li>包含数字、大写字母和符号；</li>
<li>避免使用生日、手机号等弱口令。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="-网络访问信息">🌐 网络访问信息</h3>
<ul>
<li><strong>服务器 IP</strong>：由管理员提供。</li>
<li><strong>SSH 端口</strong>：默认 22。</li>
<li><strong>远程桌面端口（RDP）</strong>：默认 3389（如启用 xrdp）。</li>
<li><strong>校外访问</strong>：需先连接校园 VPN。</li>
</ul>
<hr>
<h3 id="-用户目录结构">📁 用户目录结构</h3>
<p>每位用户登录后默认进入自己的 home 目录：</p>
<pre tabindex="0"><code>/home/username
</code></pre><p>该目录下的文件仅本人可访问。
公共数据和项目文件位于：</p>
<pre tabindex="0"><code>/data      # 公共数据集区
/workspace # 项目工作区，可按课题划分
</code></pre><hr>
<h3 id="-注意事项">⚠️ 注意事项</h3>
<ul>
<li>请务必在首次登录后立即修改密码，否则管理员将强制重置账号。</li>
<li>请不要尝试修改其他用户的文件或目录权限。</li>
<li>若忘记密码，请联系管理员重置。</li>
</ul>
<hr>
<p>是否希望我帮你把这一章节整合进整份完整文档（含前面那版内容），形成一个<strong>最终版服务器使用手册</strong>？
我可以帮你输出一个可以直接发群、存Wiki或导出PDF的“正式成品版”。</p>
]]></content></item><item><title>容器化技术之 Linux namespace</title><link>https://jekyulll.github.io/posts/linux-%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B9%8B-linux-namespace/</link><pubDate>Sun, 08 Jun 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B9%8B-linux-namespace/</guid><description>&lt;p>Linux namespace做一层资源隔离，使里面的进程/进程组看起来拥有自己的独立资源。&lt;/p>
&lt;p>PID namespace 中的 &lt;code>init&lt;/code> 进程（PID=1）需要正确处理子进程的僵尸状态，否则会导致资源泄漏。&lt;/p>
&lt;p>有多种namespace:&lt;/p>
&lt;ul>
&lt;li>PID Namespace（CLONE_NEWPID）：不同 namespace 中的进程可以拥有相同的 PID&lt;/li>
&lt;li>Network Namespace（CLONE_NEWNET）：隔离网络栈，包括网络设备、IP 地址、端口、路由表以及防火墙规则&lt;/li>
&lt;li>Mount Namespace（CLONE_NEWNS）：隔离文件系统挂载点&lt;/li>
&lt;li>User Namespace（CLONE_NEWUSER）：隔离用户和组 ID 空间，允许同一个用户在不同 namespace 中拥有不同的权限&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>Docker 容器默认会使用以下 namespace：&lt;/p>
&lt;ul>
&lt;li>PID：隔离进程树。&lt;/li>
&lt;li>NET：提供独立的网络栈。&lt;/li>
&lt;li>IPC：隔离进程间通信。&lt;/li>
&lt;li>UTS：设置独立的主机名。&lt;/li>
&lt;li>MOUNT：隔离文件系统挂载点。&lt;/li>
&lt;li>USER：用于映射容器内的 root 用户到宿主机的普通用户。&lt;/li>
&lt;/ul>
&lt;p>每个进程的 namespace 信息都存储在/proc/[pid]/ns目录下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ls -l /proc/self/ns
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 cgroup -&amp;gt; &amp;#39;cgroup:[4026531835]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 ipc -&amp;gt; &amp;#39;ipc:[4026531839]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 mnt -&amp;gt; &amp;#39;mnt:[4026531840]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 net -&amp;gt; &amp;#39;net:[4026531956]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 pid -&amp;gt; &amp;#39;pid:[4026531836]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 pid_for_children -&amp;gt; &amp;#39;pid:[4026531836]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 user -&amp;gt; &amp;#39;user:[4026531837]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 uts -&amp;gt; &amp;#39;uts:[4026531838]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="如何创建">如何创建？&lt;/h3>
&lt;ol>
&lt;li>使用&lt;code>unshare&lt;/code>命令创建 namespace：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建新的挂载点和PID namespace，并在其中启动bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>unshare --mount --pid --fork bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在新的namespace中查看PID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $$ &lt;span style="color:#75715e"># 输出通常为1，表示当前bash是新namespace中的第一个进程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看当前namespace中的进程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ps aux
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>使用&lt;code>clone()&lt;/code>系统调用&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define _GNU_SOURCE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sched.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/wait.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 子进程执行的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">child_func&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>arg) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在新的UTS namespace中设置主机名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> sethostname(&lt;span style="color:#e6db74">&amp;#34;container&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 输出当前进程ID和主机名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;子进程PID: %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, getpid());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;主机名: %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;container&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> execlp(&lt;span style="color:#e6db74">&amp;#34;/bin/bash&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;bash&amp;#34;&lt;/span>, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> STACK_SIZE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">65536&lt;/span>; &lt;span style="color:#75715e">// 为子进程分配栈空间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>stack &lt;span style="color:#f92672">=&lt;/span> malloc(STACK_SIZE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>stack) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;内存分配失败&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置栈顶（栈是向下增长的）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>stack_top &lt;span style="color:#f92672">=&lt;/span> stack &lt;span style="color:#f92672">+&lt;/span> STACK_SIZE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建新的UTS和PID namespace，并启动子进程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pid_t pid &lt;span style="color:#f92672">=&lt;/span> clone(child_func, stack_top,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CLONE_NEWUTS &lt;span style="color:#f92672">|&lt;/span> CLONE_NEWPID &lt;span style="color:#f92672">|&lt;/span> SIGCHLD, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pid &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;clone失败&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 等待子进程结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> waitpid(pid, NULL, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(stack);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>使用&lt;code>setns()&lt;/code>加入现有 namespace&lt;br>
加入另一个进程的网络 namespace：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define _GNU_SOURCE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;fcntl.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sched.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 打开目标进程的网络namespace文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;/proc/1234/ns/net&amp;#34;&lt;/span>, O_RDONLY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fd &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;打开namespace文件失败&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 加入目标namespace
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (setns(fd, CLONE_NEWNET) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;加入namespace失败&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(fd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行需要在目标namespace中运行的命令
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> execlp(&lt;span style="color:#e6db74">&amp;#34;ip&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ip&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;addr&amp;#34;&lt;/span>, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>使用&lt;code>nsenter&lt;/code>命令（简化版&lt;code>setns()&lt;/code>）&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo nsenter --target &lt;span style="color:#ae81ff">1234&lt;/span> --net ip addr
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description><content type="html"><![CDATA[<p>Linux namespace做一层资源隔离，使里面的进程/进程组看起来拥有自己的独立资源。</p>
<p>PID namespace 中的 <code>init</code> 进程（PID=1）需要正确处理子进程的僵尸状态，否则会导致资源泄漏。</p>
<p>有多种namespace:</p>
<ul>
<li>PID Namespace（CLONE_NEWPID）：不同 namespace 中的进程可以拥有相同的 PID</li>
<li>Network Namespace（CLONE_NEWNET）：隔离网络栈，包括网络设备、IP 地址、端口、路由表以及防火墙规则</li>
<li>Mount Namespace（CLONE_NEWNS）：隔离文件系统挂载点</li>
<li>User Namespace（CLONE_NEWUSER）：隔离用户和组 ID 空间，允许同一个用户在不同 namespace 中拥有不同的权限</li>
<li>&hellip;</li>
</ul>
<p>Docker 容器默认会使用以下 namespace：</p>
<ul>
<li>PID：隔离进程树。</li>
<li>NET：提供独立的网络栈。</li>
<li>IPC：隔离进程间通信。</li>
<li>UTS：设置独立的主机名。</li>
<li>MOUNT：隔离文件系统挂载点。</li>
<li>USER：用于映射容器内的 root 用户到宿主机的普通用户。</li>
</ul>
<p>每个进程的 namespace 信息都存储在/proc/[pid]/ns目录下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls -l /proc/self/ns
</span></span><span style="display:flex;"><span><span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 cgroup -&gt; &#39;cgroup:[4026531835]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 ipc -&gt; &#39;ipc:[4026531839]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 mnt -&gt; &#39;mnt:[4026531840]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 net -&gt; &#39;net:[4026531956]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 pid -&gt; &#39;pid:[4026531836]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 pid_for_children -&gt; &#39;pid:[4026531836]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 user -&gt; &#39;user:[4026531837]&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 uts -&gt; &#39;uts:[4026531838]&#39;</span>
</span></span></code></pre></div><h3 id="如何创建">如何创建？</h3>
<ol>
<li>使用<code>unshare</code>命令创建 namespace：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 创建新的挂载点和PID namespace，并在其中启动bash</span>
</span></span><span style="display:flex;"><span>unshare --mount --pid --fork bash
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 在新的namespace中查看PID</span>
</span></span><span style="display:flex;"><span>echo $$  <span style="color:#75715e"># 输出通常为1，表示当前bash是新namespace中的第一个进程</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看当前namespace中的进程</span>
</span></span><span style="display:flex;"><span>ps aux
</span></span></code></pre></div><ol start="2">
<li>使用<code>clone()</code>系统调用</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#define _GNU_SOURCE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/wait.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 子进程执行的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">child_func</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在新的UTS namespace中设置主机名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sethostname(<span style="color:#e6db74">&#34;container&#34;</span>, <span style="color:#ae81ff">9</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 输出当前进程ID和主机名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;子进程PID: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;主机名: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;container&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    execlp(<span style="color:#e6db74">&#34;/bin/bash&#34;</span>, <span style="color:#e6db74">&#34;bash&#34;</span>, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> STACK_SIZE <span style="color:#f92672">=</span> <span style="color:#ae81ff">65536</span>; <span style="color:#75715e">// 为子进程分配栈空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>stack <span style="color:#f92672">=</span> malloc(STACK_SIZE);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>stack) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;内存分配失败&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置栈顶（栈是向下增长的）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>stack_top <span style="color:#f92672">=</span> stack <span style="color:#f92672">+</span> STACK_SIZE;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建新的UTS和PID namespace，并启动子进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pid_t pid <span style="color:#f92672">=</span> clone(child_func, stack_top, 
</span></span><span style="display:flex;"><span>                     CLONE_NEWUTS <span style="color:#f92672">|</span> CLONE_NEWPID <span style="color:#f92672">|</span> SIGCHLD, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;clone失败&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 等待子进程结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    waitpid(pid, NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    free(stack);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="3">
<li>使用<code>setns()</code>加入现有 namespace<br>
加入另一个进程的网络 namespace：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#define _GNU_SOURCE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打开目标进程的网络namespace文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/proc/1234/ns/net&#34;</span>, O_RDONLY);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;打开namespace文件失败&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 加入目标namespace
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (setns(fd, CLONE_NEWNET) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;加入namespace失败&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    close(fd);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行需要在目标namespace中运行的命令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    execlp(<span style="color:#e6db74">&#34;ip&#34;</span>, <span style="color:#e6db74">&#34;ip&#34;</span>, <span style="color:#e6db74">&#34;addr&#34;</span>, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="4">
<li>使用<code>nsenter</code>命令（简化版<code>setns()</code>）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nsenter --target <span style="color:#ae81ff">1234</span> --net ip addr
</span></span></code></pre></div>]]></content></item><item><title>【仅源码】C语言通过getaddrinfo函数获取域名的IP地址</title><link>https://jekyulll.github.io/posts/cppc%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87getaddrinfo%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%9F%9F%E5%90%8D%E7%9A%84ip%E5%9C%B0%E5%9D%80/</link><pubDate>Thu, 08 May 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cppc%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87getaddrinfo%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%9F%9F%E5%90%8D%E7%9A%84ip%E5%9C%B0%E5%9D%80/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/socket.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;netdb.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;arpa/inet.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2025/05/08
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// C语言通过getaddrinfo函数获取域名的IP地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">addrinfo&lt;/span> hints, &lt;span style="color:#f92672">*&lt;/span>res, &lt;span style="color:#f92672">*&lt;/span>p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> status;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> ipstr[INET6_ADDRSTRLEN];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 初始化hints结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>hints, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span> hints);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hints.ai_family &lt;span style="color:#f92672">=&lt;/span> AF_UNSPEC; &lt;span style="color:#75715e">// IPv4 或者 IPv6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> hints.ai_socktype &lt;span style="color:#f92672">=&lt;/span> SOCK_STREAM; &lt;span style="color:#75715e">// TCP 套接字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取地址信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> ((status &lt;span style="color:#f92672">=&lt;/span> getaddrinfo(&lt;span style="color:#e6db74">&amp;#34;www.baidu.com&amp;#34;&lt;/span>, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>hints, &lt;span style="color:#f92672">&amp;amp;&lt;/span>res)) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fprintf(stderr, &lt;span style="color:#e6db74">&amp;#34;getaddrinfo error: %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, gai_strerror(status));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 遍历地址列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(p &lt;span style="color:#f92672">=&lt;/span> res; p &lt;span style="color:#f92672">!=&lt;/span> NULL; p &lt;span style="color:#f92672">=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ipver;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取 IP 地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_family &lt;span style="color:#f92672">==&lt;/span> AF_INET) { &lt;span style="color:#75715e">// IPv4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ipv4 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>(ipv4&lt;span style="color:#f92672">-&amp;gt;&lt;/span>sin_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ipver &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;IPv4&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#75715e">// IPv6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in6&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ipv6 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in6&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>(ipv6&lt;span style="color:#f92672">-&amp;gt;&lt;/span>sin6_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ipver &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;IPv6&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将二进制 IP 地址转换为文本格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> inet_ntop(p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_family, addr, ipstr, &lt;span style="color:#66d9ef">sizeof&lt;/span> ipstr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%s: %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, ipver, ipstr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 释放地址信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> freeaddrinfo(res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description><content type="html"><![CDATA[<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netdb.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2025/05/08
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// C语言通过getaddrinfo函数获取域名的IP地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">addrinfo</span> hints, <span style="color:#f92672">*</span>res, <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> status;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> ipstr[INET6_ADDRSTRLEN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化hints结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    memset(<span style="color:#f92672">&amp;</span>hints, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span> hints);
</span></span><span style="display:flex;"><span>    hints.ai_family <span style="color:#f92672">=</span> AF_UNSPEC; <span style="color:#75715e">// IPv4 或者 IPv6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    hints.ai_socktype <span style="color:#f92672">=</span> SOCK_STREAM; <span style="color:#75715e">// TCP 套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取地址信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((status <span style="color:#f92672">=</span> getaddrinfo(<span style="color:#e6db74">&#34;www.baidu.com&#34;</span>, NULL, <span style="color:#f92672">&amp;</span>hints, <span style="color:#f92672">&amp;</span>res)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        fprintf(stderr, <span style="color:#e6db74">&#34;getaddrinfo error: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, gai_strerror(status));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历地址列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(p <span style="color:#f92672">=</span> res; p <span style="color:#f92672">!=</span> NULL; p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>ai_next) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ipver;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取 IP 地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>ai_family <span style="color:#f92672">==</span> AF_INET) { <span style="color:#75715e">// IPv4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> <span style="color:#f92672">*</span>ipv4 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> <span style="color:#f92672">*</span>)p<span style="color:#f92672">-&gt;</span>ai_addr;
</span></span><span style="display:flex;"><span>            addr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(ipv4<span style="color:#f92672">-&gt;</span>sin_addr);
</span></span><span style="display:flex;"><span>            ipver <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;IPv4&#34;</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// IPv6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in6</span> <span style="color:#f92672">*</span>ipv6 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in6</span> <span style="color:#f92672">*</span>)p<span style="color:#f92672">-&gt;</span>ai_addr;
</span></span><span style="display:flex;"><span>            addr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(ipv6<span style="color:#f92672">-&gt;</span>sin6_addr);
</span></span><span style="display:flex;"><span>            ipver <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;IPv6&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将二进制 IP 地址转换为文本格式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        inet_ntop(p<span style="color:#f92672">-&gt;</span>ai_family, addr, ipstr, <span style="color:#66d9ef">sizeof</span> ipstr);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%s: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ipver, ipstr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 释放地址信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    freeaddrinfo(res);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>Redis Stream和MQ</title><link>https://jekyulll.github.io/posts/redis-redis-stream%E5%92%8Cmq/</link><pubDate>Mon, 05 May 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/redis-redis-stream%E5%92%8Cmq/</guid><description>&lt;p>常见MQ的功能，有哪些是用Redis实现不了的？&lt;/p>
&lt;p>消息队列（MQ）用于解耦系统、异步处理、削峰填谷等，常见的 MQ 有 RabbitMQ、Kafka、RocketMQ、ActiveMQ 等。而 Redis 也提供了发布/订阅（pub/sub）、List 队列、Stream（流）等机制，看似也能实现部分消息队列的功能。&lt;/p>
&lt;hr>
&lt;h3 id="-redis-能做的-mq-功能">✅ Redis 能做的 MQ 功能：&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>功能&lt;/th>
&lt;th>Redis 支持方式&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>简单队列&lt;/td>
&lt;td>使用 &lt;code>List&lt;/code> 的 &lt;code>LPUSH + BRPOP&lt;/code> 实现&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>发布订阅&lt;/td>
&lt;td>使用 &lt;code>Pub/Sub&lt;/code> 功能&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>消息流&lt;/td>
&lt;td>使用 &lt;code>Stream&lt;/code> 类型（自 Redis 5.0 起）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>消息持久化（有限）&lt;/td>
&lt;td>Redis 有持久化机制（RDB、AOF）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="-redis-实现不了或不擅长的-mq-功能">❌ Redis 实现不了或不擅长的 MQ 功能：&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>功能&lt;/th>
&lt;th>原因&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>消息可靠投递（ACK 确认机制）&lt;/strong>&lt;/td>
&lt;td>Redis 的 Pub/Sub 没有消费确认机制，Stream 有但比较弱（如无消费失败自动重试机制）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>高吞吐量/分布式日志系统（如 Kafka）&lt;/strong>&lt;/td>
&lt;td>Redis 不适合大规模日志或百万 TPS 场景，且不具备分区（partition）机制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>消费失败后的重试机制、死信队列（DLQ）&lt;/strong>&lt;/td>
&lt;td>Redis 不原生支持，需要手动构建（逻辑复杂且不够健壮）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>消费顺序保障（partition+offset）&lt;/strong>&lt;/td>
&lt;td>Redis Stream 提供 ID 顺序，但无法如 Kafka 那样做严格的有序分区消费&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>持久性保证和磁盘容量优化&lt;/strong>&lt;/td>
&lt;td>Redis 为内存数据库，持久性和存储成本远不如 Kafka 等磁盘级 MQ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>消息积压处理能力强&lt;/strong>&lt;/td>
&lt;td>Redis 基于内存，积压消息多了容易 OOM，Kafka 之类基于磁盘无此问题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>事务性消息支持（如 RocketMQ）&lt;/strong>&lt;/td>
&lt;td>Redis 不支持事务性消息逻辑&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>消费者分组与负载均衡（Consumer Group）&lt;/strong>&lt;/td>
&lt;td>Redis Stream 有些类似功能，但不如 Kafka 灵活和成熟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>流控和限速、幂等机制支持&lt;/strong>&lt;/td>
&lt;td>Redis 需要自己实现，Kafka 等 MQ 内建支持&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;ul>
&lt;li>Redis 可以用来实现轻量级、简单或低吞吐的消息队列系统；&lt;/li>
&lt;li>Kafka、RabbitMQ、RocketMQ 等更适合需要&lt;strong>高可靠性、分布式、高吞吐、复杂消息模式&lt;/strong>的场景；&lt;/li>
&lt;li>Redis 适合“玩具级”或轻量任务队列，&lt;strong>不推荐在企业级复杂系统中用作核心 MQ&lt;/strong>。&lt;/li>
&lt;/ul></description><content type="html"><![CDATA[<p>常见MQ的功能，有哪些是用Redis实现不了的？</p>
<p>消息队列（MQ）用于解耦系统、异步处理、削峰填谷等，常见的 MQ 有 RabbitMQ、Kafka、RocketMQ、ActiveMQ 等。而 Redis 也提供了发布/订阅（pub/sub）、List 队列、Stream（流）等机制，看似也能实现部分消息队列的功能。</p>
<hr>
<h3 id="-redis-能做的-mq-功能">✅ Redis 能做的 MQ 功能：</h3>
<table>
  <thead>
      <tr>
          <th>功能</th>
          <th>Redis 支持方式</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>简单队列</td>
          <td>使用 <code>List</code> 的 <code>LPUSH + BRPOP</code> 实现</td>
      </tr>
      <tr>
          <td>发布订阅</td>
          <td>使用 <code>Pub/Sub</code> 功能</td>
      </tr>
      <tr>
          <td>消息流</td>
          <td>使用 <code>Stream</code> 类型（自 Redis 5.0 起）</td>
      </tr>
      <tr>
          <td>消息持久化（有限）</td>
          <td>Redis 有持久化机制（RDB、AOF）</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="-redis-实现不了或不擅长的-mq-功能">❌ Redis 实现不了或不擅长的 MQ 功能：</h3>
<table>
  <thead>
      <tr>
          <th>功能</th>
          <th>原因</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>消息可靠投递（ACK 确认机制）</strong></td>
          <td>Redis 的 Pub/Sub 没有消费确认机制，Stream 有但比较弱（如无消费失败自动重试机制）</td>
      </tr>
      <tr>
          <td><strong>高吞吐量/分布式日志系统（如 Kafka）</strong></td>
          <td>Redis 不适合大规模日志或百万 TPS 场景，且不具备分区（partition）机制</td>
      </tr>
      <tr>
          <td><strong>消费失败后的重试机制、死信队列（DLQ）</strong></td>
          <td>Redis 不原生支持，需要手动构建（逻辑复杂且不够健壮）</td>
      </tr>
      <tr>
          <td><strong>消费顺序保障（partition+offset）</strong></td>
          <td>Redis Stream 提供 ID 顺序，但无法如 Kafka 那样做严格的有序分区消费</td>
      </tr>
      <tr>
          <td><strong>持久性保证和磁盘容量优化</strong></td>
          <td>Redis 为内存数据库，持久性和存储成本远不如 Kafka 等磁盘级 MQ</td>
      </tr>
      <tr>
          <td><strong>消息积压处理能力强</strong></td>
          <td>Redis 基于内存，积压消息多了容易 OOM，Kafka 之类基于磁盘无此问题</td>
      </tr>
      <tr>
          <td><strong>事务性消息支持（如 RocketMQ）</strong></td>
          <td>Redis 不支持事务性消息逻辑</td>
      </tr>
      <tr>
          <td><strong>消费者分组与负载均衡（Consumer Group）</strong></td>
          <td>Redis Stream 有些类似功能，但不如 Kafka 灵活和成熟</td>
      </tr>
      <tr>
          <td><strong>流控和限速、幂等机制支持</strong></td>
          <td>Redis 需要自己实现，Kafka 等 MQ 内建支持</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="总结">总结</h3>
<ul>
<li>Redis 可以用来实现轻量级、简单或低吞吐的消息队列系统；</li>
<li>Kafka、RabbitMQ、RocketMQ 等更适合需要<strong>高可靠性、分布式、高吞吐、复杂消息模式</strong>的场景；</li>
<li>Redis 适合“玩具级”或轻量任务队列，<strong>不推荐在企业级复杂系统中用作核心 MQ</strong>。</li>
</ul>
]]></content></item><item><title>[linux] TODO 守护进程，setsid，Linux三个id，权限</title><link>https://jekyulll.github.io/posts/linux-todo-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8Bsetsidlinux%E4%B8%89%E4%B8%AAid%E6%9D%83%E9%99%90/</link><pubDate>Tue, 29 Apr 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-todo-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8Bsetsidlinux%E4%B8%89%E4%B8%AAid%E6%9D%83%E9%99%90/</guid><description>&lt;p>复习：&lt;a href="https://blog.csdn.net/JMW1407/article/details/108412836">【Linux】守护进程（ Daemon）的定义，作用，创建流程&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/liaowenxiong/article/details/116401524">Linux 命令之 &lt;code>locale&lt;/code> &amp;ndash; 设置和显示程序运行的语言环境&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>使用 &lt;code>locale&lt;/code> 命令来设置和显示程序运行的语言环境，&lt;code>locale&lt;/code> 会根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统定义一个软件运行时的语言环境。&lt;br>
&lt;code>locale&lt;/code> 由ANSI C提供支持。&lt;code>locale&lt;/code> 的命名规则为&lt;code>&amp;lt;语言&amp;gt;_&amp;lt;地区&amp;gt;.&amp;lt;字符集编码&amp;gt;&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://blog.csdn.net/fmeng23/article/details/23115989">深刻理解——real user id, effective user id, saved user id in Linux&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/ybxuwei/article/details/23563423">Linux进程权限的研究——real user id, effective user id, saved set-user-id&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo $UID
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description><content type="html"><![CDATA[<p>复习：<a href="https://blog.csdn.net/JMW1407/article/details/108412836">【Linux】守护进程（ Daemon）的定义，作用，创建流程</a>。</p>
<p><a href="https://blog.csdn.net/liaowenxiong/article/details/116401524">Linux 命令之 <code>locale</code> &ndash; 设置和显示程序运行的语言环境</a>。</p>
<blockquote>
<p>使用 <code>locale</code> 命令来设置和显示程序运行的语言环境，<code>locale</code> 会根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统定义一个软件运行时的语言环境。<br>
<code>locale</code> 由ANSI C提供支持。<code>locale</code> 的命名规则为<code>&lt;语言&gt;_&lt;地区&gt;.&lt;字符集编码&gt;</code>。</p>
</blockquote>
<p><a href="https://blog.csdn.net/fmeng23/article/details/23115989">深刻理解——real user id, effective user id, saved user id in Linux</a>。<br>
<a href="https://blog.csdn.net/ybxuwei/article/details/23563423">Linux进程权限的研究——real user id, effective user id, saved set-user-id</a>。</p>
<blockquote>
<p>调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo $UID
</span></span></code></pre></div>]]></content></item><item><title>[linux] 在wezterm里使用tmux实现history restore 保存历史会话</title><link>https://jekyulll.github.io/posts/linux-tmux%E5%AE%9E%E7%8E%B0wezterm%E4%BF%9D%E5%AD%98%E4%BC%9A%E8%AF%9D/</link><pubDate>Tue, 29 Apr 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-tmux%E5%AE%9E%E7%8E%B0wezterm%E4%BF%9D%E5%AD%98%E4%BC%9A%E8%AF%9D/</guid><description>&lt;hr>
&lt;p>知乎链接：https://zhuanlan.zhihu.com/p/1961547067106259944&lt;/p>
&lt;p>wezterm在打开主进程、或者ctrl+alt+t新建tab的时候默认是空的shell会话，有时候不够方便。&lt;/p>
&lt;p>tmux可以轻松解决痛点，但是如果设置wezterm的default_prog为tmux（即每次会话都启动）：在wezterm里新建tab，你会发现和之前共享同一个tmux，相当于wezterm自带的tab功能没用了。&lt;/p>
&lt;pre>&lt;code>config.default_prog = { &amp;quot;/usr/bin/tmux&amp;quot;, &amp;quot;new-session&amp;quot;, &amp;quot;-A&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;main&amp;quot; }
&lt;/code>&lt;/pre>
&lt;p>于是：能否只让wezterm的第一个tab始终开启一个tmux来保存会话，其他tab则使用默认的新建shell功能？&lt;/p>
&lt;p>具体实现：&lt;/p>
&lt;pre>&lt;code>-- 第一个tab打开tmux，之后的为空的shell
local tmux_started = false
wezterm.on(&amp;quot;gui-startup&amp;quot;, function(cmd)
-- 启动 wezterm 时自动打开一个 window
local tab, pane, window = wezterm.mux.spawn_window(cmd or {})
if not tmux_started then
tmux_started = true
-- 启动 tmux
pane:send_text(&amp;quot;tmux -u new-session -A -s main\n&amp;quot;)
end
end)
&lt;/code>&lt;/pre>
&lt;p>加在wezterm配置合适的位置即可。&lt;/p></description><content type="html"><![CDATA[<hr>
<p>知乎链接：https://zhuanlan.zhihu.com/p/1961547067106259944</p>
<p>wezterm在打开主进程、或者ctrl+alt+t新建tab的时候默认是空的shell会话，有时候不够方便。</p>
<p>tmux可以轻松解决痛点，但是如果设置wezterm的default_prog为tmux（即每次会话都启动）：在wezterm里新建tab，你会发现和之前共享同一个tmux，相当于wezterm自带的tab功能没用了。</p>
<pre><code>config.default_prog = { &quot;/usr/bin/tmux&quot;, &quot;new-session&quot;, &quot;-A&quot;, &quot;-s&quot;, &quot;main&quot; }
</code></pre>
<p>于是：能否只让wezterm的第一个tab始终开启一个tmux来保存会话，其他tab则使用默认的新建shell功能？</p>
<p>具体实现：</p>
<pre><code>-- 第一个tab打开tmux，之后的为空的shell
local tmux_started = false
wezterm.on(&quot;gui-startup&quot;, function(cmd)
	-- 启动 wezterm 时自动打开一个 window
	local tab, pane, window = wezterm.mux.spawn_window(cmd or {})
	if not tmux_started then
		tmux_started = true
		-- 启动 tmux
		pane:send_text(&quot;tmux -u new-session -A -s main\n&quot;)
	end
end)
</code></pre>
<p>加在wezterm配置合适的位置即可。</p>
]]></content></item><item><title>Linux 守护进程</title><link>https://jekyulll.github.io/posts/linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link><pubDate>Tue, 29 Apr 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</guid><description>&lt;p>复习：&lt;a href="https://blog.csdn.net/JMW1407/article/details/108412836">【Linux】守护进程（ Daemon）的定义，作用，创建流程&lt;/a>。&lt;/p>
&lt;p>编写守护进程的一般步骤步骤：&lt;/p>
&lt;ol>
&lt;li>在父进程中执行&lt;code>fork&lt;/code>并&lt;code>exit&lt;/code>退出；&lt;/li>
&lt;li>在子进程中调用&lt;code>setsid&lt;/code>函数创建新的会话；&lt;/li>
&lt;li>在子进程中调用&lt;code>chdir&lt;/code>函数，让根目录&lt;code>/&lt;/code>成为子进程的工作目录；&lt;/li>
&lt;li>在子进程中调用&lt;code>umask&lt;/code>函数，设置进程的&lt;code>umask&lt;/code>为&lt;code>0&lt;/code>；&lt;/li>
&lt;li>在子进程中关闭任何不需要的文件描述符。&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://blog.csdn.net/Change_Improve/article/details/106107317">Linux—umask（创建文件时的掩码）用法详解&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/fmeng23/article/details/23115989">深刻理解——real user id, effective user id, saved user id in Linux&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/ybxuwei/article/details/23563423">Linux进程权限的研究——real user id, effective user id, saved set-user-id&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。&lt;/p>
&lt;/blockquote></description><content type="html"><![CDATA[<p>复习：<a href="https://blog.csdn.net/JMW1407/article/details/108412836">【Linux】守护进程（ Daemon）的定义，作用，创建流程</a>。</p>
<p>编写守护进程的一般步骤步骤：</p>
<ol>
<li>在父进程中执行<code>fork</code>并<code>exit</code>退出；</li>
<li>在子进程中调用<code>setsid</code>函数创建新的会话；</li>
<li>在子进程中调用<code>chdir</code>函数，让根目录<code>/</code>成为子进程的工作目录；</li>
<li>在子进程中调用<code>umask</code>函数，设置进程的<code>umask</code>为<code>0</code>；</li>
<li>在子进程中关闭任何不需要的文件描述符。</li>
</ol>
<p><a href="https://blog.csdn.net/Change_Improve/article/details/106107317">Linux—umask（创建文件时的掩码）用法详解</a>。</p>
<p><a href="https://blog.csdn.net/fmeng23/article/details/23115989">深刻理解——real user id, effective user id, saved user id in Linux</a>。<br>
<a href="https://blog.csdn.net/ybxuwei/article/details/23563423">Linux进程权限的研究——real user id, effective user id, saved set-user-id</a>。</p>
<blockquote>
<p>调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。</p>
</blockquote>
]]></content></item><item><title>【1】Blender学习日记-入门</title><link>https://jekyulll.github.io/posts/game-1blender%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%85%A5%E9%97%A8/</link><pubDate>Fri, 25 Apr 2025 06:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/game-1blender%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%85%A5%E9%97%A8/</guid><description>&lt;p>半夜学一下blender。&lt;/p>
&lt;!-- 在Mint上也装了一下。 -->
&lt;p>&lt;a href="https://www.bilibili.com/video/BV14u41147YH">【Kurt】Blender零基础入门教程 | Blender中文区新手必刷教程(已完结)&lt;/a>。第四课著名的珍珠耳环少女，感觉一节课就差不多学会基础操作了，不错。&lt;/p>
&lt;p>&lt;code>N&lt;/code>是变换，&lt;code>S&lt;/code>是size（也可以结合方向轴，在轴向伸缩），&lt;code>R&lt;/code>是旋转（可以输数字，例如&lt;code>R&lt;/code> &lt;code>Z&lt;/code> &lt;code>90&lt;/code>就是在Z轴旋转90度），&lt;code>G&lt;/code>是移动。&lt;br>
新建内容是&lt;code>SHIFT&lt;/code>+&lt;code>A&lt;/code>，&lt;code>F9&lt;/code>可以改段数。&lt;code>SHIFT&lt;/code>+&lt;code>D&lt;/code>复制，移动的时候可以例如按&lt;code>Z&lt;/code>锁定在Z轴上移动。按两下方向轴（例如移动的时候），可以从世界坐标系切换到局部坐标系。&lt;br>
按&lt;code>/&lt;/code>可以单独显示该物体。&lt;br>
在窗口左上角拉一下，能拉出新窗口。新窗口的右上角，可以拉回去。&lt;br>
摄像机模式也可以按&lt;code>N&lt;/code>，在&amp;quot;视图&amp;quot;里把摄像机&amp;quot;锁定到视图方位&amp;quot;，方便调整。&lt;/p>
&lt;p>blender有两个渲染引擎：&lt;em>EEVEE&lt;/em>（快、实时）、&lt;em>CYCLES&lt;/em>（物理写实）。
渲染快捷键F12。&lt;br>
右键物体，平滑着色。右边物体数据属性（绿色三角）-&amp;gt; 法向 -&amp;gt; 自动光滑。&lt;/p>
&lt;p>编辑-&amp;gt;偏好设置里能调整CUDA设置。&lt;br>
发现用CYCLES的时候，切换成GPU渲染不出东西。显示&lt;code>Error CUDA kernel for this graphics card compute capability(8.6) not found&lt;/code>，可能是因为显卡驱动太新——毕竟我用的 2.83 的远古Blender（以前转mmd格式的时候，插件比较老，所以下的老版本）。&lt;/p>
&lt;p>多选之后-&amp;gt;&lt;code>CTRL&lt;/code>+&lt;code>L&lt;/code>-&amp;gt;关联材质。&lt;/p></description><content type="html"><![CDATA[<p>半夜学一下blender。</p>
<!-- 在Mint上也装了一下。   -->
<p><a href="https://www.bilibili.com/video/BV14u41147YH">【Kurt】Blender零基础入门教程 | Blender中文区新手必刷教程(已完结)</a>。第四课著名的珍珠耳环少女，感觉一节课就差不多学会基础操作了，不错。</p>
<p><code>N</code>是变换，<code>S</code>是size（也可以结合方向轴，在轴向伸缩），<code>R</code>是旋转（可以输数字，例如<code>R</code> <code>Z</code> <code>90</code>就是在Z轴旋转90度），<code>G</code>是移动。<br>
新建内容是<code>SHIFT</code>+<code>A</code>，<code>F9</code>可以改段数。<code>SHIFT</code>+<code>D</code>复制，移动的时候可以例如按<code>Z</code>锁定在Z轴上移动。按两下方向轴（例如移动的时候），可以从世界坐标系切换到局部坐标系。<br>
按<code>/</code>可以单独显示该物体。<br>
在窗口左上角拉一下，能拉出新窗口。新窗口的右上角，可以拉回去。<br>
摄像机模式也可以按<code>N</code>，在&quot;视图&quot;里把摄像机&quot;锁定到视图方位&quot;，方便调整。</p>
<p>blender有两个渲染引擎：<em>EEVEE</em>（快、实时）、<em>CYCLES</em>（物理写实）。
渲染快捷键F12。<br>
右键物体，平滑着色。右边物体数据属性（绿色三角）-&gt; 法向 -&gt; 自动光滑。</p>
<p>编辑-&gt;偏好设置里能调整CUDA设置。<br>
发现用CYCLES的时候，切换成GPU渲染不出东西。显示<code>Error CUDA kernel for this graphics card compute capability(8.6) not found</code>，可能是因为显卡驱动太新——毕竟我用的 2.83 的远古Blender（以前转mmd格式的时候，插件比较老，所以下的老版本）。</p>
<p>多选之后-&gt;<code>CTRL</code>+<code>L</code>-&gt;关联材质。</p>
]]></content></item><item><title>实现服务端断点续传：Go与Nginx</title><link>https://jekyulll.github.io/posts/web-%E5%88%A4%E6%96%ADhttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</link><pubDate>Wed, 23 Apr 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-%E5%88%A4%E6%96%ADhttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</guid><description>&lt;h3 id="一http协议基础">一、HTTP协议基础&lt;/h3>
&lt;p>HTTP协议通过&lt;strong>Range请求&lt;/strong>实现断点续传：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>客户端请求指定范围&lt;/strong>&lt;br>
客户端在请求头中携带&lt;code>Range&lt;/code>字段，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">GET&lt;/span> /file.zip &lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Range&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">bytes=500-1000&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>服务端响应部分内容&lt;/strong>&lt;br>
若支持范围请求，服务端返回状态码&lt;code>206 Partial Content&lt;/code>及对应数据片段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span> &lt;span style="color:#ae81ff">206&lt;/span> &lt;span style="color:#a6e22e">Partial Content&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Content-Range&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">bytes 500-1000/5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Content-Length&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">501&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>完整性校验机制&lt;/strong>&lt;br>
通过&lt;code>ETag&lt;/code>或&lt;code>Last-Modified&lt;/code>头确保文件未变更，避免续传数据不一致。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二nginx静态资源断点续传">二、Nginx静态资源断点续传&lt;/h3>
&lt;p>Nginx默认支持静态文件的断点续传。需要有以下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">root&lt;/span> &lt;span style="color:#e6db74">/data/files&lt;/span>; &lt;span style="color:#75715e"># 文件存储路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">add_header&lt;/span> &lt;span style="color:#e6db74">Accept-Ranges&lt;/span> &lt;span style="color:#e6db74">bytes&lt;/span>; &lt;span style="color:#75715e"># 声明支持字节范围请求
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>验证方法&lt;/strong>：&lt;br>
使用&lt;code>curl&lt;/code>检测响应头：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -I http://your-domain/static/large-file.iso
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>若输出包含&lt;code>Accept-Ranges: bytes&lt;/code>与&lt;code>Content-Length&lt;/code>，则表明支持续传。&lt;/p>
&lt;hr>
&lt;h3 id="三go实现">三、Go实现&lt;/h3>
&lt;p>对于动态生成的文件（如需鉴权的资源），需手动处理&lt;code>Range&lt;/code>请求。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;strconv&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;strings&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleDownload&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ResponseWriter&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">filePath&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/data/dynamic-file.bin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">file&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Open&lt;/span>(&lt;span style="color:#a6e22e">filePath&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;File not found&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusNotFound&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">file&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fileInfo&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">file&lt;/span>.&lt;span style="color:#a6e22e">Stat&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fileSize&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">Size&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>().&lt;span style="color:#a6e22e">Set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-Length&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">FormatInt&lt;/span>(&lt;span style="color:#a6e22e">fileSize&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>().&lt;span style="color:#a6e22e">Set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ETag&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;\&amp;#34;%x\&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">ModTime&lt;/span>().&lt;span style="color:#a6e22e">UnixNano&lt;/span>()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rangeHeader&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Range&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">rangeHeader&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ServeContent&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>(), &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">ModTime&lt;/span>(), &lt;span style="color:#a6e22e">file&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ranges&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">strings&lt;/span>.&lt;span style="color:#a6e22e">Split&lt;/span>(&lt;span style="color:#a6e22e">rangeHeader&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;=&amp;#34;&lt;/span>)[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">parts&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">strings&lt;/span>.&lt;span style="color:#a6e22e">Split&lt;/span>(&lt;span style="color:#a6e22e">ranges&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">ParseInt&lt;/span>(&lt;span style="color:#a6e22e">parts&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>], &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">64&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">end&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">fileSize&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">parts&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">end&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> = &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">ParseInt&lt;/span>(&lt;span style="color:#a6e22e">parts&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">64&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">start&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">fileSize&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">end&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">fileSize&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Requested range not satisfiable&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusRequestedRangeNotSatisfiable&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>().&lt;span style="color:#a6e22e">Set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-Range&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;bytes %d-%d/%d&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">end&lt;/span>, &lt;span style="color:#a6e22e">fileSize&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>().&lt;span style="color:#a6e22e">Set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-Length&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">FormatInt&lt;/span>(&lt;span style="color:#a6e22e">end&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">WriteHeader&lt;/span>(&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusPartialContent&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">file&lt;/span>.&lt;span style="color:#a6e22e">Seek&lt;/span>(&lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ServeContent&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>(), &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">ModTime&lt;/span>(), &lt;span style="color:#a6e22e">file&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">HandleFunc&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/download&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">handleDownload&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ListenAndServe&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;:8080&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>• 解析&lt;code>Range&lt;/code>请求头并验证范围有效性
• 使用&lt;code>Seek&lt;/code>定位文件指针，返回部分内容
• 通过&lt;code>ETag&lt;/code>实现文件一致性校验&lt;/p></description><content type="html"><![CDATA[<h3 id="一http协议基础">一、HTTP协议基础</h3>
<p>HTTP协议通过<strong>Range请求</strong>实现断点续传：</p>
<ol>
<li>
<p><strong>客户端请求指定范围</strong><br>
客户端在请求头中携带<code>Range</code>字段，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#a6e22e">GET</span> /file.zip <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span>
</span></span><span style="display:flex;"><span>Range<span style="color:#f92672">:</span> <span style="color:#ae81ff">bytes=500-1000</span>
</span></span></code></pre></div></li>
<li>
<p><strong>服务端响应部分内容</strong><br>
若支持范围请求，服务端返回状态码<code>206 Partial Content</code>及对应数据片段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">206</span> <span style="color:#a6e22e">Partial Content</span>
</span></span><span style="display:flex;"><span>Content-Range<span style="color:#f92672">:</span> <span style="color:#ae81ff">bytes 500-1000/5000</span>
</span></span><span style="display:flex;"><span>Content-Length<span style="color:#f92672">:</span> <span style="color:#ae81ff">501</span>
</span></span></code></pre></div></li>
<li>
<p><strong>完整性校验机制</strong><br>
通过<code>ETag</code>或<code>Last-Modified</code>头确保文件未变更，避免续传数据不一致。</p>
</li>
</ol>
<hr>
<h3 id="二nginx静态资源断点续传">二、Nginx静态资源断点续传</h3>
<p>Nginx默认支持静态文件的断点续传。需要有以下配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#66d9ef">server</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">location</span> <span style="color:#e6db74">/static</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">root</span> <span style="color:#e6db74">/data/files</span>;           <span style="color:#75715e"># 文件存储路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">add_header</span> <span style="color:#e6db74">Accept-Ranges</span> <span style="color:#e6db74">bytes</span>;  <span style="color:#75715e"># 声明支持字节范围请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>验证方法</strong>：<br>
使用<code>curl</code>检测响应头：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -I http://your-domain/static/large-file.iso
</span></span></code></pre></div><p>若输出包含<code>Accept-Ranges: bytes</code>与<code>Content-Length</code>，则表明支持续传。</p>
<hr>
<h3 id="三go实现">三、Go实现</h3>
<p>对于动态生成的文件（如需鉴权的资源），需手动处理<code>Range</code>请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;net/http&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;strconv&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handleDownload</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">filePath</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;/data/dynamic-file.bin&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#a6e22e">filePath</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;File not found&#34;</span>, <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusNotFound</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fileInfo</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Stat</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fileSize</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fileInfo</span>.<span style="color:#a6e22e">Size</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Header</span>().<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;Content-Length&#34;</span>, <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">FormatInt</span>(<span style="color:#a6e22e">fileSize</span>, <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Header</span>().<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;ETag&#34;</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;\&#34;%x\&#34;&#34;</span>, <span style="color:#a6e22e">fileInfo</span>.<span style="color:#a6e22e">ModTime</span>().<span style="color:#a6e22e">UnixNano</span>()))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rangeHeader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Header</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;Range&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">rangeHeader</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ServeContent</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">fileInfo</span>.<span style="color:#a6e22e">Name</span>(), <span style="color:#a6e22e">fileInfo</span>.<span style="color:#a6e22e">ModTime</span>(), <span style="color:#a6e22e">file</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ranges</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">rangeHeader</span>, <span style="color:#e6db74">&#34;=&#34;</span>)[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">ranges</span>, <span style="color:#e6db74">&#34;-&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseInt</span>(<span style="color:#a6e22e">parts</span>[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">64</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fileSize</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">parts</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">end</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseInt</span>(<span style="color:#a6e22e">parts</span>[<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">64</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">fileSize</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">end</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">fileSize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;Requested range not satisfiable&#34;</span>, <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusRequestedRangeNotSatisfiable</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Header</span>().<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;Content-Range&#34;</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;bytes %d-%d/%d&#34;</span>, <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span>, <span style="color:#a6e22e">fileSize</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Header</span>().<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;Content-Length&#34;</span>, <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">FormatInt</span>(<span style="color:#a6e22e">end</span><span style="color:#f92672">-</span><span style="color:#a6e22e">start</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">WriteHeader</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusPartialContent</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Seek</span>(<span style="color:#a6e22e">start</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ServeContent</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">fileInfo</span>.<span style="color:#a6e22e">Name</span>(), <span style="color:#a6e22e">fileInfo</span>.<span style="color:#a6e22e">ModTime</span>(), <span style="color:#a6e22e">file</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/download&#34;</span>, <span style="color:#a6e22e">handleDownload</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#e6db74">&#34;:8080&#34;</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>• 解析<code>Range</code>请求头并验证范围有效性
• 使用<code>Seek</code>定位文件指针，返回部分内容
• 通过<code>ETag</code>实现文件一致性校验</p>
<hr>
<h3 id="四客户端如何检测服务端是否支持">四、客户端如何检测服务端是否支持？</h3>
<p>可通过以下步骤判断：</p>
<ol>
<li>
<p><strong>发送HEAD请求</strong><br>
获取响应头信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -I http://your-domain/file.zip
</span></span></code></pre></div></li>
<li>
<p><strong>检查关键头字段</strong><br>
• <strong><code>Accept-Ranges: bytes</code></strong>：表明支持字节范围请求
• <strong><code>Content-Length</code></strong>：必须存在且为固定值（动态内容可能无法支持）
• <strong><code>ETag</code>或<code>Last-Modified</code></strong>：用于文件变更校验</p>
</li>
<li>
<p><strong>实验性范围请求测试</strong><br>
发送带<code>Range</code>头的GET请求：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -H <span style="color:#e6db74">&#34;Range: bytes=0-100&#34;</span> http://your-domain/file.zip
</span></span></code></pre></div><p>若响应状态码为<code>206</code>且包含<code>Content-Range</code>头，则确认支持续传。</p>
</li>
</ol>
<hr>
<h3 id="五nginx反向代理go服务的注意事项">五、Nginx反向代理Go服务的注意事项</h3>
<p>当Go服务部署于Nginx后，需确保配置正确处理Range请求：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#66d9ef">location</span> <span style="color:#e6db74">/go-download</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">proxy_pass</span> <span style="color:#e6db74">http://go-backend:8080/download</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">Range</span> $http_range;    <span style="color:#75715e"># 传递原始Range头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">If-Range</span> $http_if_range;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">proxy_hide_header</span> <span style="color:#e6db74">Accept-Ranges</span>;      <span style="color:#75715e"># 避免与后端冲突
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">proxy_http_version</span> <span style="color:#ae81ff">1</span><span style="color:#e6db74">.1</span>;               <span style="color:#75715e"># 支持HTTP/1.1特性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>• 确认Nginx与Go服务对文件有读取权限
• 检查<code>Content-Length</code>是否被意外修改（如Gzip压缩）
• 使用<code>tcpdump</code>或Wireshark抓包验证请求头传递</p>
<hr>
<h3 id="六边界问题与优化建议">六、边界问题与优化建议</h3>
<ol>
<li>
<p><strong>多范围请求处理</strong><br>
支持形如<code>Range: bytes=0-100,200-300</code>的请求需分段响应，可通过Go的<code>multipart/byteranges</code>实现。</p>
</li>
<li>
<p><strong>速率限制与防滥用</strong><br>
Nginx配置限速：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#66d9ef">location</span> <span style="color:#e6db74">/download</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">limit_rate</span> <span style="color:#ae81ff">1m</span>;  <span style="color:#75715e"># 限制下载速度为1MB/s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div></li>
<li>
<p><strong>日志监控</strong><br>
监控<code>206</code>状态码频率，识别异常续传行为。</p>
</li>
</ol>
]]></content></item><item><title>C++ 中的乐观锁和悲观锁</title><link>https://jekyulll.github.io/posts/cpp-c++-%E4%B8%AD%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</link><pubDate>Mon, 21 Apr 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E4%B8%AD%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>悲观锁&lt;/strong>（Pessimistic Lock）是一种假设冲突会频繁发生的锁机制。每次数据访问时，都会先加锁，直到操作完成后才释放锁，这样可以确保在锁持有期间，其他线程无法访问这段数据，从而避免了并发冲突。
&lt;strong>乐观锁&lt;/strong>（Optimistic Lock）是一种假设冲突不会频繁发生的锁机制。每次数据访问时，不会加锁，而是在更新数据时检查是否有其他线程修改过数据。如果检测到冲突（数据被其他线程修改过），则重试操作或报错。适用于读多写少的场景。&lt;/p>
&lt;/blockquote>
&lt;p>乐观锁通常实现方式有以下两种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>版本号机制&lt;/strong>：每次读取数据时，读取一个版本号，更新数据时，检查版本号是否变化，如果没有变化，则更新成功，否则重试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>时间戳机制&lt;/strong>：类似版本号机制，通过时间戳来检测数据是否被修改。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>悲观锁性能较低，因为每次操作都需要加锁和解锁。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>乐观锁性能较高，但在高并发写操作下可能会频繁重试，影响性能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>悲观锁适用于并发冲突高、数据一致性要求严格的场景。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>乐观锁适用于并发冲突低、读多写少的场景。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>C++乐观锁实现方式：使用 &lt;strong>CAS（Compare-And-Swap）&lt;/strong> 或 &lt;code>std::atomic&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;thread&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;atomic&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> sharedData(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">optimisticTask&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> oldValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> newValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> oldValue &lt;span style="color:#f92672">=&lt;/span> sharedData.load(); &lt;span style="color:#75715e">// 读取当前值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> newValue &lt;span style="color:#f92672">=&lt;/span> oldValue &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 本地计算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>sharedData.compare_exchange_weak(oldValue, newValue));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Thread &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> id &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; updated sharedData to &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> newValue &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t1(optimisticTask, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t2(optimisticTask, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t1.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t2.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Final sharedData: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> sharedData &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>compare_exchange_weak&lt;/code> 可能会在无冲突时也失败（为性能优化），可以换成 &lt;code>compare_exchange_strong&lt;/code> 更稳定。&lt;/p></description><content type="html"><![CDATA[<blockquote>
<p><strong>悲观锁</strong>（Pessimistic Lock）是一种假设冲突会频繁发生的锁机制。每次数据访问时，都会先加锁，直到操作完成后才释放锁，这样可以确保在锁持有期间，其他线程无法访问这段数据，从而避免了并发冲突。
<strong>乐观锁</strong>（Optimistic Lock）是一种假设冲突不会频繁发生的锁机制。每次数据访问时，不会加锁，而是在更新数据时检查是否有其他线程修改过数据。如果检测到冲突（数据被其他线程修改过），则重试操作或报错。适用于读多写少的场景。</p>
</blockquote>
<p>乐观锁通常实现方式有以下两种：</p>
<ul>
<li>
<p><strong>版本号机制</strong>：每次读取数据时，读取一个版本号，更新数据时，检查版本号是否变化，如果没有变化，则更新成功，否则重试。</p>
</li>
<li>
<p><strong>时间戳机制</strong>：类似版本号机制，通过时间戳来检测数据是否被修改。</p>
</li>
<li>
<p>悲观锁性能较低，因为每次操作都需要加锁和解锁。</p>
</li>
<li>
<p>乐观锁性能较高，但在高并发写操作下可能会频繁重试，影响性能。</p>
</li>
<li>
<p>悲观锁适用于并发冲突高、数据一致性要求严格的场景。</p>
</li>
<li>
<p>乐观锁适用于并发冲突低、读多写少的场景。</p>
</li>
</ul>
<hr>
<p>C++乐观锁实现方式：使用 <strong>CAS（Compare-And-Swap）</strong> 或 <code>std::atomic</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;atomic&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sharedData(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">optimisticTask</span>(<span style="color:#66d9ef">int</span> id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> oldValue;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> newValue;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>            oldValue <span style="color:#f92672">=</span> sharedData.load();        <span style="color:#75715e">// 读取当前值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            newValue <span style="color:#f92672">=</span> oldValue <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;             <span style="color:#75715e">// 本地计算
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>sharedData.compare_exchange_weak(oldValue, newValue));
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Thread &#34;</span> <span style="color:#f92672">&lt;&lt;</span> id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; updated sharedData to &#34;</span> <span style="color:#f92672">&lt;&lt;</span> newValue <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(optimisticTask, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(optimisticTask, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    t1.join();
</span></span><span style="display:flex;"><span>    t2.join();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Final sharedData: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sharedData <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>compare_exchange_weak</code> 可能会在无冲突时也失败（为性能优化），可以换成 <code>compare_exchange_strong</code> 更稳定。</p>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>悲观锁</th>
          <th>乐观锁</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>开销</td>
          <td>较大（加锁解锁）</td>
          <td>较小（无锁，靠 CAS）</td>
      </tr>
      <tr>
          <td>并发性能</td>
          <td>低（锁竞争激烈时性能下降）</td>
          <td>高（冲突少时效率高）</td>
      </tr>
      <tr>
          <td>适用场景</td>
          <td>冲突频繁的情况（例如写多读少）</td>
          <td>冲突较少的情况（例如读多写少）</td>
      </tr>
      <tr>
          <td>实现方式</td>
          <td><code>std::mutex</code>, <code>std::lock_guard</code></td>
          <td><code>std::atomic</code>, <code>compare_exchange_*</code></td>
      </tr>
  </tbody>
</table>
]]></content></item><item><title>304 Not Modified 是怎么检测的？</title><link>https://jekyulll.github.io/posts/web-304-not-modified-%E6%98%AF%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E7%9A%84/</link><pubDate>Thu, 17 Apr 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-304-not-modified-%E6%98%AF%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E7%9A%84/</guid><description>&lt;p>&lt;strong>最终判断逻辑由服务端完成&lt;/strong>。&lt;/p>
&lt;p>• &lt;strong>浏览器行为&lt;/strong>（客户端）：&lt;br>
• 浏览器会缓存资源（如 HTML、图片、CSS 等），并根据服务端之前返回的响应头（如 &lt;code>Cache-Control&lt;/code>、&lt;code>Expires&lt;/code>、&lt;code>ETag&lt;/code>、&lt;code>Last-Modified&lt;/code>）决定是否发起&lt;strong>条件请求&lt;/strong>。&lt;br>
• 当缓存过期或页面刷新（非强制刷新）时，浏览器会向服务端发送一个带有&lt;strong>验证头&lt;/strong>的请求，例如：&lt;br>
◦ &lt;code>If-None-Match&lt;/code>（对应服务端之前返回的 &lt;code>ETag&lt;/code>）&lt;br>
◦ &lt;code>If-Modified-Since&lt;/code>（对应服务端之前返回的 &lt;code>Last-Modified&lt;/code>）&lt;/p>
&lt;p>• &lt;strong>服务端行为&lt;/strong>：&lt;br>
• 服务端收到请求后，根据客户端的验证头（&lt;code>If-None-Match&lt;/code> 或 &lt;code>If-Modified-Since&lt;/code>）检查资源是否已修改。&lt;br>
• &lt;strong>如果资源未修改&lt;/strong>，返回 &lt;strong>304 Not Modified&lt;/strong>，且不返回资源内容，仅返回响应头。&lt;br>
• &lt;strong>如果资源已修改&lt;/strong>，返回 &lt;strong>200 OK&lt;/strong> 并附带新内容。&lt;/p>
&lt;p>• &lt;strong>浏览器&lt;/strong>：负责发起条件请求（携带验证头），并根据响应状态码决定是否使用缓存。&lt;br>
• &lt;strong>服务端&lt;/strong>：负责验证资源是否修改，并决定返回 304 或 200。&lt;/p>
&lt;ol>
&lt;li>用户首次访问网页，服务端返回资源，响应头包含：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#a6e22e">OK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ETag&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">&amp;#34;abc123&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Last-Modified&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">Wed, 01 Jan 2024 00:00:00 GMT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cache-Control&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">max-age=3600&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>用户再次访问时，浏览器缓存未过期（&lt;code>max-age=3600&lt;/code> 内）：&lt;br>
• 直接使用缓存，无需请求服务端。&lt;/li>
&lt;li>缓存过期后，浏览器发起条件请求：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">GET&lt;/span> /example.html &lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>If-None-Match&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">&amp;#34;abc123&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>If-Modified-Since&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">Wed, 01 Jan 2024 00:00:00 GMT&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>服务端验证资源未修改，返回：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span> &lt;span style="color:#ae81ff">304&lt;/span> &lt;span style="color:#a6e22e">Not Modified&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ETag&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">&amp;#34;abc123&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Last-Modified&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">Wed, 01 Jan 2024 00:00:00 GMT&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>浏览器收到 304 后，继续使用本地缓存。&lt;/li>
&lt;/ol></description><content type="html"><![CDATA[<p><strong>最终判断逻辑由服务端完成</strong>。</p>
<p>• <strong>浏览器行为</strong>（客户端）：<br>
• 浏览器会缓存资源（如 HTML、图片、CSS 等），并根据服务端之前返回的响应头（如 <code>Cache-Control</code>、<code>Expires</code>、<code>ETag</code>、<code>Last-Modified</code>）决定是否发起<strong>条件请求</strong>。<br>
• 当缓存过期或页面刷新（非强制刷新）时，浏览器会向服务端发送一个带有<strong>验证头</strong>的请求，例如：<br>
◦ <code>If-None-Match</code>（对应服务端之前返回的 <code>ETag</code>）<br>
◦ <code>If-Modified-Since</code>（对应服务端之前返回的 <code>Last-Modified</code>）</p>
<p>• <strong>服务端行为</strong>：<br>
• 服务端收到请求后，根据客户端的验证头（<code>If-None-Match</code> 或 <code>If-Modified-Since</code>）检查资源是否已修改。<br>
• <strong>如果资源未修改</strong>，返回 <strong>304 Not Modified</strong>，且不返回资源内容，仅返回响应头。<br>
• <strong>如果资源已修改</strong>，返回 <strong>200 OK</strong> 并附带新内容。</p>
<p>• <strong>浏览器</strong>：负责发起条件请求（携带验证头），并根据响应状态码决定是否使用缓存。<br>
• <strong>服务端</strong>：负责验证资源是否修改，并决定返回 304 或 200。</p>
<ol>
<li>用户首次访问网页，服务端返回资源，响应头包含：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">200</span> <span style="color:#a6e22e">OK</span>
</span></span><span style="display:flex;"><span>ETag<span style="color:#f92672">:</span> <span style="color:#ae81ff">&#34;abc123&#34;</span>
</span></span><span style="display:flex;"><span>Last-Modified<span style="color:#f92672">:</span> <span style="color:#ae81ff">Wed, 01 Jan 2024 00:00:00 GMT</span>
</span></span><span style="display:flex;"><span>Cache-Control<span style="color:#f92672">:</span> <span style="color:#ae81ff">max-age=3600</span>
</span></span></code></pre></div></li>
<li>用户再次访问时，浏览器缓存未过期（<code>max-age=3600</code> 内）：<br>
• 直接使用缓存，无需请求服务端。</li>
<li>缓存过期后，浏览器发起条件请求：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#a6e22e">GET</span> /example.html <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span>
</span></span><span style="display:flex;"><span>If-None-Match<span style="color:#f92672">:</span> <span style="color:#ae81ff">&#34;abc123&#34;</span>
</span></span><span style="display:flex;"><span>If-Modified-Since<span style="color:#f92672">:</span> <span style="color:#ae81ff">Wed, 01 Jan 2024 00:00:00 GMT</span>
</span></span></code></pre></div></li>
<li>服务端验证资源未修改，返回：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">304</span> <span style="color:#a6e22e">Not Modified</span>
</span></span><span style="display:flex;"><span>ETag<span style="color:#f92672">:</span> <span style="color:#ae81ff">&#34;abc123&#34;</span>
</span></span><span style="display:flex;"><span>Last-Modified<span style="color:#f92672">:</span> <span style="color:#ae81ff">Wed, 01 Jan 2024 00:00:00 GMT</span>
</span></span></code></pre></div></li>
<li>浏览器收到 304 后，继续使用本地缓存。</li>
</ol>
]]></content></item><item><title>Linux 的CPU保护环，三环和零环</title><link>https://jekyulll.github.io/posts/linux-linux-%E7%9A%84cpu%E4%BF%9D%E6%8A%A4%E7%8E%AF%E4%B8%89%E7%8E%AF%E5%92%8C%E9%9B%B6%E7%8E%AF/</link><pubDate>Sun, 30 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-linux-%E7%9A%84cpu%E4%BF%9D%E6%8A%A4%E7%8E%AF%E4%B8%89%E7%8E%AF%E5%92%8C%E9%9B%B6%E7%8E%AF/</guid><description>&lt;p>Linux系统中的“三环”和“零环”概念源自CPU的&lt;strong>保护环&lt;/strong>（Protection Rings）机制，是操作系统实现权限隔离和安全保护的核心设计。&lt;/p>
&lt;p>x86保护环的完整结构为四层，但实际仅Ring 0和Ring 3被广泛使用：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>零环&lt;/strong>（Ring 0）：
&lt;ul>
&lt;li>又称内核态，是CPU权限最高的运行模式。操作系统内核运行于此环，可直接访问硬件资源（如CPU、内存、I/O设备），执行特权指令（如修改内存映射、中断处理等）。例如，Linux内核的进程调度、内存管理和设备驱动均在此层级运行。&lt;/li>
&lt;li>零环可直接控制硬件，而三环的代码若试图执行特权指令（如直接读写磁盘），CPU会触发异常（如General Protection Fault），强制终止非法操作。这种设计避免了用户程序破坏系统稳定性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>三环&lt;/strong>（Ring 3）：
&lt;ul>
&lt;li>又称用户态，是权限最低的层级。普通应用程序运行于此环，仅能通过系统调用（Syscall）请求内核服务，无法直接操作硬件。例如，用户启动的文本编辑器、浏览器等程序均受此限制。&lt;/li>
&lt;li>用户程序通过系统调用或硬件中断从三环切换到零环。例如，当程序调用&lt;code>open()&lt;/code>函数打开文件时，会触发软中断（如&lt;code>int 0x80&lt;/code>或&lt;code>syscall&lt;/code>指令），内核接管执行文件操作，完成后返回用户态。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.csdn.net/youyou1543724847/article/details/85048490">CPU的运行环, 特权级与保护&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/farmwang/article/details/50094959">原文 ——CPU的运行环, 特权级与保护&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/qq_26962739/article/details/133133574">Linux内核开发之hook系统调用&lt;/a>。&lt;br>
&lt;a href="https://www.cnblogs.com/onetrainee/p/11707130.html">三环进入零环的细节（KiFastCallEntry函数分析）&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/wxy_xx1/article/details/142953401">系统调用之_KUSER_SHARED_DATA&lt;/a>。&lt;/p></description><content type="html"><![CDATA[<p>Linux系统中的“三环”和“零环”概念源自CPU的<strong>保护环</strong>（Protection Rings）机制，是操作系统实现权限隔离和安全保护的核心设计。</p>
<p>x86保护环的完整结构为四层，但实际仅Ring 0和Ring 3被广泛使用：</p>
<ul>
<li><strong>零环</strong>（Ring 0）：
<ul>
<li>又称内核态，是CPU权限最高的运行模式。操作系统内核运行于此环，可直接访问硬件资源（如CPU、内存、I/O设备），执行特权指令（如修改内存映射、中断处理等）。例如，Linux内核的进程调度、内存管理和设备驱动均在此层级运行。</li>
<li>零环可直接控制硬件，而三环的代码若试图执行特权指令（如直接读写磁盘），CPU会触发异常（如General Protection Fault），强制终止非法操作。这种设计避免了用户程序破坏系统稳定性。</li>
</ul>
</li>
<li><strong>三环</strong>（Ring 3）：
<ul>
<li>又称用户态，是权限最低的层级。普通应用程序运行于此环，仅能通过系统调用（Syscall）请求内核服务，无法直接操作硬件。例如，用户启动的文本编辑器、浏览器等程序均受此限制。</li>
<li>用户程序通过系统调用或硬件中断从三环切换到零环。例如，当程序调用<code>open()</code>函数打开文件时，会触发软中断（如<code>int 0x80</code>或<code>syscall</code>指令），内核接管执行文件操作，完成后返回用户态。</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/youyou1543724847/article/details/85048490">CPU的运行环, 特权级与保护</a>。<br>
<a href="https://blog.csdn.net/farmwang/article/details/50094959">原文 ——CPU的运行环, 特权级与保护</a>。<br>
<a href="https://blog.csdn.net/qq_26962739/article/details/133133574">Linux内核开发之hook系统调用</a>。<br>
<a href="https://www.cnblogs.com/onetrainee/p/11707130.html">三环进入零环的细节（KiFastCallEntry函数分析）</a>。<br>
<a href="https://blog.csdn.net/wxy_xx1/article/details/142953401">系统调用之_KUSER_SHARED_DATA</a>。</p>
]]></content></item><item><title>fork出的子进程是否继承文件描述符表？</title><link>https://jekyulll.github.io/posts/linux-fork%E5%87%BA%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/</link><pubDate>Sat, 29 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-fork%E5%87%BA%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/</guid><description>&lt;p>当通过 &lt;code>fork()&lt;/code> 创建子进程时，子进程会获得父进程文件描述符表的&lt;u>完整副本&lt;/u>。这意味着子进程的文件描述符表中每个条目指向的 系统级文件表项（File Table Entry）与父进程相同。
父子进程共享文件表项中的文件偏移量（Offset）、打开模式（Read/Write Flags）、文件状态标志等信息。例如，如果父进程写入文件后移动了偏移量，子进程会从新的偏移位置继续操作。&lt;/p>
&lt;ul>
&lt;li>修改文件描述符表本身（如关闭 &lt;code>fd&lt;/code>）：子进程的操作不会影响父进程。例如，子进程关闭 fd=3，父进程的 fd=3 仍然有效。&lt;/li>
&lt;li>修改共享的文件表项（如偏移量、状态标志）：子进程的操作会直接影响父进程，因为它们共享同一文件表项。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.csdn.net/DLUTBruceZhang/article/details/8802156">&lt;code>fork()&lt;/code>子进程与父进程之间的文件描述符问题&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/m0_73209194/article/details/130165449">【Linux】进程间通信&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>文件描述符相当于一个逻辑句柄，而&lt;code>open&lt;/code>，&lt;code>close&lt;/code>等函数则是将文件或者物理设备与句柄相关联。&lt;/p>
&lt;/blockquote>
&lt;p>三张表：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>文件描述符表&lt;/strong>：用户区的一部分，除非通过使用文件描述符的函数，否则程序无法对其进行访问。对进程中每个打开的文件，文件描述符表都包含一个条目。&lt;/li>
&lt;li>&lt;strong>系统文件表&lt;/strong>：为系统中所有的进程共享。对每个活动的open, 它都包含一个条目。每个系统文件表的条目都包含文件偏移量、访问模式（读、写、or 读-写）以及指向它的文件描述符表的条目计数。&lt;/li>
&lt;li>&lt;strong>内存索引节点表&lt;/strong>: 对系统中的每个活动的文件（被某个进程打开了），内存中索引节点表都包含一个条目。几个系统文件表条目可能对应于同一个内存索引节点表（不同进程打开同一个文件）。&lt;/li>
&lt;/ul></description><content type="html"><![CDATA[<p>当通过 <code>fork()</code> 创建子进程时，子进程会获得父进程文件描述符表的<u>完整副本</u>。这意味着子进程的文件描述符表中每个条目指向的 系统级文件表项（File Table Entry）与父进程相同。
父子进程共享文件表项中的文件偏移量（Offset）、打开模式（Read/Write Flags）、文件状态标志等信息。例如，如果父进程写入文件后移动了偏移量，子进程会从新的偏移位置继续操作。</p>
<ul>
<li>修改文件描述符表本身（如关闭 <code>fd</code>）：子进程的操作不会影响父进程。例如，子进程关闭 fd=3，父进程的 fd=3 仍然有效。</li>
<li>修改共享的文件表项（如偏移量、状态标志）：子进程的操作会直接影响父进程，因为它们共享同一文件表项。</li>
</ul>
<p><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/8802156"><code>fork()</code>子进程与父进程之间的文件描述符问题</a>。<br>
<a href="https://blog.csdn.net/m0_73209194/article/details/130165449">【Linux】进程间通信</a>。</p>
<blockquote>
<p>文件描述符相当于一个逻辑句柄，而<code>open</code>，<code>close</code>等函数则是将文件或者物理设备与句柄相关联。</p>
</blockquote>
<p>三张表：</p>
<ul>
<li><strong>文件描述符表</strong>：用户区的一部分，除非通过使用文件描述符的函数，否则程序无法对其进行访问。对进程中每个打开的文件，文件描述符表都包含一个条目。</li>
<li><strong>系统文件表</strong>：为系统中所有的进程共享。对每个活动的open, 它都包含一个条目。每个系统文件表的条目都包含文件偏移量、访问模式（读、写、or 读-写）以及指向它的文件描述符表的条目计数。</li>
<li><strong>内存索引节点表</strong>: 对系统中的每个活动的文件（被某个进程打开了），内存中索引节点表都包含一个条目。几个系统文件表条目可能对应于同一个内存索引节点表（不同进程打开同一个文件）。</li>
</ul>
]]></content></item><item><title>Linux里fork出子进程的时候，哪些内容是共享的？</title><link>https://jekyulll.github.io/posts/linux-linux%E9%87%8Cfork%E5%87%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84/</link><pubDate>Thu, 27 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-linux%E9%87%8Cfork%E5%87%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84/</guid><description>&lt;h3 id="一共享的内容">&lt;strong>一、共享的内容&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>文件描述符与文件状态&lt;/strong>&lt;br>
子进程会继承父进程已打开的文件描述符表，包括文件偏移量、打开模式（如读写权限）和文件状态标志（如&lt;code>O_APPEND&lt;/code>）。例如，若父进程打开了一个文件并写入数据，子进程可通过相同的文件描述符继续操作，且两者的写入位置（偏移量）会相互影响。&lt;br>
• &lt;strong>示例场景&lt;/strong>：父进程向文件写入“Parent”，子进程写入“Child”，最终文件内容会按操作顺序合并（如“ParentChild”或“ChildParent”），具体取决于调度顺序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>信号处理设置&lt;/strong>&lt;br>
子进程继承父进程的信号处理函数（如&lt;code>SIG_IGN&lt;/code>或自定义处理程序）和信号屏蔽集（&lt;code>sigprocmask&lt;/code>的设置）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>用户身份与环境变量&lt;/strong>&lt;br>
子进程继承父进程的用户ID、组ID、环境变量、当前工作目录等身份信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>写时复制（Copy-On-Write）的内存初始状态&lt;/strong>&lt;br>
在未发生写入操作前，父子进程的代码段（&lt;code>.text&lt;/code>）、数据段（&lt;code>.data&lt;/code>、&lt;code>.bss&lt;/code>）、堆、栈等内存区域共享同一物理内存页。一旦某一方尝试修改数据，则会触发写时复制，生成独立的副本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>文件锁&lt;/strong>&lt;br>
通过&lt;code>fcntl&lt;/code>或&lt;code>flock&lt;/code>设置的文件锁会被子进程继承，父子进程对同一文件的锁定操作会相互影响。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二不共享的内容">&lt;strong>二、不共享的内容&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>进程独立属性&lt;/strong>&lt;br>
子进程拥有独立的进程ID（PID）、父进程ID（PPID）、运行时间统计、未决信号队列等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>多线程环境中的线程资源&lt;/strong>&lt;br>
若父进程包含多个线程，子进程仅复制执行&lt;code>fork()&lt;/code>的线程，其他线程不会被继承。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>独立的内存修改&lt;/strong>&lt;br>
通过写时复制机制，父子进程对内存的修改会各自独立。例如，全局变量初始值相同，但修改后互不影响。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>独立的文件描述符关闭操作&lt;/strong>&lt;br>
子进程关闭某个文件描述符不会影响父进程的同名描述符，反之亦然。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="三关键机制写时复制cow">&lt;strong>三、关键机制：写时复制（COW）&lt;/strong>&lt;/h3>
&lt;p>内核通过写时复制技术优化性能：&lt;br>
• &lt;strong>原理&lt;/strong>：&lt;code>fork()&lt;/code>后，父子进程的页表项指向相同的物理内存页，并将这些页标记为只读。当某一进程尝试写入时，触发页错误，内核复制该页并修改权限为可写。&lt;br>
• &lt;strong>优点&lt;/strong>：避免不必要的内存复制，提高资源利用率。&lt;/p>
&lt;hr>
&lt;h3 id="四应用注意事项">&lt;strong>四、应用注意事项&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>文件操作同步&lt;/strong>：父子进程对同一文件描述符的并发写入需通过锁（如&lt;code>flock()&lt;/code>）或原子操作避免竞争。&lt;/li>
&lt;li>&lt;strong>内存共享限制&lt;/strong>：若需主动共享内存，需使用&lt;code>mmap()&lt;/code>或共享内存API（如&lt;code>shmget()&lt;/code>）。&lt;/li>
&lt;li>&lt;strong>僵尸进程处理&lt;/strong>：父进程需通过&lt;code>wait()&lt;/code>回收子进程资源，或注册&lt;code>SIGCHLD&lt;/code>信号处理函数。&lt;/li>
&lt;/ol></description><content type="html"><![CDATA[<h3 id="一共享的内容"><strong>一、共享的内容</strong></h3>
<ol>
<li>
<p><strong>文件描述符与文件状态</strong><br>
子进程会继承父进程已打开的文件描述符表，包括文件偏移量、打开模式（如读写权限）和文件状态标志（如<code>O_APPEND</code>）。例如，若父进程打开了一个文件并写入数据，子进程可通过相同的文件描述符继续操作，且两者的写入位置（偏移量）会相互影响。<br>
• <strong>示例场景</strong>：父进程向文件写入“Parent”，子进程写入“Child”，最终文件内容会按操作顺序合并（如“ParentChild”或“ChildParent”），具体取决于调度顺序。</p>
</li>
<li>
<p><strong>信号处理设置</strong><br>
子进程继承父进程的信号处理函数（如<code>SIG_IGN</code>或自定义处理程序）和信号屏蔽集（<code>sigprocmask</code>的设置）。</p>
</li>
<li>
<p><strong>用户身份与环境变量</strong><br>
子进程继承父进程的用户ID、组ID、环境变量、当前工作目录等身份信息。</p>
</li>
<li>
<p><strong>写时复制（Copy-On-Write）的内存初始状态</strong><br>
在未发生写入操作前，父子进程的代码段（<code>.text</code>）、数据段（<code>.data</code>、<code>.bss</code>）、堆、栈等内存区域共享同一物理内存页。一旦某一方尝试修改数据，则会触发写时复制，生成独立的副本。</p>
</li>
<li>
<p><strong>文件锁</strong><br>
通过<code>fcntl</code>或<code>flock</code>设置的文件锁会被子进程继承，父子进程对同一文件的锁定操作会相互影响。</p>
</li>
</ol>
<hr>
<h3 id="二不共享的内容"><strong>二、不共享的内容</strong></h3>
<ol>
<li>
<p><strong>进程独立属性</strong><br>
子进程拥有独立的进程ID（PID）、父进程ID（PPID）、运行时间统计、未决信号队列等。</p>
</li>
<li>
<p><strong>多线程环境中的线程资源</strong><br>
若父进程包含多个线程，子进程仅复制执行<code>fork()</code>的线程，其他线程不会被继承。</p>
</li>
<li>
<p><strong>独立的内存修改</strong><br>
通过写时复制机制，父子进程对内存的修改会各自独立。例如，全局变量初始值相同，但修改后互不影响。</p>
</li>
<li>
<p><strong>独立的文件描述符关闭操作</strong><br>
子进程关闭某个文件描述符不会影响父进程的同名描述符，反之亦然。</p>
</li>
</ol>
<hr>
<h3 id="三关键机制写时复制cow"><strong>三、关键机制：写时复制（COW）</strong></h3>
<p>内核通过写时复制技术优化性能：<br>
• <strong>原理</strong>：<code>fork()</code>后，父子进程的页表项指向相同的物理内存页，并将这些页标记为只读。当某一进程尝试写入时，触发页错误，内核复制该页并修改权限为可写。<br>
• <strong>优点</strong>：避免不必要的内存复制，提高资源利用率。</p>
<hr>
<h3 id="四应用注意事项"><strong>四、应用注意事项</strong></h3>
<ol>
<li><strong>文件操作同步</strong>：父子进程对同一文件描述符的并发写入需通过锁（如<code>flock()</code>）或原子操作避免竞争。</li>
<li><strong>内存共享限制</strong>：若需主动共享内存，需使用<code>mmap()</code>或共享内存API（如<code>shmget()</code>）。</li>
<li><strong>僵尸进程处理</strong>：父进程需通过<code>wait()</code>回收子进程资源，或注册<code>SIGCHLD</code>信号处理函数。</li>
</ol>
]]></content></item><item><title>文件锁（FileLock）的本质与价值</title><link>https://jekyulll.github.io/posts/cpp-%E6%96%87%E4%BB%B6%E9%94%81filelock%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BB%B7%E5%80%BC/</link><pubDate>Wed, 26 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E6%96%87%E4%BB%B6%E9%94%81filelock%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BB%B7%E5%80%BC/</guid><description>&lt;p>在多进程/多线程环境中，Mutex针对的是程序内部的内存数据结构（如链表、哈希表），无法直接控制外部资源（如磁盘文件）。例如，线程A通过Mutex保护一个缓存队列，但若另一个进程直接修改磁盘上的对应文件，Mutex无法拦截。此时可以用文件锁来解决。&lt;/p>
&lt;p>文件锁的核心逻辑是通过独占标记协调资源访问。&lt;/p>
&lt;p>&lt;strong>典型应用场景&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>配置文件的原子性更新&lt;/strong>&lt;br>
多个服务实例同时修改同一配置文件时，未加锁会导致最后的写入覆盖先前内容（例如Nginx配置热更新）&lt;/li>
&lt;li>&lt;strong>日志文件的顺序写入&lt;/strong>&lt;br>
多线程日志系统中，不加锁可能引发日志行交错（如Apache日志滚动的并发问题）&lt;/li>
&lt;li>&lt;strong>分布式系统的资源协调&lt;/strong>&lt;br>
在无中心化锁服务时，通过共享存储（如NFS）的文件锁实现分布式锁（类似ZooKeeper的临时节点机制）&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="c实现文件锁的三种范式">C++实现文件锁的三种范式&lt;/h3>
&lt;h4 id="方案一操作系统原生api工业级方案">&lt;strong>方案一：操作系统原生API（工业级方案）&lt;/strong>&lt;/h4>
&lt;p>&lt;strong>适用场景&lt;/strong>：需要高可靠性、跨平台兼容的生产环境&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;fcntl.h&amp;gt;&lt;/span>&lt;span style="color:#75715e"> &lt;/span>&lt;span style="color:#75715e">// Linux
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;windows.h&amp;gt;&lt;/span>&lt;span style="color:#75715e"> &lt;/span>&lt;span style="color:#75715e">// Windows
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">NativeFileLock&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">explicit&lt;/span> NativeFileLock(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> path) &lt;span style="color:#f92672">:&lt;/span> lock_path(path) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">acquire&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef _WIN32
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Windows通过独占模式创建文件实现锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> h_file &lt;span style="color:#f92672">=&lt;/span> CreateFileA(lock_path.c_str(), GENERIC_WRITE, &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">nullptr&lt;/span>, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> h_file &lt;span style="color:#f92672">!=&lt;/span> INVALID_HANDLE_VALUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Linux使用fcntl记录锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(lock_path.c_str(), O_RDWR &lt;span style="color:#f92672">|&lt;/span> O_CREAT, &lt;span style="color:#ae81ff">0644&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fd &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flock lock_struct{};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock_struct.l_type &lt;span style="color:#f92672">=&lt;/span> F_WRLCK; &lt;span style="color:#75715e">// 排他锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> lock_struct.l_whence &lt;span style="color:#f92672">=&lt;/span> SEEK_SET;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> fcntl(fd, F_SETLK, &lt;span style="color:#f92672">&amp;amp;&lt;/span>lock_struct) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">release&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef _WIN32
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> CloseHandle(h_file);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DeleteFileA(lock_path.c_str());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> close(fd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unlink(lock_path.c_str());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef _WIN32
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HANDLE h_file &lt;span style="color:#f92672">=&lt;/span> INVALID_HANDLE_VALUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string lock_path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>技术要点&lt;/strong>：&lt;br>
• Windows通过&lt;code>CREATE_ALWAYS&lt;/code>+隐藏属性实现原子创建&lt;br>
• Linux使用&lt;code>fcntl&lt;/code>的记录锁，支持对文件部分区域加锁&lt;br>
• 必须处理进程崩溃后的锁残留（通过&lt;code>unlink/DeleteFile&lt;/code>物理删除锁文件）&lt;/p></description><content type="html"><![CDATA[<p>在多进程/多线程环境中，Mutex针对的是程序内部的内存数据结构（如链表、哈希表），无法直接控制外部资源（如磁盘文件）。例如，线程A通过Mutex保护一个缓存队列，但若另一个进程直接修改磁盘上的对应文件，Mutex无法拦截。此时可以用文件锁来解决。</p>
<p>文件锁的核心逻辑是通过独占标记协调资源访问。</p>
<p><strong>典型应用场景</strong>：</p>
<ol>
<li><strong>配置文件的原子性更新</strong><br>
多个服务实例同时修改同一配置文件时，未加锁会导致最后的写入覆盖先前内容（例如Nginx配置热更新）</li>
<li><strong>日志文件的顺序写入</strong><br>
多线程日志系统中，不加锁可能引发日志行交错（如Apache日志滚动的并发问题）</li>
<li><strong>分布式系统的资源协调</strong><br>
在无中心化锁服务时，通过共享存储（如NFS）的文件锁实现分布式锁（类似ZooKeeper的临时节点机制）</li>
</ol>
<hr>
<h3 id="c实现文件锁的三种范式">C++实现文件锁的三种范式</h3>
<h4 id="方案一操作系统原生api工业级方案"><strong>方案一：操作系统原生API（工业级方案）</strong></h4>
<p><strong>适用场景</strong>：需要高可靠性、跨平台兼容的生产环境</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">    </span><span style="color:#75715e">// Linux
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">  </span><span style="color:#75715e">// Windows
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NativeFileLock</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">explicit</span> NativeFileLock(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> path) <span style="color:#f92672">:</span> lock_path(path) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">acquire</span>() {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Windows通过独占模式创建文件实现锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        h_file <span style="color:#f92672">=</span> CreateFileA(lock_path.c_str(), GENERIC_WRITE, <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>                           <span style="color:#66d9ef">nullptr</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, <span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> h_file <span style="color:#f92672">!=</span> INVALID_HANDLE_VALUE;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Linux使用fcntl记录锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        fd <span style="color:#f92672">=</span> open(lock_path.c_str(), O_RDWR <span style="color:#f92672">|</span> O_CREAT, <span style="color:#ae81ff">0644</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        flock lock_struct{};
</span></span><span style="display:flex;"><span>        lock_struct.l_type <span style="color:#f92672">=</span> F_WRLCK;  <span style="color:#75715e">// 排他锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        lock_struct.l_whence <span style="color:#f92672">=</span> SEEK_SET;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> fcntl(fd, F_SETLK, <span style="color:#f92672">&amp;</span>lock_struct) <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">release</span>() {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        CloseHandle(h_file);
</span></span><span style="display:flex;"><span>        DeleteFileA(lock_path.c_str());
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        close(fd);
</span></span><span style="display:flex;"><span>        unlink(lock_path.c_str());
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HANDLE h_file <span style="color:#f92672">=</span> INVALID_HANDLE_VALUE;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>string lock_path;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>技术要点</strong>：<br>
• Windows通过<code>CREATE_ALWAYS</code>+隐藏属性实现原子创建<br>
• Linux使用<code>fcntl</code>的记录锁，支持对文件部分区域加锁<br>
• 必须处理进程崩溃后的锁残留（通过<code>unlink/DeleteFile</code>物理删除锁文件）</p>
<hr>
<h4 id="方案二基于文件系统标记轻量级方案"><strong>方案二：基于文件系统标记（轻量级方案）</strong></h4>
<p><strong>适用场景</strong>：快速实现、非高并发场景</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;filesystem&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MarkerFileLock</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">explicit</span> MarkerFileLock(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> path) <span style="color:#f92672">:</span> lock_path(path) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">try_lock</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>exists(lock_path)) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>ofstream temp(lock_path);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> temp.is_open();  <span style="color:#75715e">// 文件创建成功即视为获得锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>() { 
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>filesystem<span style="color:#f92672">::</span>remove(lock_path); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string lock_path;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>局限性</strong>：<br>
• 无法检测锁文件被手动删除的意外情况<br>
• 进程崩溃可能导致死锁（需额外守护进程清理）</p>
<hr>
<h4 id="方案三内存映射原子操作高性能方案"><strong>方案三：内存映射+原子操作（高性能方案）</strong></h4>
<p><strong>适用场景</strong>：需要微秒级响应的关键系统</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mman.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;atomic&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MMapLock</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MMapLock(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> path) {
</span></span><span style="display:flex;"><span>        fd <span style="color:#f92672">=</span> open(path, O_RDWR <span style="color:#f92672">|</span> O_CREAT, <span style="color:#ae81ff">0644</span>);
</span></span><span style="display:flex;"><span>        ftruncate(fd, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));  <span style="color:#75715e">// 扩展文件大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        addr <span style="color:#f92672">=</span> mmap(<span style="color:#66d9ef">nullptr</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>), PROT_READ <span style="color:#f92672">|</span> PROT_WRITE, 
</span></span><span style="display:flex;"><span>                   MAP_SHARED, fd, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        counter <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;*&gt;</span>(addr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">lock</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> expected <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> counter<span style="color:#f92672">-&gt;</span>compare_exchange_strong(expected, <span style="color:#ae81ff">1</span>, 
</span></span><span style="display:flex;"><span>               std<span style="color:#f92672">::</span>memory_order_acquire);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>() {
</span></span><span style="display:flex;"><span>        counter<span style="color:#f92672">-&gt;</span>store(<span style="color:#ae81ff">0</span>, std<span style="color:#f92672">::</span>memory_order_release);
</span></span><span style="display:flex;"><span>        munmap(addr, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>        close(fd);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> addr;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;*</span> counter;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>优势</strong>：<br>
• 通过CPU原子指令实现无阻塞锁，性能比传统文件锁高10倍<br>
• 依赖内存映射文件实现跨进程同步</p>
<hr>
<h3 id="实现选择指南">实现选择指南</h3>
<table>
  <thead>
      <tr>
          <th>方案</th>
          <th>可靠性</th>
          <th>性能</th>
          <th>适用场景</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>原生API</td>
          <td>★★★</td>
          <td>★★☆</td>
          <td>生产环境、跨平台要求高</td>
      </tr>
      <tr>
          <td>文件标记</td>
          <td>★☆☆</td>
          <td>★★★</td>
          <td>快速原型、低并发需求</td>
      </tr>
      <tr>
          <td>内存映射+原子</td>
          <td>★★☆</td>
          <td>★★★</td>
          <td>高频访问、延迟敏感型系统（如交易系统）</td>
      </tr>
  </tbody>
</table>
<p><strong>避坑建议</strong>：</p>
<ol>
<li><strong>避免网络文件系统</strong>（如NFS）——锁机制可能因网络延迟失效</li>
<li><strong>设置超时退避</strong>——防止死锁（参考Java的<code>tryLock(timeout)</code>）</li>
<li><strong>锁文件路径规范化</strong>——建议使用<code>/var/lock/</code>等专用目录</li>
</ol>
]]></content></item><item><title>更新的二进制差异算法</title><link>https://jekyulll.github.io/posts/alg-%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B7%AE%E5%BC%82%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 26 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/alg-%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B7%AE%E5%BC%82%E7%AE%97%E6%B3%95/</guid><description>&lt;p>替换一个二进制文件有以下两个思路：&lt;/p>
&lt;p>使用完整的一个新文件直接覆盖旧的文件。
只替换新旧文件之间的差异。通过算法去计算新旧文件之间的差异，然后将差异部分移动到目标机器上。
其中方法一制作的更新就叫做全量更新（Full Update）。而方法二就是二进制差分方式，即增量更新（Delta Update）。&lt;/p>
&lt;hr>
&lt;h2 id="增量更新">增量更新&lt;/h2>
&lt;p>增量更新有两个方式：&lt;strong>文件差量更新&lt;/strong>、&lt;strong>二进制差量更新&lt;/strong>。&lt;br>
大部分的大软件，如 QQ 等，都会在自动更新的时候都会使用文件差量更新和二进制差量更新一起使用的策略。&lt;/p>
&lt;p>二进制差分更新对于就文件的状态有严格的要求，这是因为不同版本之间的二进制差异不同。&lt;br>
举个例子：某个新的文件A的版本是3，需要更新到用户的机器上。但是部分用户机器上安装的文件A版本是1，部分用户的文件A是版本2。这种情况下，就需要分别计算版本3和版本1的差异，以及版本3和版本2的差异。然后根据不同用户的情况分别发送不同的二进制差异文件。&lt;br>
想要进行增量更新，需要构建模块支持才能实现。确定性构建就是在代码没有变更的时候，构建输出的 DLL 或 Exe 一定是不变的。对应的，还应加入确定性混淆的支持，有一些代码接入了混淆过程，要求在代码没有变更的时候，最后混淆输出的文件也没有变更。&lt;/p>
&lt;p>增量更新不能热更新，需要重启才能生效。&lt;/p>
&lt;p>用到的算法主要有&lt;a href="https://www.daemonology.net/bsdiff/">bsdiff&lt;/a>，&lt;a href="https://github.com/OctopusDeploy/Octodiff">octodiff&lt;/a>，xdelta。&lt;/p>
&lt;p>bsdiff 算法的时间复杂度和空间复杂度都很高。但优点是更新文件大小比较小。&lt;/p>
&lt;blockquote>
&lt;p>处理大文件选择Octodiff，处理小文件选择bsdiff.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="正向逆向差分技术">正向/逆向差分技术&lt;/h2>
&lt;p>在此之前，为了解决Windows累积更新体积过大的问题，微软使用的是Express Update技术。Express技术确实减小了累积更新的体积，但是却极大的增加了Window更新服务器的计算压力与存储压力。Express更新文件在更新服务器上通常会有大于10GB的体积。Express Update正是使用的增量更新方式，并且把所有文件的所有版本差异都存储到了更新服务器上（海量的文件）。&lt;/p>
&lt;p>Windows 10 1809版本之后引入了基于二进制的正向/逆向差分技术。&lt;/p>
&lt;p>二进制差分是需要严格比对文件的版本信息的。如果被替换文件的版本不确定，那么就无法应用二进制差分。如果本替换文件的版本非常多，那么就需要针对每一个版本分别计算二进制差分，这样一来，不同版本的二进制差分的总和体积也必然不会小，因此就抵消掉差分带来的体积优势。&lt;/p>
&lt;p>正向/逆向差分技术的核心思路是：将被替换文件的版本固定，这样就能唯一确定一个二进制差分了。那么，将被替换的文件版本固定成什么版本呢？&lt;br>
Windows更新用的方法是，将所有需要被更新的文件版本回到Windows 10 基线版本 。然后，从基线版本安装二进制差分，完成文件的更新。&lt;br>
这里，从当前的文件版本回退到基线版本的过程被称为&lt;strong>逆向&lt;/strong>，从基线版本更新到最新的版本的过程称为&lt;strong>正向&lt;/strong>，也被称为&lt;strong>注水&lt;/strong>（hydration）。制作差分二进制叫做&lt;strong>脱水&lt;/strong>（dehydration）。&lt;br>
这两次文件更新的行为都使用差分二进制来完成，因此这就是正向/逆向二进制差分技术。&lt;/p>
&lt;p>核心逻辑在于通过固定基线版本（RTM）作为唯一中间状态，规避多版本组合带来的差分数爆炸问题。&lt;br>
这样只需要存储一个当前版本到基线版本的二进制差分，然后统一从基线版本升级到新版本。&lt;br>
（&lt;em>eg&lt;/em>. 例如有0、1、2、3、4版本。如果用老办法，需要存储0-&amp;gt;1，0-&amp;gt;2，0-&amp;gt;3，0-&amp;gt;4，1-&amp;gt;2，1-&amp;gt;3，1-&amp;gt;4，2-&amp;gt;3，2-&amp;gt;4，3-&amp;gt;4的差分包，多了之后数量爆炸，因为&lt;u>增加新版本的时候需要存储之前所有版本到新版本的差分包&lt;/u>。&lt;br>
如果采用正向/逆向差分，要存储1-&amp;gt;0，2-&amp;gt;0，3-&amp;gt;0，4-&amp;gt;0，然后存储0-&amp;gt;1，0-&amp;gt;2，0-&amp;gt;3，0-&amp;gt;4。增加新版本的时候，只需要增加5-&amp;gt;0和0-&amp;gt;5，从n的累加优化到了n的线性关系的差分包数量。&lt;br>
）&lt;/p>
&lt;p>基于正向/逆向二进制差分的Windows累积更新内部包含以下内容：&lt;/p>
&lt;ul>
&lt;li>从基线版本到最新版本N的正向二进制差分文件&lt;/li>
&lt;li>回退到基线版本所需的逆向二进制差分文件&lt;/li>
&lt;li>更新文件清单（Manifest）&lt;/li>
&lt;li>更新文件Metadata&lt;/li>
&lt;/ul>
&lt;p>如果是离线更新MSU，还会多一些版本以及操作系统适应性判断的内容。&lt;/p>
&lt;hr>
&lt;h3 id="source--reference">Source &amp;amp;&amp;amp; Reference&lt;/h3>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/13382743061">二进制差异文件算法&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://github.com/Squirrel/Squirrel.Windows">Squirrel.Windows: An installation and update framework for Windows desktop apps&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://zhuyie.github.io/posts/bsdiff-annotated/">bsdiff源码解析&lt;/a>。&lt;/p>
&lt;p>这段时间看到的最牛逼的文章：&lt;a href="https://jishuzhan.net/article/1874273746852777985#google_vignette">Windows 客户端软件自动更新服务的开发有哪些需求？&lt;/a>。&lt;/p>
&lt;p>微软官方对正向/逆向二进制差分Updates的介绍：&lt;a href="https://learn.microsoft.com/en-us/windows/deployment/update/forward-reverse-differentials">Windows Updates using forward and reverse differentials&lt;/a>。&lt;/p></description><content type="html"><![CDATA[<p>替换一个二进制文件有以下两个思路：</p>
<p>使用完整的一个新文件直接覆盖旧的文件。
只替换新旧文件之间的差异。通过算法去计算新旧文件之间的差异，然后将差异部分移动到目标机器上。
其中方法一制作的更新就叫做全量更新（Full Update）。而方法二就是二进制差分方式，即增量更新（Delta Update）。</p>
<hr>
<h2 id="增量更新">增量更新</h2>
<p>增量更新有两个方式：<strong>文件差量更新</strong>、<strong>二进制差量更新</strong>。<br>
大部分的大软件，如 QQ 等，都会在自动更新的时候都会使用文件差量更新和二进制差量更新一起使用的策略。</p>
<p>二进制差分更新对于就文件的状态有严格的要求，这是因为不同版本之间的二进制差异不同。<br>
举个例子：某个新的文件A的版本是3，需要更新到用户的机器上。但是部分用户机器上安装的文件A版本是1，部分用户的文件A是版本2。这种情况下，就需要分别计算版本3和版本1的差异，以及版本3和版本2的差异。然后根据不同用户的情况分别发送不同的二进制差异文件。<br>
想要进行增量更新，需要构建模块支持才能实现。确定性构建就是在代码没有变更的时候，构建输出的 DLL 或 Exe 一定是不变的。对应的，还应加入确定性混淆的支持，有一些代码接入了混淆过程，要求在代码没有变更的时候，最后混淆输出的文件也没有变更。</p>
<p>增量更新不能热更新，需要重启才能生效。</p>
<p>用到的算法主要有<a href="https://www.daemonology.net/bsdiff/">bsdiff</a>，<a href="https://github.com/OctopusDeploy/Octodiff">octodiff</a>，xdelta。</p>
<p>bsdiff 算法的时间复杂度和空间复杂度都很高。但优点是更新文件大小比较小。</p>
<blockquote>
<p>处理大文件选择Octodiff，处理小文件选择bsdiff.</p>
</blockquote>
<hr>
<h2 id="正向逆向差分技术">正向/逆向差分技术</h2>
<p>在此之前，为了解决Windows累积更新体积过大的问题，微软使用的是Express Update技术。Express技术确实减小了累积更新的体积，但是却极大的增加了Window更新服务器的计算压力与存储压力。Express更新文件在更新服务器上通常会有大于10GB的体积。Express Update正是使用的增量更新方式，并且把所有文件的所有版本差异都存储到了更新服务器上（海量的文件）。</p>
<p>Windows 10 1809版本之后引入了基于二进制的正向/逆向差分技术。</p>
<p>二进制差分是需要严格比对文件的版本信息的。如果被替换文件的版本不确定，那么就无法应用二进制差分。如果本替换文件的版本非常多，那么就需要针对每一个版本分别计算二进制差分，这样一来，不同版本的二进制差分的总和体积也必然不会小，因此就抵消掉差分带来的体积优势。</p>
<p>正向/逆向差分技术的核心思路是：将被替换文件的版本固定，这样就能唯一确定一个二进制差分了。那么，将被替换的文件版本固定成什么版本呢？<br>
Windows更新用的方法是，将所有需要被更新的文件版本回到Windows 10 基线版本 。然后，从基线版本安装二进制差分，完成文件的更新。<br>
这里，从当前的文件版本回退到基线版本的过程被称为<strong>逆向</strong>，从基线版本更新到最新的版本的过程称为<strong>正向</strong>，也被称为<strong>注水</strong>（hydration）。制作差分二进制叫做<strong>脱水</strong>（dehydration）。<br>
这两次文件更新的行为都使用差分二进制来完成，因此这就是正向/逆向二进制差分技术。</p>
<p>核心逻辑在于通过固定基线版本（RTM）作为唯一中间状态，规避多版本组合带来的差分数爆炸问题。<br>
这样只需要存储一个当前版本到基线版本的二进制差分，然后统一从基线版本升级到新版本。<br>
（<em>eg</em>. 例如有0、1、2、3、4版本。如果用老办法，需要存储0-&gt;1，0-&gt;2，0-&gt;3，0-&gt;4，1-&gt;2，1-&gt;3，1-&gt;4，2-&gt;3，2-&gt;4，3-&gt;4的差分包，多了之后数量爆炸，因为<u>增加新版本的时候需要存储之前所有版本到新版本的差分包</u>。<br>
如果采用正向/逆向差分，要存储1-&gt;0，2-&gt;0，3-&gt;0，4-&gt;0，然后存储0-&gt;1，0-&gt;2，0-&gt;3，0-&gt;4。增加新版本的时候，只需要增加5-&gt;0和0-&gt;5，从n的累加优化到了n的线性关系的差分包数量。<br>
）</p>
<p>基于正向/逆向二进制差分的Windows累积更新内部包含以下内容：</p>
<ul>
<li>从基线版本到最新版本N的正向二进制差分文件</li>
<li>回退到基线版本所需的逆向二进制差分文件</li>
<li>更新文件清单（Manifest）</li>
<li>更新文件Metadata</li>
</ul>
<p>如果是离线更新MSU，还会多一些版本以及操作系统适应性判断的内容。</p>
<hr>
<h3 id="source--reference">Source &amp;&amp; Reference</h3>
<p><a href="https://zhuanlan.zhihu.com/p/13382743061">二进制差异文件算法</a>。</p>
<p><a href="https://github.com/Squirrel/Squirrel.Windows">Squirrel.Windows: An installation and update framework for Windows desktop apps</a>。</p>
<p><a href="https://zhuyie.github.io/posts/bsdiff-annotated/">bsdiff源码解析</a>。</p>
<p>这段时间看到的最牛逼的文章：<a href="https://jishuzhan.net/article/1874273746852777985#google_vignette">Windows 客户端软件自动更新服务的开发有哪些需求？</a>。</p>
<p>微软官方对正向/逆向二进制差分Updates的介绍：<a href="https://learn.microsoft.com/en-us/windows/deployment/update/forward-reverse-differentials">Windows Updates using forward and reverse differentials</a>。</p>
<p><a href="https://www.toutiao.com/article/7156768607085658662/?wid=1742955409104">基于正向/逆向二进制差分的Windows累积更新</a>。</p>
<p><a href="https://www.toutiao.com/article/7389464626552898082">Windows Update 技术详解系列之快速分发技术Express Update</a>。</p>
]]></content></item><item><title>Nginx 的多进程模型</title><link>https://jekyulll.github.io/posts/web-nginx-%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Fri, 21 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-nginx-%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>在Web服务器领域，Nginx凭借其高并发、低资源消耗的特点脱颖而出。其核心设计选择之一便是&lt;strong>多进程模型&lt;/strong>。这一设计看似与传统多线程模型背道而驰，却恰恰成就了Nginx的卓越性能。本文将从技术原理、场景适配、架构权衡等角度，深度解析Nginx偏爱多进程的底层逻辑。&lt;/p>
&lt;hr>
&lt;h4 id="一多进程模型的核心架构">一、多进程模型的核心架构&lt;/h4>
&lt;p>Nginx采用经典的&lt;strong>Master-Worker多进程架构&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Master进程&lt;/strong>：负责全局管理，包括配置加载、信号处理、Worker进程监控与重启。&lt;/li>
&lt;li>&lt;strong>Worker进程&lt;/strong>：实际处理请求的“战斗单元”，每个Worker独立运行且绑定到特定CPU核心，通过&lt;strong>异步非阻塞事件驱动模型&lt;/strong>处理成千上万的并发连接。&lt;br>
这种设计实现了&lt;strong>资源隔离&lt;/strong>与&lt;strong>职责分离&lt;/strong>，Master的稳定性不受Worker业务逻辑影响，Worker的崩溃也不会导致服务中断。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="二选择多进程的五大核心原因">二、选择多进程的五大核心原因&lt;/h4>
&lt;h5 id="1-最大化多核cpu利用率">1. &lt;strong>最大化多核CPU利用率&lt;/strong>&lt;/h5>
&lt;p>现代服务器普遍采用多核架构，Nginx通过为每个Worker进程绑定独立CPU核心，避免了线程上下文切换的开销，使硬件资源被充分调度。例如，8核服务器可启动8个Worker，每个进程独占一核执行无锁化任务处理。&lt;/p>
&lt;h5 id="2-规避多线程锁竞争">2. &lt;strong>规避多线程锁竞争&lt;/strong>&lt;/h5>
&lt;p>多线程模型中，共享内存的访问需通过锁机制同步，而锁竞争会导致性能急剧下降。Nginx的多进程模型天然隔离了内存空间，Worker之间无需加锁，消除了这一性能瓶颈。&lt;/p>
&lt;h5 id="3-故障隔离与高可用性">3. &lt;strong>故障隔离与高可用性&lt;/strong>&lt;/h5>
&lt;p>若某个Worker进程因代码缺陷崩溃，Master进程可立即重启新Worker，其他进程仍正常服务。这种“单点故障不影响全局”的特性，显著提升了系统的容错能力。相比之下，多线程模型中线程崩溃可能导致整个进程宕机。&lt;/p>
&lt;h5 id="4-简化开发与维护">4. &lt;strong>简化开发与维护&lt;/strong>&lt;/h5>
&lt;p>多进程模型的代码结构更清晰：&lt;br>
• Worker之间无共享状态，避免复杂的线程同步逻辑&lt;br>
• 调试时可通过&lt;code>gdb&lt;/code>单独附加到某个Worker进程，无需处理线程交织问题&lt;/p>
&lt;h5 id="5-与事件驱动模型的完美契合">5. &lt;strong>与事件驱动模型的完美契合&lt;/strong>&lt;/h5>
&lt;p>Nginx的&lt;strong>异步非阻塞I/O多路复用&lt;/strong>（如Linux的epoll）是其高并发的另一基石。每个Worker进程通过单线程循环处理事件，避免了传统多进程模型中“一请求一进程”的资源浪费。这种组合使得单个Worker即可高效管理数万连接。&lt;/p>
&lt;hr>
&lt;h4 id="三多进程模型的局限性">三、多进程模型的局限性&lt;/h4>
&lt;p>尽管优势显著，该模型也存在以下挑战：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>内存占用较高&lt;/strong>：每个Worker需独立的内存空间，连接数极高时可能产生冗余开销。&lt;/li>
&lt;li>&lt;strong>进程间通信复杂&lt;/strong>：共享数据需通过IPC（如共享内存），开发复杂度高于线程模型。&lt;/li>
&lt;li>&lt;strong>计算密集型场景劣势&lt;/strong>：若请求涉及大量CPU运算（如加密解密），多线程模型可能更高效。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="四与其他模型的对比分析">四、与其他模型的对比分析&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>模型类型&lt;/th>
&lt;th>典型代表&lt;/th>
&lt;th>适用场景&lt;/th>
&lt;th>Nginx的选择依据&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>多进程单线程&lt;/strong>&lt;/td>
&lt;td>Nginx&lt;/td>
&lt;td>I/O密集型高并发&lt;/td>
&lt;td>规避锁竞争，隔离故障&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>单进程多线程&lt;/strong>&lt;/td>
&lt;td>Apache&lt;/td>
&lt;td>计算密集型任务&lt;/td>
&lt;td>线程崩溃风险高，调试复杂&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>协程模型&lt;/strong>&lt;/td>
&lt;td>Go&lt;/td>
&lt;td>高并发微服务&lt;/td>
&lt;td>需语言运行时支持，生态差异&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h4 id="五设计启示如何选择并发模型">五、设计启示：如何选择并发模型？&lt;/h4>
&lt;p>Nginx的实践为高并发系统设计提供了重要参考：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>区分任务类型&lt;/strong>：I/O密集型首选事件驱动+多进程，计算密集型可考虑多线程。&lt;/li>
&lt;li>&lt;strong>权衡开发成本&lt;/strong>：多进程模型更易实现稳定性，但需额外处理IPC；多线程开发门槛更高。&lt;/li>
&lt;li>&lt;strong>利用操作系统特性&lt;/strong>：如Linux的CPU亲和性（affinity）可优化多进程绑定。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="结语">结语&lt;/h4>
&lt;p>Nginx的多进程模型并非偶然，而是针对Web服务器&lt;strong>高并发、低延迟、强稳定&lt;/strong>的核心需求做出的理性权衡。它通过资源隔离、无锁架构与事件驱动的三重设计，在I/O密集型场景中展现了无可替代的优势。正如其作者Igor Sysoev所言：“简单性是可扩展性的基石”——多进程模型正是这一哲学的最佳实践。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>参考资料&lt;/strong>：&lt;br>
[1] 其其网《Nginx为何偏爱多进程模型》&lt;br>
[4][6] CSDN博客《nginx为什么是多进程单线程》&lt;br>
[2][3] CSDN博客《Nginx工作原理》&lt;/p>
&lt;/blockquote></description><content type="html"><![CDATA[<p>在Web服务器领域，Nginx凭借其高并发、低资源消耗的特点脱颖而出。其核心设计选择之一便是<strong>多进程模型</strong>。这一设计看似与传统多线程模型背道而驰，却恰恰成就了Nginx的卓越性能。本文将从技术原理、场景适配、架构权衡等角度，深度解析Nginx偏爱多进程的底层逻辑。</p>
<hr>
<h4 id="一多进程模型的核心架构">一、多进程模型的核心架构</h4>
<p>Nginx采用经典的<strong>Master-Worker多进程架构</strong>：</p>
<ol>
<li><strong>Master进程</strong>：负责全局管理，包括配置加载、信号处理、Worker进程监控与重启。</li>
<li><strong>Worker进程</strong>：实际处理请求的“战斗单元”，每个Worker独立运行且绑定到特定CPU核心，通过<strong>异步非阻塞事件驱动模型</strong>处理成千上万的并发连接。<br>
这种设计实现了<strong>资源隔离</strong>与<strong>职责分离</strong>，Master的稳定性不受Worker业务逻辑影响，Worker的崩溃也不会导致服务中断。</li>
</ol>
<hr>
<h4 id="二选择多进程的五大核心原因">二、选择多进程的五大核心原因</h4>
<h5 id="1-最大化多核cpu利用率">1. <strong>最大化多核CPU利用率</strong></h5>
<p>现代服务器普遍采用多核架构，Nginx通过为每个Worker进程绑定独立CPU核心，避免了线程上下文切换的开销，使硬件资源被充分调度。例如，8核服务器可启动8个Worker，每个进程独占一核执行无锁化任务处理。</p>
<h5 id="2-规避多线程锁竞争">2. <strong>规避多线程锁竞争</strong></h5>
<p>多线程模型中，共享内存的访问需通过锁机制同步，而锁竞争会导致性能急剧下降。Nginx的多进程模型天然隔离了内存空间，Worker之间无需加锁，消除了这一性能瓶颈。</p>
<h5 id="3-故障隔离与高可用性">3. <strong>故障隔离与高可用性</strong></h5>
<p>若某个Worker进程因代码缺陷崩溃，Master进程可立即重启新Worker，其他进程仍正常服务。这种“单点故障不影响全局”的特性，显著提升了系统的容错能力。相比之下，多线程模型中线程崩溃可能导致整个进程宕机。</p>
<h5 id="4-简化开发与维护">4. <strong>简化开发与维护</strong></h5>
<p>多进程模型的代码结构更清晰：<br>
• Worker之间无共享状态，避免复杂的线程同步逻辑<br>
• 调试时可通过<code>gdb</code>单独附加到某个Worker进程，无需处理线程交织问题</p>
<h5 id="5-与事件驱动模型的完美契合">5. <strong>与事件驱动模型的完美契合</strong></h5>
<p>Nginx的<strong>异步非阻塞I/O多路复用</strong>（如Linux的epoll）是其高并发的另一基石。每个Worker进程通过单线程循环处理事件，避免了传统多进程模型中“一请求一进程”的资源浪费。这种组合使得单个Worker即可高效管理数万连接。</p>
<hr>
<h4 id="三多进程模型的局限性">三、多进程模型的局限性</h4>
<p>尽管优势显著，该模型也存在以下挑战：</p>
<ol>
<li><strong>内存占用较高</strong>：每个Worker需独立的内存空间，连接数极高时可能产生冗余开销。</li>
<li><strong>进程间通信复杂</strong>：共享数据需通过IPC（如共享内存），开发复杂度高于线程模型。</li>
<li><strong>计算密集型场景劣势</strong>：若请求涉及大量CPU运算（如加密解密），多线程模型可能更高效。</li>
</ol>
<hr>
<h4 id="四与其他模型的对比分析">四、与其他模型的对比分析</h4>
<table>
  <thead>
      <tr>
          <th>模型类型</th>
          <th>典型代表</th>
          <th>适用场景</th>
          <th>Nginx的选择依据</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>多进程单线程</strong></td>
          <td>Nginx</td>
          <td>I/O密集型高并发</td>
          <td>规避锁竞争，隔离故障</td>
      </tr>
      <tr>
          <td><strong>单进程多线程</strong></td>
          <td>Apache</td>
          <td>计算密集型任务</td>
          <td>线程崩溃风险高，调试复杂</td>
      </tr>
      <tr>
          <td><strong>协程模型</strong></td>
          <td>Go</td>
          <td>高并发微服务</td>
          <td>需语言运行时支持，生态差异</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="五设计启示如何选择并发模型">五、设计启示：如何选择并发模型？</h4>
<p>Nginx的实践为高并发系统设计提供了重要参考：</p>
<ol>
<li><strong>区分任务类型</strong>：I/O密集型首选事件驱动+多进程，计算密集型可考虑多线程。</li>
<li><strong>权衡开发成本</strong>：多进程模型更易实现稳定性，但需额外处理IPC；多线程开发门槛更高。</li>
<li><strong>利用操作系统特性</strong>：如Linux的CPU亲和性（affinity）可优化多进程绑定。</li>
</ol>
<hr>
<h4 id="结语">结语</h4>
<p>Nginx的多进程模型并非偶然，而是针对Web服务器<strong>高并发、低延迟、强稳定</strong>的核心需求做出的理性权衡。它通过资源隔离、无锁架构与事件驱动的三重设计，在I/O密集型场景中展现了无可替代的优势。正如其作者Igor Sysoev所言：“简单性是可扩展性的基石”——多进程模型正是这一哲学的最佳实践。</p>
<blockquote>
<p><strong>参考资料</strong>：<br>
[1] 其其网《Nginx为何偏爱多进程模型》<br>
[4][6] CSDN博客《nginx为什么是多进程单线程》<br>
[2][3] CSDN博客《Nginx工作原理》</p>
</blockquote>
]]></content></item><item><title>流计算中的反向压力模型与 Reactive Streams --C++实现</title><link>https://jekyulll.github.io/posts/web-%E6%B5%81%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E5%8E%8B%E5%8A%9B%E6%A8%A1%E5%9E%8B%E4%B8%8E-reactive-streams---c++%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 21 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-%E6%B5%81%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E5%8E%8B%E5%8A%9B%E6%A8%A1%E5%9E%8B%E4%B8%8E-reactive-streams---c++%E5%AE%9E%E7%8E%B0/</guid><description>&lt;h2 id="一反向压力backpressure的核心意义">一、反向压力（Backpressure）的核心意义&lt;/h2>
&lt;p>在流式计算中，数据生产者的生成速率与消费者的处理速率往往不匹配。若生产者速度远高于消费者，无限制的缓冲会导致&lt;strong>内存溢出&lt;/strong>或&lt;strong>系统崩溃&lt;/strong>。反向压力（Backpressure）机制通过动态调节数据流速，实现生产者与消费者的&lt;strong>速率适配&lt;/strong>，从而保证系统的稳定性与资源可控性。&lt;/p>
&lt;h3 id="11-背压的两种实现模式">1.1 背压的两种实现模式&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>阻塞式反馈&lt;/strong>：通过队列容量限制直接阻塞生产者（如线程等待）。&lt;/li>
&lt;li>&lt;strong>非阻塞式协商&lt;/strong>：通过异步信号（如请求量协商）动态调整生产者速率（Reactive Streams的核心机制）。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="二reactive-streams规范与c映射">二、Reactive Streams规范与C++映射&lt;/h2>
&lt;p>Reactive Streams是异步流处理的&lt;strong>标准化规范&lt;/strong>，定义了四个核心组件：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>组件&lt;/th>
&lt;th>职责&lt;/th>
&lt;th>C++类设计示例（伪代码）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Publisher&lt;/strong>&lt;/td>
&lt;td>数据生产者（如传感器、文件读取）&lt;/td>
&lt;td>&lt;code>class Publisher&amp;lt;T&amp;gt; { virtual void subscribe(Subscriber&amp;lt;T&amp;gt;&amp;amp;) = 0; };&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Subscriber&lt;/strong>&lt;/td>
&lt;td>数据消费者（如数据库写入、网络发送）&lt;/td>
&lt;td>&lt;code>class Subscriber&amp;lt;T&amp;gt; { virtual void onNext(const T&amp;amp;) = 0; };&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Subscription&lt;/strong>&lt;/td>
&lt;td>订阅上下文（背压协商）&lt;/td>
&lt;td>&lt;code>class Subscription { virtual void request(int n) = 0; };&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Processor&lt;/strong>&lt;/td>
&lt;td>中间处理节点（如数据过滤、转换）&lt;/td>
&lt;td>&lt;code>class Processor&amp;lt;T, R&amp;gt; : public Subscriber&amp;lt;T&amp;gt;, Publisher&amp;lt;R&amp;gt; {};&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="21-c实现的核心逻辑">2.1 C++实现的核心逻辑&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 基于条件变量的背压队列（简化版）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BoundedQueue&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> buffer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>mutex mtx;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>condition_variable not_full;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>condition_variable not_empty;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t capacity;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> push(&lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(mtx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> not_full.wait(lock, [&lt;span style="color:#66d9ef">this&lt;/span>] { &lt;span style="color:#66d9ef">return&lt;/span> buffer.size() &lt;span style="color:#f92672">&amp;lt;&lt;/span> capacity; });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.push(item);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> not_empty.notify_one();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T &lt;span style="color:#a6e22e">pop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(mtx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> not_empty.wait(lock, [&lt;span style="color:#66d9ef">this&lt;/span>] { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>buffer.empty(); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T val &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>move(buffer.front());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> not_full.notify_one();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明&lt;/strong>：队列满时阻塞&lt;code>push&lt;/code>，空时阻塞&lt;code>pop&lt;/code>，通过条件变量实现生产者-消费者的速率同步。&lt;/p></description><content type="html"><![CDATA[<h2 id="一反向压力backpressure的核心意义">一、反向压力（Backpressure）的核心意义</h2>
<p>在流式计算中，数据生产者的生成速率与消费者的处理速率往往不匹配。若生产者速度远高于消费者，无限制的缓冲会导致<strong>内存溢出</strong>或<strong>系统崩溃</strong>。反向压力（Backpressure）机制通过动态调节数据流速，实现生产者与消费者的<strong>速率适配</strong>，从而保证系统的稳定性与资源可控性。</p>
<h3 id="11-背压的两种实现模式">1.1 背压的两种实现模式</h3>
<ol>
<li><strong>阻塞式反馈</strong>：通过队列容量限制直接阻塞生产者（如线程等待）。</li>
<li><strong>非阻塞式协商</strong>：通过异步信号（如请求量协商）动态调整生产者速率（Reactive Streams的核心机制）。</li>
</ol>
<hr>
<h2 id="二reactive-streams规范与c映射">二、Reactive Streams规范与C++映射</h2>
<p>Reactive Streams是异步流处理的<strong>标准化规范</strong>，定义了四个核心组件：</p>
<table>
  <thead>
      <tr>
          <th>组件</th>
          <th>职责</th>
          <th>C++类设计示例（伪代码）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Publisher</strong></td>
          <td>数据生产者（如传感器、文件读取）</td>
          <td><code>class Publisher&lt;T&gt; { virtual void subscribe(Subscriber&lt;T&gt;&amp;) = 0; };</code></td>
      </tr>
      <tr>
          <td><strong>Subscriber</strong></td>
          <td>数据消费者（如数据库写入、网络发送）</td>
          <td><code>class Subscriber&lt;T&gt; { virtual void onNext(const T&amp;) = 0; };</code></td>
      </tr>
      <tr>
          <td><strong>Subscription</strong></td>
          <td>订阅上下文（背压协商）</td>
          <td><code>class Subscription { virtual void request(int n) = 0; };</code></td>
      </tr>
      <tr>
          <td><strong>Processor</strong></td>
          <td>中间处理节点（如数据过滤、转换）</td>
          <td><code>class Processor&lt;T, R&gt; : public Subscriber&lt;T&gt;, Publisher&lt;R&gt; {};</code></td>
      </tr>
  </tbody>
</table>
<h3 id="21-c实现的核心逻辑">2.1 C++实现的核心逻辑</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 基于条件变量的背压队列（简化版）  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BoundedQueue</span> {  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> buffer;  
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>mutex mtx;  
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>condition_variable not_full;  
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>condition_variable not_empty;  
</span></span><span style="display:flex;"><span>    size_t capacity;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> push(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> item) {  
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(mtx);  
</span></span><span style="display:flex;"><span>        not_full.wait(lock, [<span style="color:#66d9ef">this</span>] { <span style="color:#66d9ef">return</span> buffer.size() <span style="color:#f92672">&lt;</span> capacity; });  
</span></span><span style="display:flex;"><span>        buffer.push(item);  
</span></span><span style="display:flex;"><span>        not_empty.notify_one();  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    T <span style="color:#a6e22e">pop</span>() {  
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(mtx);  
</span></span><span style="display:flex;"><span>        not_empty.wait(lock, [<span style="color:#66d9ef">this</span>] { <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>buffer.empty(); });  
</span></span><span style="display:flex;"><span>        T val <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(buffer.front());  
</span></span><span style="display:flex;"><span>        buffer.pop();  
</span></span><span style="display:flex;"><span>        not_full.notify_one();  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> val;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span></code></pre></div><p><strong>说明</strong>：队列满时阻塞<code>push</code>，空时阻塞<code>pop</code>，通过条件变量实现生产者-消费者的速率同步。</p>
<hr>
<h2 id="三完整流处理管道的c实现">三、完整流处理管道的C++实现</h2>
<h3 id="31-流处理节点设计">3.1 流处理节点设计</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 数据源（Publisher实现）  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataSource</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Publisher<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> {  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> subscribe(Subscriber<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> sub) <span style="color:#66d9ef">override</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span><span style="color:#f92672">*</span> subscription <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DataSubscription(sub);  
</span></span><span style="display:flex;"><span>        sub.onSubscribe(<span style="color:#f92672">*</span>subscription);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 订阅契约（实现背压请求）  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataSubscription</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Subscription {  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>    Subscriber<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> subscriber;  
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> canceled{false};  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> request(<span style="color:#66d9ef">int</span> n) <span style="color:#66d9ef">override</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>canceled; <span style="color:#f92672">++</span>i) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> data <span style="color:#f92672">=</span> generateData(); <span style="color:#75715e">// 模拟数据生成  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            subscriber.onNext(data);  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 数据处理节点（Processor实现）  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TransformProcessor</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Processor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> {  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> onNext(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> data) <span style="color:#66d9ef">override</span> {  
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>string transformed <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>to_string(data <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>);  
</span></span><span style="display:flex;"><span>        outputQueue.push(transformed);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span></code></pre></div><h3 id="32-线程池与异步调度">3.2 线程池与异步调度</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 基于线程池的任务执行器  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReactiveExecutor</span> {  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>    BoundedQueue<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;&gt;</span> taskQueue{<span style="color:#ae81ff">1024</span>};  
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">&gt;</span> workers;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>    ReactiveExecutor(size_t threads) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> threads; <span style="color:#f92672">++</span>i) {  
</span></span><span style="display:flex;"><span>            workers.emplace_back([<span style="color:#66d9ef">this</span>] {  
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (true) {  
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">auto</span> task <span style="color:#f92672">=</span> taskQueue.pop();  
</span></span><span style="display:flex;"><span>                    task();  
</span></span><span style="display:flex;"><span>                }  
</span></span><span style="display:flex;"><span>            });  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">submit</span>(std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task) {  
</span></span><span style="display:flex;"><span>        taskQueue.push(std<span style="color:#f92672">::</span>move(task));  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span></code></pre></div><p><strong>优化点</strong>：通过有界队列实现任务提交的背压控制，防止线程池过载。</p>
<hr>
<h2 id="四性能调优与扩展">四、性能调优与扩展</h2>
<h3 id="41-动态队列扩容策略">4.1 动态队列扩容策略</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DynamicBoundedQueue</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> BoundedQueue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> {  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> push(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> item) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (buffer.size() <span style="color:#f92672">&gt;=</span> capacity <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.8</span>) {  
</span></span><span style="display:flex;"><span>            capacity <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// 动态扩容  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }  
</span></span><span style="display:flex;"><span>        BoundedQueue<span style="color:#f92672">::</span>push(item);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span></code></pre></div><h3 id="42-背压指标监控">4.2 背压指标监控</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>size_t <span style="color:#a6e22e">getBackpressureLevel</span>() <span style="color:#66d9ef">const</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> buffer.size() <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span> <span style="color:#f92672">/</span> capacity; <span style="color:#75715e">// 返回队列占用百分比  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}  
</span></span></code></pre></div><hr>
<h2 id="五应用场景">五、应用场景</h2>
<p>• <strong>实时风控系统</strong>：防止数据洪峰导致内存溢出<br>
• <strong>物联网设备</strong>：处理海量传感器数据流<br>
• <strong>视频流处理</strong>：动态调整视频帧解码速率</p>
<hr>
<dl>
<dt><strong>扩展阅读</strong>：Reactor框架设计思想 | 微服务背压实践</dt>
<dd>
<p>流计算中的反向压力模型与生产者-消费者模式</p>
</dd>
<dd>Reactive Streams背压机制解析</dd>
<dd>Reactive Streams规范与组件定义</dd>
<dd>背压的应用场景与实现策略</dd>
<dd>物联网中的流处理实践</dd>
<dd>Spring WebFlux与Reactor模型</dd>
<dd>微服务架构中的背压设计</dd>
<dd>C++线程池与异步任务调度</dd>
</dl>
]]></content></item><item><title>【01】Flet 学习笔记 --Flutter原理</title><link>https://jekyulll.github.io/posts/frontend-01flet-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---flutter%E5%8E%9F%E7%90%86/</link><pubDate>Tue, 18 Mar 2025 06:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/frontend-01flet-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---flutter%E5%8E%9F%E7%90%86/</guid><description>&lt;p>Flutter为何能摆脱浏览器依赖？&lt;/p>
&lt;hr>
&lt;h3 id="一flutter的三层架构从操作系统到界面渲染">一、Flutter的三层架构：从操作系统到界面渲染&lt;/h3>
&lt;p>&lt;strong>1. 嵌入层（Embedder）&lt;/strong>&lt;br>
嵌入层是Flutter与操作系统对话的&amp;quot;翻译官&amp;quot;，负责将Flutter引擎安装到目标平台。例如在Android上，它通过Java/C++与Activity生命周期交互；在iOS上则通过Objective-C桥接UIKit事件。这一层的关键任务是创建绘图表面（Surface）并管理线程模型（如UI线程、GPU线程），为上层渲染提供稳定的运行环境。&lt;/p>
&lt;p>&lt;strong>2. 引擎层（Engine）&lt;/strong>&lt;br>
引擎层是Flutter的心脏，由C++编写，包含三大核心模块：&lt;br>
• &lt;strong>Skia图形引擎&lt;/strong>：Google开源的2D绘图库，直接操控GPU进行像素绘制，无需经过系统原生控件&lt;br>
• &lt;strong>Dart运行时&lt;/strong>：支持JIT（开发热重载）与AOT（发布高性能）双模式编译&lt;br>
• &lt;strong>文本渲染引擎&lt;/strong>：独立处理复杂文字排版（如阿拉伯语从右向左排列）&lt;br>
这些组件共同构建了跨平台的绘图能力，例如滑动列表时，Skia会将图层数据直接提交给GPU渲染管线。&lt;/p>
&lt;p>&lt;strong>3. 框架层（Framework）&lt;/strong>&lt;br>
开发者直接接触的Dart语言层，提供声明式UI组件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-dart" data-lang="dart">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 典型Flutter组件树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Scaffold(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appBar: AppBar(title: Text(&lt;span style="color:#e6db74">&amp;#39;Demo&amp;#39;&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body: ListView.builder(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> itemBuilder: (context, index) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> ListTile(title: Text(&lt;span style="color:#e6db74">&amp;#39;Item &lt;/span>&lt;span style="color:#e6db74">$&lt;/span>index&lt;span style="color:#e6db74">&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>框架层将Widget转化为渲染指令，通过深度优先遍历完成布局计算，最终生成供Skia处理的图层数据。&lt;/p>
&lt;hr>
&lt;h3 id="二自渲染机制">二、自渲染机制&lt;/h3>
&lt;p>传统跨平台方案如React Native需要将JavaScript控件映射为原生组件。Flutter不同：&lt;/p>
&lt;p>&lt;strong>1. 像素级控制&lt;/strong>&lt;br>
通过Skia直接向GPU提交绘图指令，绕过了浏览器渲染流程中的HTML解析、CSS计算、合成层处理等环节。例如在实现渐变色动画时，Flutter引擎直接操作着色器，而Web方案需要处理复杂的CSS动画性能优化。&lt;/p>
&lt;p>&lt;strong>2. 线程模型优化&lt;/strong>&lt;br>
• &lt;strong>UI线程&lt;/strong>：执行Dart代码，构建图层树&lt;br>
• &lt;strong>GPU线程&lt;/strong>：调用Skia生成GL指令&lt;br>
• &lt;strong>IO线程&lt;/strong>：异步加载资源&lt;br>
三线程通过VSync信号同步，确保60FPS流畅渲染。相比之下，浏览器受限于单线程JavaScript和样式重计算，容易出现卡顿。&lt;/p>
&lt;p>&lt;strong>3. 跨平台一致性保障&lt;/strong>&lt;br>
自研渲染引擎避免了不同平台WebView的差异问题。例如在实现Material Design的波纹效果时，Android和iOS会呈现完全相同的动画细节，而传统方案需要分别适配各平台原生控件。&lt;/p>
&lt;hr>
&lt;h3 id="三与浏览器方案的对比">三、与浏览器方案的对比&lt;/h3>
&lt;p>通过实际场景对比传统Web技术与Flutter的差异：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>场景&lt;/th>
&lt;th>浏览器方案&lt;/th>
&lt;th>Flutter方案&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>列表滚动&lt;/td>
&lt;td>依赖DOM更新，易卡顿&lt;/td>
&lt;td>图层复用，GPU直接合成&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>交互动画&lt;/td>
&lt;td>CSS过渡可能丢帧&lt;/td>
&lt;td>基于物理的动画曲线&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>首屏加载&lt;/td>
&lt;td>需下载完整HTML/CSS/JS&lt;/td>
&lt;td>预编译Dart代码快速启动&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>内存占用&lt;/td>
&lt;td>WebView常驻内存较高&lt;/td>
&lt;td>原生线程管理更高效&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以电商商品列表为例，Flutter可稳定保持120FPS滚动帧率，而基于Web的方案在快速滑动时容易出现白屏。&lt;/p></description><content type="html"><![CDATA[<p>Flutter为何能摆脱浏览器依赖？</p>
<hr>
<h3 id="一flutter的三层架构从操作系统到界面渲染">一、Flutter的三层架构：从操作系统到界面渲染</h3>
<p><strong>1. 嵌入层（Embedder）</strong><br>
嵌入层是Flutter与操作系统对话的&quot;翻译官&quot;，负责将Flutter引擎安装到目标平台。例如在Android上，它通过Java/C++与Activity生命周期交互；在iOS上则通过Objective-C桥接UIKit事件。这一层的关键任务是创建绘图表面（Surface）并管理线程模型（如UI线程、GPU线程），为上层渲染提供稳定的运行环境。</p>
<p><strong>2. 引擎层（Engine）</strong><br>
引擎层是Flutter的心脏，由C++编写，包含三大核心模块：<br>
• <strong>Skia图形引擎</strong>：Google开源的2D绘图库，直接操控GPU进行像素绘制，无需经过系统原生控件<br>
• <strong>Dart运行时</strong>：支持JIT（开发热重载）与AOT（发布高性能）双模式编译<br>
• <strong>文本渲染引擎</strong>：独立处理复杂文字排版（如阿拉伯语从右向左排列）<br>
这些组件共同构建了跨平台的绘图能力，例如滑动列表时，Skia会将图层数据直接提交给GPU渲染管线。</p>
<p><strong>3. 框架层（Framework）</strong><br>
开发者直接接触的Dart语言层，提供声明式UI组件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#75715e">// 典型Flutter组件树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Scaffold(
</span></span><span style="display:flex;"><span>  appBar: AppBar(title: Text(<span style="color:#e6db74">&#39;Demo&#39;</span>)),
</span></span><span style="display:flex;"><span>  body: ListView.builder(
</span></span><span style="display:flex;"><span>    itemBuilder: (context, index) <span style="color:#f92672">=&gt;</span> ListTile(title: Text(<span style="color:#e6db74">&#39;Item </span><span style="color:#e6db74">$</span>index<span style="color:#e6db74">&#39;</span>))
</span></span><span style="display:flex;"><span>  )
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>框架层将Widget转化为渲染指令，通过深度优先遍历完成布局计算，最终生成供Skia处理的图层数据。</p>
<hr>
<h3 id="二自渲染机制">二、自渲染机制</h3>
<p>传统跨平台方案如React Native需要将JavaScript控件映射为原生组件。Flutter不同：</p>
<p><strong>1. 像素级控制</strong><br>
通过Skia直接向GPU提交绘图指令，绕过了浏览器渲染流程中的HTML解析、CSS计算、合成层处理等环节。例如在实现渐变色动画时，Flutter引擎直接操作着色器，而Web方案需要处理复杂的CSS动画性能优化。</p>
<p><strong>2. 线程模型优化</strong><br>
• <strong>UI线程</strong>：执行Dart代码，构建图层树<br>
• <strong>GPU线程</strong>：调用Skia生成GL指令<br>
• <strong>IO线程</strong>：异步加载资源<br>
三线程通过VSync信号同步，确保60FPS流畅渲染。相比之下，浏览器受限于单线程JavaScript和样式重计算，容易出现卡顿。</p>
<p><strong>3. 跨平台一致性保障</strong><br>
自研渲染引擎避免了不同平台WebView的差异问题。例如在实现Material Design的波纹效果时，Android和iOS会呈现完全相同的动画细节，而传统方案需要分别适配各平台原生控件。</p>
<hr>
<h3 id="三与浏览器方案的对比">三、与浏览器方案的对比</h3>
<p>通过实际场景对比传统Web技术与Flutter的差异：</p>
<table>
  <thead>
      <tr>
          <th>场景</th>
          <th>浏览器方案</th>
          <th>Flutter方案</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>列表滚动</td>
          <td>依赖DOM更新，易卡顿</td>
          <td>图层复用，GPU直接合成</td>
      </tr>
      <tr>
          <td>交互动画</td>
          <td>CSS过渡可能丢帧</td>
          <td>基于物理的动画曲线</td>
      </tr>
      <tr>
          <td>首屏加载</td>
          <td>需下载完整HTML/CSS/JS</td>
          <td>预编译Dart代码快速启动</td>
      </tr>
      <tr>
          <td>内存占用</td>
          <td>WebView常驻内存较高</td>
          <td>原生线程管理更高效</td>
      </tr>
  </tbody>
</table>
<p>以电商商品列表为例，Flutter可稳定保持120FPS滚动帧率，而基于Web的方案在快速滑动时容易出现白屏。</p>
<hr>
<h3 id="四flutter的生态演进">四、Flutter的生态演进</h3>
<p>早期Flutter聚焦移动端。后续发展：</p>
<p>• <strong>桌面端</strong>：通过嵌入层适配Windows/macOS的窗口系统<br>
• <strong>Web支持</strong>：Dart编译为JavaScript，Skia通过Canvas实现绘制<br>
• <strong>嵌入式</strong>：在Raspberry Pi等设备运行，验证轻量化潜力<br>
这印证了分层架构的前瞻性——只需扩展嵌入层，即可支持新平台。</p>
]]></content></item><item><title>如何限制C++对象只能在堆或栈上创建？heap only 和 stack only</title><link>https://jekyulll.github.io/posts/cpp-heap-only-%E5%92%8C-stack-only-%E7%9A%84-c++-%E5%AF%B9%E8%B1%A1/</link><pubDate>Sun, 16 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-heap-only-%E5%92%8C-stack-only-%E7%9A%84-c++-%E5%AF%B9%E8%B1%A1/</guid><description>&lt;h2 id="为什么需要限制对象的创建位置">为什么需要限制对象的创建位置？&lt;/h2>
&lt;p>例如一个需要&lt;strong>手动控制生命周期&lt;/strong>的数据库连接池，不希望随便在栈上创建一个然后自动销毁。又或者写了一个轻量级的临时计算工具类，如果每次都在堆上创建，性能反而会下降。&lt;/p>
&lt;p>• ✅ 明确生命周期管理
• ✅ 避免资源泄漏
• ✅ 提升关键路径性能
• ✅ 强制使用最佳实践&lt;/p>
&lt;hr>
&lt;h2 id="一heap-only必须用new创建">一、Heap Only：必须用new创建&lt;/h2>
&lt;h4 id="方法1私有化析构函数">方法1：私有化析构函数&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HeapOnly&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> HeapOnly&lt;span style="color:#f92672">*&lt;/span> Create() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">HeapOnly&lt;/span>(); &lt;span style="color:#75715e">// 工厂方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Suicide&lt;/span>() { &lt;span style="color:#66d9ef">delete&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>; } &lt;span style="color:#75715e">// 起个中二的名字提醒要手动释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>HeapOnly() {} &lt;span style="color:#75715e">// 关键！栈对象无法自动调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HeapOnly() {} &lt;span style="color:#75715e">// 私有构造
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>原理&lt;/strong>：栈对象在离开作用域时会自动调用析构函数，如果析构是私有的，编译器直接报错。必须通过&lt;code>new&lt;/code>创建，手动调用释放。&lt;/p>
&lt;h4 id="方法2c11用-delete">方法2：C++11，用&lt;code>= delete&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HeapOnly&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> HeapOnly&lt;span style="color:#f92672">*&lt;/span> Create() { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HeapOnly; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 直接禁用拷贝构造和赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HeapOnly(&lt;span style="color:#66d9ef">const&lt;/span> HeapOnly&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HeapOnly&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> HeapOnly&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HeapOnly() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="应用场景">应用场景&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>单例模式&lt;/strong>（比如全局配置管理器）&lt;/li>
&lt;li>&lt;strong>需要多态的对象&lt;/strong>（比如动物基类派生出猫狗子类）&lt;/li>
&lt;li>&lt;strong>重量级资源&lt;/strong>（比如线程池、网络连接池）&lt;/li>
&lt;li>&lt;strong>延迟初始化&lt;/strong>的对象（按需创建）&lt;/li>
&lt;/ol>
&lt;p>eg. 游戏引擎中的资源管理器，所有贴图、模型都通过&lt;code>ResourceManager::LoadTexture()&lt;/code>这类工厂方法创建，确保统一管理。&lt;/p></description><content type="html"><![CDATA[<h2 id="为什么需要限制对象的创建位置">为什么需要限制对象的创建位置？</h2>
<p>例如一个需要<strong>手动控制生命周期</strong>的数据库连接池，不希望随便在栈上创建一个然后自动销毁。又或者写了一个轻量级的临时计算工具类，如果每次都在堆上创建，性能反而会下降。</p>
<p>• ✅ 明确生命周期管理
• ✅ 避免资源泄漏
• ✅ 提升关键路径性能
• ✅ 强制使用最佳实践</p>
<hr>
<h2 id="一heap-only必须用new创建">一、Heap Only：必须用new创建</h2>
<h4 id="方法1私有化析构函数">方法1：私有化析构函数</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HeapOnly</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> HeapOnly<span style="color:#f92672">*</span> Create() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">HeapOnly</span>(); <span style="color:#75715e">// 工厂方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Suicide</span>() { <span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">this</span>; } <span style="color:#75715e">// 起个中二的名字提醒要手动释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>HeapOnly() {} <span style="color:#75715e">// 关键！栈对象无法自动调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HeapOnly() {}  <span style="color:#75715e">// 私有构造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p><strong>原理</strong>：栈对象在离开作用域时会自动调用析构函数，如果析构是私有的，编译器直接报错。必须通过<code>new</code>创建，手动调用释放。</p>
<h4 id="方法2c11用-delete">方法2：C++11，用<code>= delete</code></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HeapOnly</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> HeapOnly<span style="color:#f92672">*</span> Create() { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> HeapOnly; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 直接禁用拷贝构造和赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HeapOnly(<span style="color:#66d9ef">const</span> HeapOnly<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>    HeapOnly<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> HeapOnly<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    HeapOnly() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="应用场景">应用场景</h3>
<ol>
<li><strong>单例模式</strong>（比如全局配置管理器）</li>
<li><strong>需要多态的对象</strong>（比如动物基类派生出猫狗子类）</li>
<li><strong>重量级资源</strong>（比如线程池、网络连接池）</li>
<li><strong>延迟初始化</strong>的对象（按需创建）</li>
</ol>
<p>eg. 游戏引擎中的资源管理器，所有贴图、模型都通过<code>ResourceManager::LoadTexture()</code>这类工厂方法创建，确保统一管理。</p>
<hr>
<h2 id="二stack-only禁止new出来的对象">二、Stack Only：禁止<code>new</code>出来的对象</h2>
<h4 id="方法1删除new运算符">方法1：删除new运算符</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StackOnly</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> StackOnly Create() { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">StackOnly</span>(); }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重点在这两行！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    StackOnly() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>效果</strong>：<code>new StackOnly()</code>，编译器直接报错：&ldquo;尝试引用已删除的函数&rdquo;。</p>
<h4 id="方法2raii">方法2：RAII</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FileHandler</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    FileHandler(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> path) { 
</span></span><span style="display:flex;"><span>        file <span style="color:#f92672">=</span> fopen(path, <span style="color:#e6db74">&#34;r&#34;</span>); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>FileHandler() { 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(file) fclose(file); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 禁用堆分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    FILE<span style="color:#f92672">*</span> file;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>实际意义</strong>：用的时候直接在栈上创建，离开作用域自动关闭文件。</p>
<h3 id="应用场景-1">应用场景</h3>
<ol>
<li><strong>RAII资源管理</strong>（锁、文件句柄、智能指针）</li>
<li><strong>轻量临时对象</strong>（比如3D向量、矩阵运算）</li>
<li><strong>高频创建销毁的小对象</strong>（比如游戏中的粒子效果）</li>
<li><strong>保证线程安全的对象</strong>（栈对象不会跨线程共享）</li>
</ol>
<p>eg. 多线程中的<code>std::lock_guard</code>，必须直接在栈上创建才能确保锁的自动释放，防止死锁。</p>
<hr>
<h2 id="三使用场景">三、使用场景</h2>
<table>
  <thead>
      <tr>
          <th><strong>考虑因素</strong></th>
          <th><strong>选堆对象</strong></th>
          <th><strong>选栈对象</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>生命周期</td>
          <td>需要长期存在或跨作用域</td>
          <td>随用随毁，自动清理</td>
      </tr>
      <tr>
          <td>对象大小</td>
          <td>大型对象（比如超过1MB）</td>
          <td>小型对象（建议不超过几十KB）</td>
      </tr>
      <tr>
          <td>性能要求</td>
          <td>对内存分配速度不敏感</td>
          <td>高频创建/销毁时性能敏感</td>
      </tr>
      <tr>
          <td>多态需求</td>
          <td>需要基类指针操作不同子类</td>
          <td>通常不需要</td>
      </tr>
      <tr>
          <td>资源安全</td>
          <td>需要手动管理</td>
          <td>依赖RAII自动管理</td>
      </tr>
  </tbody>
</table>
<p>不确定该用哪个时，优先考虑栈对象（更安全）。</p>
]]></content></item><item><title>解析LRU与LFU算法及C++实现</title><link>https://jekyulll.github.io/posts/web-%E8%A7%A3%E6%9E%90lru%E4%B8%8Elfu%E7%AE%97%E6%B3%95%E5%8F%8Ac++%E5%AE%9E%E7%8E%B0/</link><pubDate>Sun, 16 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-%E8%A7%A3%E6%9E%90lru%E4%B8%8Elfu%E7%AE%97%E6%B3%95%E5%8F%8Ac++%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>在计算机系统中，缓存是提升性能的核心技术之一。当内存资源有限时，如何高效淘汰无用数据、保留热点数据？**LRU（最近最少使用）&lt;strong>和&lt;/strong>LFU（最不频繁使用）**算法为此提供了经典解决方案。本文将从原理到实践，详解这两种算法，并附完整C++实现代码。&lt;/p>
&lt;ul>
&lt;li>​LRU（Least Recently Used）​
&lt;ul>
&lt;li>基于时间维度，淘汰最久未被访问的数据。例如，若缓存容量为3，依次访问A→B→C→A，则再次插入新数据时，最久未访问的B会被淘汰。其核心假设是：最近被访问的数据未来更可能被使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>​LFU（Least Frequently Used）​
&lt;ul>
&lt;li>基于频率维度，淘汰访问次数最少的数据。例如，若数据A被访问5次，B被访问3次，则优先淘汰B。LFU通过计数器记录访问频次，并可能结合时间衰减机制避免旧高频数据长期占用缓存。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一lru算法时间维度淘汰策略">&lt;strong>一、LRU算法：时间维度淘汰策略&lt;/strong>&lt;/h3>
&lt;h4 id="核心原理">&lt;strong>核心原理&lt;/strong>&lt;/h4>
&lt;p>LRU基于“时间局部性”假设：&lt;strong>最近被访问的数据更可能被再次使用&lt;/strong>。其淘汰策略简单直接——移除最久未访问的数据。例如，若缓存容量为3，访问顺序为A→B→C→A，则新数据插入时淘汰最旧的B。&lt;/p>
&lt;h4 id="c实现">&lt;strong>C++实现&lt;/strong>&lt;/h4>
&lt;p>LRU需高效支持两种操作：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>快速查询&lt;/strong>（哈希表，O(1)）&lt;/li>
&lt;li>&lt;strong>顺序维护&lt;/strong>（双向链表，O(1)调整顺序）&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>数据结构设计&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> key, value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node &lt;span style="color:#f92672">*&lt;/span>prev, &lt;span style="color:#f92672">*&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node(&lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> v) &lt;span style="color:#f92672">:&lt;/span> key(k), value(v), prev(&lt;span style="color:#66d9ef">nullptr&lt;/span>), next(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LRUCache&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> capacity;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, Node&lt;span style="color:#f92672">*&amp;gt;&lt;/span> cache; &lt;span style="color:#75715e">// 哈希表：键到节点映射
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Node &lt;span style="color:#f92672">*&lt;/span>head, &lt;span style="color:#f92672">*&lt;/span>tail; &lt;span style="color:#75715e">// 双向链表头尾哨兵节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">moveToHead&lt;/span>(Node&lt;span style="color:#f92672">*&lt;/span> node) { &lt;span style="color:#75715e">// 将节点移至头部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> removeNode(node);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addToHead(node);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">removeNode&lt;/span>(Node&lt;span style="color:#f92672">*&lt;/span> node) { &lt;span style="color:#75715e">// 移除节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addToHead&lt;/span>(Node&lt;span style="color:#f92672">*&lt;/span> node) { &lt;span style="color:#75715e">// 头部插入节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev &lt;span style="color:#f92672">=&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LRUCache(&lt;span style="color:#66d9ef">int&lt;/span> cap) &lt;span style="color:#f92672">:&lt;/span> capacity(cap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>); &lt;span style="color:#75715e">// 初始化哨兵节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> tail &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> tail;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> key) { &lt;span style="color:#75715e">// 查询操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> cache.find(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (it &lt;span style="color:#f92672">==&lt;/span> cache.end()) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> moveToHead(it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>second); &lt;span style="color:#75715e">// 更新为最近访问
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>second&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> key, &lt;span style="color:#66d9ef">int&lt;/span> value) { &lt;span style="color:#75715e">// 插入/更新操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (cache.find(key) &lt;span style="color:#f92672">!=&lt;/span> cache.end()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache[key]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> moveToHead(cache[key]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#f92672">*&lt;/span> newNode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node(key, value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache[key] &lt;span style="color:#f92672">=&lt;/span> newNode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addToHead(newNode);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cache.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> capacity) { &lt;span style="color:#75715e">// 触发淘汰
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Node&lt;span style="color:#f92672">*&lt;/span> toDelete &lt;span style="color:#f92672">=&lt;/span> tail&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache.erase(toDelete&lt;span style="color:#f92672">-&amp;gt;&lt;/span>key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> removeNode(toDelete);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> toDelete;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>关键点&lt;/strong>：&lt;br>
• 使用&lt;strong>哈希表+双向链表&lt;/strong>实现O(1)操作复杂度&lt;br>
• 头节点存放最新访问数据，尾节点为待淘汰数据&lt;/p></description><content type="html"><![CDATA[<p>在计算机系统中，缓存是提升性能的核心技术之一。当内存资源有限时，如何高效淘汰无用数据、保留热点数据？**LRU（最近最少使用）<strong>和</strong>LFU（最不频繁使用）**算法为此提供了经典解决方案。本文将从原理到实践，详解这两种算法，并附完整C++实现代码。</p>
<ul>
<li>​LRU（Least Recently Used）​
<ul>
<li>基于时间维度，淘汰最久未被访问的数据。例如，若缓存容量为3，依次访问A→B→C→A，则再次插入新数据时，最久未访问的B会被淘汰。其核心假设是：最近被访问的数据未来更可能被使用。</li>
</ul>
</li>
<li>​LFU（Least Frequently Used）​
<ul>
<li>基于频率维度，淘汰访问次数最少的数据。例如，若数据A被访问5次，B被访问3次，则优先淘汰B。LFU通过计数器记录访问频次，并可能结合时间衰减机制避免旧高频数据长期占用缓存。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="一lru算法时间维度淘汰策略"><strong>一、LRU算法：时间维度淘汰策略</strong></h3>
<h4 id="核心原理"><strong>核心原理</strong></h4>
<p>LRU基于“时间局部性”假设：<strong>最近被访问的数据更可能被再次使用</strong>。其淘汰策略简单直接——移除最久未访问的数据。例如，若缓存容量为3，访问顺序为A→B→C→A，则新数据插入时淘汰最旧的B。</p>
<h4 id="c实现"><strong>C++实现</strong></h4>
<p>LRU需高效支持两种操作：</p>
<ol>
<li><strong>快速查询</strong>（哈希表，O(1)）</li>
<li><strong>顺序维护</strong>（双向链表，O(1)调整顺序）</li>
</ol>
<p><strong>数据结构设计</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> key, value;
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>prev, <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>    Node(<span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> v) <span style="color:#f92672">:</span> key(k), value(v), prev(<span style="color:#66d9ef">nullptr</span>), next(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LRUCache</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> capacity;
</span></span><span style="display:flex;"><span>    unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, Node<span style="color:#f92672">*&gt;</span> cache;  <span style="color:#75715e">// 哈希表：键到节点映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>head, <span style="color:#f92672">*</span>tail;                <span style="color:#75715e">// 双向链表头尾哨兵节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">moveToHead</span>(Node<span style="color:#f92672">*</span> node) {     <span style="color:#75715e">// 将节点移至头部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        removeNode(node);
</span></span><span style="display:flex;"><span>        addToHead(node);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeNode</span>(Node<span style="color:#f92672">*</span> node) {     <span style="color:#75715e">// 移除节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        node<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addToHead</span>(Node<span style="color:#f92672">*</span> node) {     <span style="color:#75715e">// 头部插入节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        head<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    LRUCache(<span style="color:#66d9ef">int</span> cap) <span style="color:#f92672">:</span> capacity(cap) {
</span></span><span style="display:flex;"><span>        head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);      <span style="color:#75715e">// 初始化哨兵节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        tail <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> tail;
</span></span><span style="display:flex;"><span>        tail<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">int</span> key) {               <span style="color:#75715e">// 查询操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> cache.find(key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> cache.end()) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        moveToHead(it<span style="color:#f92672">-&gt;</span>second);       <span style="color:#75715e">// 更新为最近访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> it<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span>(<span style="color:#66d9ef">int</span> key, <span style="color:#66d9ef">int</span> value) {   <span style="color:#75715e">// 插入/更新操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (cache.find(key) <span style="color:#f92672">!=</span> cache.end()) {
</span></span><span style="display:flex;"><span>            cache[key]<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>            moveToHead(cache[key]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Node<span style="color:#f92672">*</span> newNode <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(key, value);
</span></span><span style="display:flex;"><span>        cache[key] <span style="color:#f92672">=</span> newNode;
</span></span><span style="display:flex;"><span>        addToHead(newNode);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cache.size() <span style="color:#f92672">&gt;</span> capacity) {  <span style="color:#75715e">// 触发淘汰
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Node<span style="color:#f92672">*</span> toDelete <span style="color:#f92672">=</span> tail<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>            cache.erase(toDelete<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>            removeNode(toDelete);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> toDelete;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>关键点</strong>：<br>
• 使用<strong>哈希表+双向链表</strong>实现O(1)操作复杂度<br>
• 头节点存放最新访问数据，尾节点为待淘汰数据</p>
<hr>
<h3 id="二lfu算法频率维度淘汰策略"><strong>二、LFU算法：频率维度淘汰策略</strong></h3>
<h4 id="核心原理-1"><strong>核心原理</strong></h4>
<p>LFU基于“频率优先”原则：<strong>淘汰访问次数最少的数据</strong>。例如，数据A访问5次、B访问3次，则优先淘汰B。LFU需记录每个键的访问频率，并维护最小频率值。</p>
<h4 id="c实现-1"><strong>C++实现</strong></h4>
<p>LFU需维护三个核心结构：</p>
<ol>
<li><strong>键到值和频率的映射</strong></li>
<li><strong>频率到键集合的映射</strong></li>
<li><strong>当前最小频率值</strong></li>
</ol>
<p><strong>数据结构设计</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LFUCache</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> capacity, minFreq;
</span></span><span style="display:flex;"><span>    unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> keyMap;       <span style="color:#75715e">// key→{value, freq}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> freqMap;          <span style="color:#75715e">// freq→keys list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator<span style="color:#f92672">&gt;</span> keyIter;<span style="color:#75715e">// key在freqMap中的迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increaseFreq</span>(<span style="color:#66d9ef">int</span> key) {     <span style="color:#75715e">// 增加键的频率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> oldFreq <span style="color:#f92672">=</span> keyMap[key].second;
</span></span><span style="display:flex;"><span>        keyMap[key].second<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        freqMap[oldFreq].erase(keyIter[key]);        <span style="color:#75715e">// 从旧频率列表移除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (freqMap[oldFreq].empty()) {              <span style="color:#75715e">// 更新最小频率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            freqMap.erase(oldFreq);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (oldFreq <span style="color:#f92672">==</span> minFreq) minFreq<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        freqMap[oldFreq <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].push_front(key);        <span style="color:#75715e">// 加入新频率列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        keyIter[key] <span style="color:#f92672">=</span> freqMap[req <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].begin();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    LFUCache(<span style="color:#66d9ef">int</span> cap) <span style="color:#f92672">:</span> capacity(cap), minFreq(<span style="color:#ae81ff">0</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (keyMap.find(key) <span style="color:#f92672">==</span> keyMap.end()) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        increaseFreq(key);           <span style="color:#75715e">// 更新频率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> keyMap[key].first;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span>(<span style="color:#66d9ef">int</span> key, <span style="color:#66d9ef">int</span> value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (capacity <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (keyMap.find(key) <span style="color:#f92672">!=</span> keyMap.end()) {  <span style="color:#75715e">// 已存在则更新值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            keyMap[key].first <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>            increaseFreq(key);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (keyMap.size() <span style="color:#f92672">&gt;=</span> capacity) {         <span style="color:#75715e">// 触发淘汰
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> evictKey <span style="color:#f92672">=</span> freqMap[minFreq].back();
</span></span><span style="display:flex;"><span>            freqMap[minFreq].pop_back();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (freqMap[minFreq].empty()) 
</span></span><span style="display:flex;"><span>                freqMap.erase(minFreq);
</span></span><span style="display:flex;"><span>            keyMap.erase(evictKey);
</span></span><span style="display:flex;"><span>            keyIter.erase(evictKey);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        keyMap[key] <span style="color:#f92672">=</span> {value, <span style="color:#ae81ff">1</span>};                <span style="color:#75715e">// 插入新键
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        freqMap[<span style="color:#ae81ff">1</span>].push_front(key);
</span></span><span style="display:flex;"><span>        keyIter[key] <span style="color:#f92672">=</span> freqMap[<span style="color:#ae81ff">1</span>].begin();
</span></span><span style="display:flex;"><span>        minFreq <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;                             <span style="color:#75715e">// 最小频率重置为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>关键点</strong>：<br>
• 通过三层映射实现频率统计与快速淘汰<br>
• 维护<code>minFreq</code>避免遍历所有频率值</p>
<hr>
<h3 id="三lru与lfu对比与应用场景"><strong>三、LRU与LFU对比与应用场景</strong></h3>
<table>
  <thead>
      <tr>
          <th><strong>维度</strong></th>
          <th><strong>LRU</strong></th>
          <th><strong>LFU</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>淘汰依据</strong></td>
          <td>访问时间（最久未用）</td>
          <td>访问频率（最少使用）</td>
      </tr>
      <tr>
          <td><strong>优点</strong></td>
          <td>实现简单，适应突发流量</td>
          <td>精准捕捉长期热点数据</td>
      </tr>
      <tr>
          <td><strong>缺点</strong></td>
          <td>周期性访问易误淘汰（如扫描操作）</td>
          <td>新数据易被淘汰（冷启动问题）</td>
      </tr>
      <tr>
          <td><strong>适用场景</strong></td>
          <td>实时榜单、用户会话管理</td>
          <td>热门视频缓存、搜索引擎热词</td>
      </tr>
  </tbody>
</table>
<p><strong>实际案例</strong>：<br>
• <strong>数据库缓存</strong>：MySQL的Buffer Pool使用改进版LRU（冷热数据分离）<br>
• <strong>高并发系统</strong>：Redis采用近似LFU，平衡性能与内存开销</p>
<hr>
<h3 id="四总结与选型建议"><strong>四、总结与选型建议</strong></h3>
<p>• <strong>选择LRU</strong>：若业务存在明显的时间局部性（如新闻热点），或需快速响应访问顺序变化。<br>
• <strong>选择LFU</strong>：若数据访问频次差异大（如电商热门商品），且需长期保留高频数据。</p>
<p><strong>性能优化方向</strong>：<br>
• 分段锁减少并发竞争（如将缓存分16段）<br>
• 添加频率衰减机制（避免旧高频数据长期占用）</p>
<p>建议根据场景调整参数（如缓存容量、锁粒度等）以获得最佳效果。</p>
]]></content></item><item><title>【AI】半衰期算法在后端的应用</title><link>https://jekyulll.github.io/posts/web-%E5%8D%8A%E8%A1%B0%E6%9C%9F%E7%AE%97%E6%B3%95%E5%9C%A8%E5%90%8E%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8/</link><pubDate>Mon, 10 Mar 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-%E5%8D%8A%E8%A1%B0%E6%9C%9F%E7%AE%97%E6%B3%95%E5%9C%A8%E5%90%8E%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8/</guid><description>&lt;p>在后端开发中，半衰期算法常用于动态调整数据权重的场景，其核心是通过时间衰减机制平衡实时性与历史价值。以下是其典型应用及实现逻辑：&lt;/p>
&lt;h3 id="一算法原理与公式">一、算法原理与公式&lt;/h3>
&lt;p>半衰期算法基于放射性衰变公式：&lt;strong>M * (1/2)^(t/T)&lt;/strong>，其中：
• &lt;strong>M&lt;/strong>：初始值（如点击量）
• &lt;strong>t&lt;/strong>：时间间隔（如天数）
• &lt;strong>T&lt;/strong>：半衰期周期（如7天）
该公式使数据权重随时间呈指数衰减，例如7天半衰期意味着权重每天减少约10%。&lt;/p>
&lt;h3 id="二核心应用场景">二、核心应用场景&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>热搜排序&lt;/strong>（如微博、腾讯平台）
• 动态平衡点击量与时间衰减：新事件点击量高但衰减快，旧事件点击量低但衰减慢。例如：
◦ 电影类半衰期设为7天（T=7），初始权重1000，单日点击量20000时，2天后权重为 &lt;code>(1000+20000) * (1/2)^(2/7) * 0.8 ≈ 17474.56&lt;/code>。
◦ 小说类半衰期15天（T=15），汽车类30天（T=30），体现不同内容时效性差异。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>推荐系统冷启动&lt;/strong>
• 新内容通过初始权重（如1000）获得曝光机会，同时随时间自然衰减，避免长期占据推荐位。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>动态排行榜&lt;/strong>
• 结合实时数据与历史表现：例如游戏活动榜单，近期活跃玩家通过半衰期快速提升排名，老玩家贡献逐步降低。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="三后端实现要点">三、后端实现要点&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>数据模型设计&lt;/strong>
• 数据库需存储&lt;strong>原始点击量&lt;/strong>和&lt;strong>计算后的排序权重字段&lt;/strong>（如&lt;code>sort_info&lt;/code>），通过定时任务（如每小时）更新权重值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>参数可配置化&lt;/strong>
• 不同业务类型设置独立参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">filmHalfLife&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span>; &lt;span style="color:#75715e">//半衰期周期
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">weight&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.8&lt;/span>; &lt;span style="color:#75715e">//类型权重
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过接口&lt;code>halfLifeFactory&lt;/code>实现多态，支持扩展新类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>防作弊机制&lt;/strong>
• 引入&lt;strong>类型权重系数&lt;/strong>（如电影0.8、汽车0.85），降低刷量对排序的影响。
• 结合IP频率限制、异常点击检测等补充措施。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="四扩展优化方向">四、扩展优化方向&lt;/h3>
&lt;p>• &lt;strong>时间粒度细化&lt;/strong>：将天级计算改为小时级，适应高实时性场景（如突发新闻）。
• &lt;strong>复合衰减策略&lt;/strong>：叠加多个半衰期公式，处理复杂业务逻辑（如短视频热度需同时考虑播放、点赞、分享）。
• &lt;strong>动态调整半衰期&lt;/strong>：通过机器学习根据历史数据自动优化T值。&lt;/p>
&lt;blockquote>
&lt;p>该算法已在实际工程中验证可行性，例如某博客示例中，电影类内容在7天内权重从1000衰减至约400，而汽车类内容30天后仍保留约300权重。开发者可根据业务需求调整公式参数，平衡时效性与长尾效应。&lt;/p>
&lt;/blockquote></description><content type="html"><![CDATA[<p>在后端开发中，半衰期算法常用于动态调整数据权重的场景，其核心是通过时间衰减机制平衡实时性与历史价值。以下是其典型应用及实现逻辑：</p>
<h3 id="一算法原理与公式">一、算法原理与公式</h3>
<p>半衰期算法基于放射性衰变公式：<strong>M * (1/2)^(t/T)</strong>，其中：
• <strong>M</strong>：初始值（如点击量）
• <strong>t</strong>：时间间隔（如天数）
• <strong>T</strong>：半衰期周期（如7天）
该公式使数据权重随时间呈指数衰减，例如7天半衰期意味着权重每天减少约10%。</p>
<h3 id="二核心应用场景">二、核心应用场景</h3>
<ol>
<li>
<p><strong>热搜排序</strong>（如微博、腾讯平台）
• 动态平衡点击量与时间衰减：新事件点击量高但衰减快，旧事件点击量低但衰减慢。例如：
◦ 电影类半衰期设为7天（T=7），初始权重1000，单日点击量20000时，2天后权重为 <code>(1000+20000) * (1/2)^(2/7) * 0.8 ≈ 17474.56</code>。
◦ 小说类半衰期15天（T=15），汽车类30天（T=30），体现不同内容时效性差异。</p>
</li>
<li>
<p><strong>推荐系统冷启动</strong>
• 新内容通过初始权重（如1000）获得曝光机会，同时随时间自然衰减，避免长期占据推荐位。</p>
</li>
<li>
<p><strong>动态排行榜</strong>
• 结合实时数据与历史表现：例如游戏活动榜单，近期活跃玩家通过半衰期快速提升排名，老玩家贡献逐步降低。</p>
</li>
</ol>
<h3 id="三后端实现要点">三、后端实现要点</h3>
<ol>
<li>
<p><strong>数据模型设计</strong>
• 数据库需存储<strong>原始点击量</strong>和<strong>计算后的排序权重字段</strong>（如<code>sort_info</code>），通过定时任务（如每小时）更新权重值。</p>
</li>
<li>
<p><strong>参数可配置化</strong>
• 不同业务类型设置独立参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">filmHalfLife</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;  <span style="color:#75715e">//半衰期周期
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">weight</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.8</span>; <span style="color:#75715e">//类型权重
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>通过接口<code>halfLifeFactory</code>实现多态，支持扩展新类型。</p>
</li>
<li>
<p><strong>防作弊机制</strong>
• 引入<strong>类型权重系数</strong>（如电影0.8、汽车0.85），降低刷量对排序的影响。
• 结合IP频率限制、异常点击检测等补充措施。</p>
</li>
</ol>
<h3 id="四扩展优化方向">四、扩展优化方向</h3>
<p>• <strong>时间粒度细化</strong>：将天级计算改为小时级，适应高实时性场景（如突发新闻）。
• <strong>复合衰减策略</strong>：叠加多个半衰期公式，处理复杂业务逻辑（如短视频热度需同时考虑播放、点赞、分享）。
• <strong>动态调整半衰期</strong>：通过机器学习根据历史数据自动优化T值。</p>
<blockquote>
<p>该算法已在实际工程中验证可行性，例如某博客示例中，电影类内容在7天内权重从1000衰减至约400，而汽车类内容30天后仍保留约300权重。开发者可根据业务需求调整公式参数，平衡时效性与长尾效应。</p>
</blockquote>
]]></content></item><item><title>【AI】C++八股：main函数之前执行了什么？</title><link>https://jekyulll.github.io/posts/cpp-c++%E5%85%AB%E8%82%A1main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BA%86%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 10 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++%E5%85%AB%E8%82%A1main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BA%86%E4%BB%80%E4%B9%88/</guid><description>&lt;h3 id="一_start与__libc_start_call_main的作用">一、&lt;code>_start&lt;/code>与&lt;code>__libc_start_call_main&lt;/code>的作用&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;code>_start&lt;/code>：程序的入口点&lt;/strong>&lt;br>
&lt;u>&lt;code>_start&lt;/code>是Linux环境下C/C++程序的&lt;strong>实际入口函数&lt;/strong>，由链接器自动添加到可执行文件中，负责初始化运行时环境并调用&lt;code>__libc_start_main&lt;/code>。&lt;/u>&lt;br>
它的核心任务包括：&lt;br>
• 设置栈指针（&lt;code>%ebp&lt;/code>清零）、传递参数（如&lt;code>argc&lt;/code>和&lt;code>argv&lt;/code>）到寄存器。&lt;br>
• 加载全局初始化函数（如&lt;code>__libc_csu_init&lt;/code>）和清理函数（如&lt;code>__libc_csu_fini&lt;/code>）。&lt;br>
• 调用&lt;code>__libc_start_main&lt;/code>，并将&lt;code>main&lt;/code>函数地址作为参数传递。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>__libc_start_call_main&lt;/code>：非托管入口的桥梁&lt;/strong>&lt;br>
该函数位于&lt;code>libc.so&lt;/code>中，是&lt;code>__libc_start_main&lt;/code>内部调用的关键步骤，负责&lt;strong>直接触发非托管&lt;code>main&lt;/code>函数的执行&lt;/strong>（例如C++中的全局构造函数完成后，最终调用用户编写的&lt;code>main&lt;/code>函数）。在Linux下，它与&lt;code>__libc_start_main_impl&lt;/code>共同完成用户态到程序主逻辑的过渡。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二c程序在main函数前的执行流程">二、C++程序在&lt;code>main&lt;/code>函数前的执行流程&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>操作系统加载与内存分配&lt;/strong>&lt;br>
• 可执行文件被加载到内存，操作系统分配栈、堆空间，并初始化&lt;code>.data&lt;/code>（已初始化全局变量）和&lt;code>.bss&lt;/code>（未初始化全局变量）段。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>全局变量与静态对象的初始化&lt;/strong>&lt;br>
• &lt;strong>&lt;code>.data&lt;/code>段变量&lt;/strong>：直接赋初值（如&lt;code>float global_float = 3.14&lt;/code>）。&lt;br>
• &lt;strong>&lt;code>.bss&lt;/code>段变量&lt;/strong>：数值类型初始化为0，指针初始化为&lt;code>NULL&lt;/code>。&lt;br>
• &lt;strong>全局对象构造函数&lt;/strong>：在&lt;code>main&lt;/code>前按定义顺序调用（例如&lt;code>AnotherClass another_global_object&lt;/code>的构造函数）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>运行时库的初始化&lt;/strong>&lt;br>
• C++运行时库（如&lt;code>libstdc++&lt;/code>）执行初始化，包括堆管理、异常处理框架等。&lt;br>
• 静态成员变量的初始化（如&lt;code>AnotherClass::static_double = 2.718&lt;/code>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>参数传递与入口跳转&lt;/strong>&lt;br>
• &lt;code>_start&lt;/code>通过&lt;code>__libc_start_main&lt;/code>将&lt;code>argc&lt;/code>、&lt;code>argv&lt;/code>和&lt;code>envp&lt;/code>传递给&lt;code>main&lt;/code>函数，最终通过&lt;code>__libc_start_call_main&lt;/code>触发&lt;code>main&lt;/code>的执行。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="三关键差异与注意事项">三、关键差异与注意事项&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>与Windows的对比&lt;/strong>&lt;br>
• &lt;strong>Linux&lt;/strong>：入口链为&lt;code>_start → __libc_start_main → __libc_start_call_main → main&lt;/code>。&lt;br>
• &lt;strong>Windows&lt;/strong>：入口函数为&lt;code>RtlUserThreadStart&lt;/code>（&lt;code>ntdll.dll&lt;/code>），非托管入口通过&lt;code>BaseThreadInitThunk&lt;/code>（&lt;code>kernel32.dll&lt;/code>）调用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>初始化顺序的潜在问题&lt;/strong>&lt;br>
若全局对象之间存在依赖（如A依赖B），需通过&lt;strong>编译单元顺序控制&lt;/strong>或&lt;code>__attribute__((init_priority))&lt;/code>（GCC扩展）强制指定初始化顺序，避免未定义行为。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>C++程序的启动过程远不止&lt;code>main&lt;/code>函数的执行，其核心在于操作系统和运行时库的协作初始化。理解&lt;code>_start&lt;/code>与&lt;code>__libc_start_call_main&lt;/code>的作用，以及全局对象的构造顺序，对于调试启动崩溃、优化资源初始化至关重要。例如，若程序在&lt;code>main&lt;/code>前崩溃，需优先排查全局对象的构造函数或静态变量初始化逻辑。&lt;/p></description><content type="html"><![CDATA[<h3 id="一_start与__libc_start_call_main的作用">一、<code>_start</code>与<code>__libc_start_call_main</code>的作用</h3>
<ol>
<li>
<p><strong><code>_start</code>：程序的入口点</strong><br>
<u><code>_start</code>是Linux环境下C/C++程序的<strong>实际入口函数</strong>，由链接器自动添加到可执行文件中，负责初始化运行时环境并调用<code>__libc_start_main</code>。</u><br>
它的核心任务包括：<br>
• 设置栈指针（<code>%ebp</code>清零）、传递参数（如<code>argc</code>和<code>argv</code>）到寄存器。<br>
• 加载全局初始化函数（如<code>__libc_csu_init</code>）和清理函数（如<code>__libc_csu_fini</code>）。<br>
• 调用<code>__libc_start_main</code>，并将<code>main</code>函数地址作为参数传递。</p>
</li>
<li>
<p><strong><code>__libc_start_call_main</code>：非托管入口的桥梁</strong><br>
该函数位于<code>libc.so</code>中，是<code>__libc_start_main</code>内部调用的关键步骤，负责<strong>直接触发非托管<code>main</code>函数的执行</strong>（例如C++中的全局构造函数完成后，最终调用用户编写的<code>main</code>函数）。在Linux下，它与<code>__libc_start_main_impl</code>共同完成用户态到程序主逻辑的过渡。</p>
</li>
</ol>
<hr>
<h3 id="二c程序在main函数前的执行流程">二、C++程序在<code>main</code>函数前的执行流程</h3>
<ol>
<li>
<p><strong>操作系统加载与内存分配</strong><br>
• 可执行文件被加载到内存，操作系统分配栈、堆空间，并初始化<code>.data</code>（已初始化全局变量）和<code>.bss</code>（未初始化全局变量）段。</p>
</li>
<li>
<p><strong>全局变量与静态对象的初始化</strong><br>
• <strong><code>.data</code>段变量</strong>：直接赋初值（如<code>float global_float = 3.14</code>）。<br>
• <strong><code>.bss</code>段变量</strong>：数值类型初始化为0，指针初始化为<code>NULL</code>。<br>
• <strong>全局对象构造函数</strong>：在<code>main</code>前按定义顺序调用（例如<code>AnotherClass another_global_object</code>的构造函数）。</p>
</li>
<li>
<p><strong>运行时库的初始化</strong><br>
• C++运行时库（如<code>libstdc++</code>）执行初始化，包括堆管理、异常处理框架等。<br>
• 静态成员变量的初始化（如<code>AnotherClass::static_double = 2.718</code>）。</p>
</li>
<li>
<p><strong>参数传递与入口跳转</strong><br>
• <code>_start</code>通过<code>__libc_start_main</code>将<code>argc</code>、<code>argv</code>和<code>envp</code>传递给<code>main</code>函数，最终通过<code>__libc_start_call_main</code>触发<code>main</code>的执行。</p>
</li>
</ol>
<hr>
<h3 id="三关键差异与注意事项">三、关键差异与注意事项</h3>
<ol>
<li>
<p><strong>与Windows的对比</strong><br>
• <strong>Linux</strong>：入口链为<code>_start → __libc_start_main → __libc_start_call_main → main</code>。<br>
• <strong>Windows</strong>：入口函数为<code>RtlUserThreadStart</code>（<code>ntdll.dll</code>），非托管入口通过<code>BaseThreadInitThunk</code>（<code>kernel32.dll</code>）调用。</p>
</li>
<li>
<p><strong>初始化顺序的潜在问题</strong><br>
若全局对象之间存在依赖（如A依赖B），需通过<strong>编译单元顺序控制</strong>或<code>__attribute__((init_priority))</code>（GCC扩展）强制指定初始化顺序，避免未定义行为。</p>
</li>
</ol>
<hr>
<h3 id="总结">总结</h3>
<p>C++程序的启动过程远不止<code>main</code>函数的执行，其核心在于操作系统和运行时库的协作初始化。理解<code>_start</code>与<code>__libc_start_call_main</code>的作用，以及全局对象的构造顺序，对于调试启动崩溃、优化资源初始化至关重要。例如，若程序在<code>main</code>前崩溃，需优先排查全局对象的构造函数或静态变量初始化逻辑。</p>
]]></content></item><item><title>【AI】使用普通的互斥锁实现读写锁</title><link>https://jekyulll.github.io/posts/cpp-%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 10 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>&lt;p>核心在于通过&lt;strong>状态管理&lt;/strong>和&lt;strong>锁的组合&lt;/strong>来模拟读写锁的“读共享、写独占”特性。以下是实现思路和具体方法：&lt;/p>
&lt;hr>
&lt;h3 id="一实现原理">一、实现原理&lt;/h3>
&lt;p>读写锁的核心规则是：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>读读共享&lt;/strong>：允许多个读线程并发访问。&lt;/li>
&lt;li>&lt;strong>读写互斥&lt;/strong>：读线程和写线程不能同时访问。&lt;/li>
&lt;li>&lt;strong>写写互斥&lt;/strong>：同一时间只能有一个写线程访问。&lt;/li>
&lt;/ol>
&lt;p>使用普通互斥锁（&lt;code>std::mutex&lt;/code>）和计数器可以实现这一逻辑：&lt;br>
• &lt;strong>读计数器&lt;/strong>：统计当前活跃的读线程数量。&lt;br>
• &lt;strong>写互斥锁&lt;/strong>：确保写操作的独占性。&lt;br>
• &lt;strong>状态保护锁&lt;/strong>：保护读计数器和写锁状态的原子性。&lt;/p>
&lt;hr>
&lt;h3 id="二实现步骤">二、实现步骤&lt;/h3>
&lt;h4 id="1-定义关键成员变量">1. 定义关键成员变量&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;condition_variable&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ReadWriteLock&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>mutex counter_mutex; &lt;span style="color:#75715e">// 保护读计数器和写标志
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>mutex write_mutex; &lt;span style="color:#75715e">// 写操作的独占锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> reader_count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// 当前活跃的读线程数量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> write_pending &lt;span style="color:#f92672">=&lt;/span> false; &lt;span style="color:#75715e">// 是否有写线程在等待
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>condition_variable read_cv, write_cv;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-读锁的获取与释放">2. 读锁的获取与释放&lt;/h4>
&lt;p>• &lt;strong>获取读锁&lt;/strong>：&lt;br>
当无写线程运行时，允许读线程进入；若存在写线程等待，则阻塞新读线程（避免写饥饿）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">read_lock&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(counter_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 等待直到没有写线程在等待或运行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> read_cv.wait(lock, [&lt;span style="color:#66d9ef">this&lt;/span>] { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>write_pending; });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reader_count&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (reader_count &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write_mutex.lock(); &lt;span style="color:#75715e">// 第一个读线程获取写锁，阻止写操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>• &lt;strong>释放读锁&lt;/strong>：&lt;br>
减少读计数器，若最后一个读线程退出，则释放写锁并通知可能的等待写线程。&lt;/p></description><content type="html"><![CDATA[<p>核心在于通过<strong>状态管理</strong>和<strong>锁的组合</strong>来模拟读写锁的“读共享、写独占”特性。以下是实现思路和具体方法：</p>
<hr>
<h3 id="一实现原理">一、实现原理</h3>
<p>读写锁的核心规则是：</p>
<ol>
<li><strong>读读共享</strong>：允许多个读线程并发访问。</li>
<li><strong>读写互斥</strong>：读线程和写线程不能同时访问。</li>
<li><strong>写写互斥</strong>：同一时间只能有一个写线程访问。</li>
</ol>
<p>使用普通互斥锁（<code>std::mutex</code>）和计数器可以实现这一逻辑：<br>
• <strong>读计数器</strong>：统计当前活跃的读线程数量。<br>
• <strong>写互斥锁</strong>：确保写操作的独占性。<br>
• <strong>状态保护锁</strong>：保护读计数器和写锁状态的原子性。</p>
<hr>
<h3 id="二实现步骤">二、实现步骤</h3>
<h4 id="1-定义关键成员变量">1. 定义关键成员变量</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;condition_variable&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReadWriteLock</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>mutex counter_mutex;    <span style="color:#75715e">// 保护读计数器和写标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>mutex write_mutex;      <span style="color:#75715e">// 写操作的独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> reader_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;        <span style="color:#75715e">// 当前活跃的读线程数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> write_pending <span style="color:#f92672">=</span> false;  <span style="color:#75715e">// 是否有写线程在等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>condition_variable read_cv, write_cv;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="2-读锁的获取与释放">2. 读锁的获取与释放</h4>
<p>• <strong>获取读锁</strong>：<br>
当无写线程运行时，允许读线程进入；若存在写线程等待，则阻塞新读线程（避免写饥饿）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_lock</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(counter_mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 等待直到没有写线程在等待或运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    read_cv.wait(lock, [<span style="color:#66d9ef">this</span>] { <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>write_pending; });
</span></span><span style="display:flex;"><span>    reader_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (reader_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        write_mutex.lock();  <span style="color:#75715e">// 第一个读线程获取写锁，阻止写操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>• <strong>释放读锁</strong>：<br>
减少读计数器，若最后一个读线程退出，则释放写锁并通知可能的等待写线程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_unlock</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(counter_mutex);
</span></span><span style="display:flex;"><span>    reader_count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (reader_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        write_mutex.unlock();
</span></span><span style="display:flex;"><span>        write_cv.notify_one();  <span style="color:#75715e">// 通知等待的写线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3-写锁的获取与释放">3. 写锁的获取与释放</h4>
<p>• <strong>获取写锁</strong>：<br>
设置写等待标志，等待所有读线程退出后获取写锁。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_lock</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(counter_mutex);
</span></span><span style="display:flex;"><span>    write_pending <span style="color:#f92672">=</span> true;        <span style="color:#75715e">// 标记有写线程等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    write_cv.wait(lock, [<span style="color:#66d9ef">this</span>] { <span style="color:#66d9ef">return</span> reader_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }); <span style="color:#75715e">// 等待读线程退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    write_mutex.lock();          <span style="color:#75715e">// 获取写锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>• <strong>释放写锁</strong>：<br>
释放写锁并重置写等待标志，唤醒可能的读或写线程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_unlock</span>() {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(counter_mutex);
</span></span><span style="display:flex;"><span>        write_pending <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    write_mutex.unlock();
</span></span><span style="display:flex;"><span>    read_cv.notify_all();  <span style="color:#75715e">// 唤醒等待的读线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><hr>
<h3 id="三关键点与注意事项">三、关键点与注意事项</h3>
<ol>
<li><strong>避免写线程饥饿</strong>：<br>
通过<code>write_pending</code>标志，确保在有写线程等待时，新读线程会被阻塞。</li>
<li><strong>原子性保护</strong>：<br>
所有对<code>reader_count</code>和<code>write_pending</code>的修改必须通过<code>counter_mutex</code>保护。</li>
<li><strong>条件变量的使用</strong>：<br>
<code>read_cv</code>和<code>write_cv</code>用于协调读/写线程的状态切换，避免忙等待。</li>
<li><strong>锁的粒度</strong>：<br>
写操作通过<code>write_mutex</code>实现独占，读操作通过共享计数器实现并发。</li>
</ol>
<hr>
<h3 id="四潜在问题与优化">四、潜在问题与优化</h3>
<p>• <strong>性能问题</strong>：与标准库的<code>std::shared_mutex</code>相比，此实现可能因频繁锁竞争导致性能下降。<br>
• <strong>死锁风险</strong>：需确保锁的获取顺序一致（如先<code>counter_mutex</code>再<code>write_mutex</code>）。<br>
• <strong>扩展性</strong>：可引入优先级策略（如写优先）来优化公平性。</p>
<hr>
<h3 id="五面试回答示例">五、面试回答示例</h3>
<p>“可以通过两个互斥锁和一个读计数器实现读写锁：</p>
<ol>
<li><strong>写锁</strong>：使用一个互斥锁（<code>write_mutex</code>）保证写操作的独占性。</li>
<li><strong>读计数器</strong>：统计活跃读线程数量，第一个读线程获取写锁，最后一个释放。</li>
<li><strong>状态协调</strong>：通过条件变量和标志位避免写线程饥饿，例如在有写等待时阻塞新读线程。”</li>
</ol>
<p>这一实现体现了对互斥锁组合使用和线程同步机制的理解，适合在面试中展示底层设计能力。</p>
]]></content></item><item><title>【AI】mmap 和零拷贝</title><link>https://jekyulll.github.io/posts/linux-mmap-%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link><pubDate>Fri, 07 Mar 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-mmap-%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid><description>&lt;p>mmap（Memory Mapping）是Unix/Linux系统中的一种重要机制，它允许将文件或设备直接映射到进程的虚拟地址空间，从而将文件操作与内存操作高效结合。以下从核心机制、与IO的关系、与内存分配的关系三个方面详细解析：&lt;/p>
&lt;hr>
&lt;h3 id="一mmap的核心机制">一、mmap的核心机制&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>系统调用与映射方式&lt;/strong>：
• &lt;strong>函数原型&lt;/strong>：&lt;code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);&lt;/code>
• &lt;strong>关键参数&lt;/strong>：
◦ &lt;code>prot&lt;/code>：控制读写权限（如&lt;code>PROT_READ&lt;/code>、&lt;code>PROT_WRITE&lt;/code>）。
◦ &lt;code>flags&lt;/code>：决定映射类型（&lt;code>MAP_SHARED&lt;/code>、&lt;code>MAP_PRIVATE&lt;/code>、&lt;code>MAP_ANONYMOUS&lt;/code>）。
• &lt;strong>两种主要映射&lt;/strong>：
◦ &lt;strong>文件映射&lt;/strong>：将文件映射到内存，修改可同步到文件（&lt;code>MAP_SHARED&lt;/code>）或仅进程可见（&lt;code>MAP_PRIVATE&lt;/code>）。
◦ &lt;strong>匿名映射&lt;/strong>：不关联文件，用于进程间共享内存或动态内存分配（&lt;code>MAP_ANONYMOUS&lt;/code>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>实现原理&lt;/strong>：
• &lt;strong>虚拟内存管理&lt;/strong>：mmap在进程的虚拟地址空间中划分一段区域（通常位于堆与栈之间），通过页表映射到物理内存或文件的页缓存。
• &lt;strong>按需加载（Demand Paging）&lt;/strong>：访问映射内存时触发缺页中断，内核自动将文件数据加载到物理内存，减少一次性加载开销。
• &lt;strong>同步机制&lt;/strong>：修改后的数据由内核异步写回文件，也可通过&lt;code>msync()&lt;/code>强制同步。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二mmap与io的关系">二、mmap与IO的关系&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>传统IO的瓶颈&lt;/strong>：
• &lt;strong>数据拷贝开销&lt;/strong>：&lt;code>read()&lt;/code>/&lt;code>write()&lt;/code>需要在内核缓冲区（页缓存）与用户空间之间复制数据，频繁系统调用和拷贝降低性能。
• &lt;strong>小文件问题&lt;/strong>：多次系统调用对小文件不友好，增加上下文切换开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>mmap的优势&lt;/strong>：
• &lt;strong>零拷贝（Zero-Copy）&lt;/strong>：直接操作映射内存，省去用户态与内核态的数据拷贝。
• &lt;strong>减少系统调用&lt;/strong>：通过内存访问隐式完成文件读写，无需显式调用&lt;code>read()&lt;/code>/&lt;code>write()&lt;/code>。
• &lt;strong>高效大文件处理&lt;/strong>：按需加载，避免一次性加载大文件的延迟和内存浪费。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能对比&lt;/strong>：
• &lt;strong>顺序访问&lt;/strong>：mmap与&lt;code>read()&lt;/code>性能接近，但省去拷贝时间。
• &lt;strong>随机访问&lt;/strong>：mmap显著优于传统IO，减少多次&lt;code>lseek()&lt;/code>和&lt;code>read()&lt;/code>的开销。
• &lt;strong>适用场景&lt;/strong>：适合频繁读写或需要随机访问的大文件（如数据库、图像处理）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="三mmap与内存分配的关系">三、mmap与内存分配的关系&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>动态内存分配&lt;/strong>：
• &lt;strong>glibc的malloc策略&lt;/strong>：
◦ 小块内存（如&amp;lt;128KB）使用&lt;code>brk()&lt;/code>扩展堆内存。
◦ 大块内存使用&lt;code>mmap(MAP_ANONYMOUS)&lt;/code>独立映射，避免内存碎片。
• &lt;strong>优势&lt;/strong>：&lt;code>mmap&lt;/code>分配的内存可独立释放（&lt;code>munmap()&lt;/code>），而&lt;code>brk()&lt;/code>释放需依赖堆顶内存释放顺序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>匿名映射的应用&lt;/strong>：
• &lt;strong>进程间共享内存&lt;/strong>：通过&lt;code>MAP_SHARED&lt;/code>标志，多个进程可共享同一物理内存，高效通信。
• &lt;strong>自定义内存管理&lt;/strong>：替代&lt;code>malloc&lt;/code>，用于需要精细控制的大内存分配（如内存池）。&lt;/p></description><content type="html"><![CDATA[<p>mmap（Memory Mapping）是Unix/Linux系统中的一种重要机制，它允许将文件或设备直接映射到进程的虚拟地址空间，从而将文件操作与内存操作高效结合。以下从核心机制、与IO的关系、与内存分配的关系三个方面详细解析：</p>
<hr>
<h3 id="一mmap的核心机制">一、mmap的核心机制</h3>
<ol>
<li>
<p><strong>系统调用与映射方式</strong>：
• <strong>函数原型</strong>：<code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code>
• <strong>关键参数</strong>：
◦ <code>prot</code>：控制读写权限（如<code>PROT_READ</code>、<code>PROT_WRITE</code>）。
◦ <code>flags</code>：决定映射类型（<code>MAP_SHARED</code>、<code>MAP_PRIVATE</code>、<code>MAP_ANONYMOUS</code>）。
• <strong>两种主要映射</strong>：
◦ <strong>文件映射</strong>：将文件映射到内存，修改可同步到文件（<code>MAP_SHARED</code>）或仅进程可见（<code>MAP_PRIVATE</code>）。
◦ <strong>匿名映射</strong>：不关联文件，用于进程间共享内存或动态内存分配（<code>MAP_ANONYMOUS</code>）。</p>
</li>
<li>
<p><strong>实现原理</strong>：
• <strong>虚拟内存管理</strong>：mmap在进程的虚拟地址空间中划分一段区域（通常位于堆与栈之间），通过页表映射到物理内存或文件的页缓存。
• <strong>按需加载（Demand Paging）</strong>：访问映射内存时触发缺页中断，内核自动将文件数据加载到物理内存，减少一次性加载开销。
• <strong>同步机制</strong>：修改后的数据由内核异步写回文件，也可通过<code>msync()</code>强制同步。</p>
</li>
</ol>
<hr>
<h3 id="二mmap与io的关系">二、mmap与IO的关系</h3>
<ol>
<li>
<p><strong>传统IO的瓶颈</strong>：
• <strong>数据拷贝开销</strong>：<code>read()</code>/<code>write()</code>需要在内核缓冲区（页缓存）与用户空间之间复制数据，频繁系统调用和拷贝降低性能。
• <strong>小文件问题</strong>：多次系统调用对小文件不友好，增加上下文切换开销。</p>
</li>
<li>
<p><strong>mmap的优势</strong>：
• <strong>零拷贝（Zero-Copy）</strong>：直接操作映射内存，省去用户态与内核态的数据拷贝。
• <strong>减少系统调用</strong>：通过内存访问隐式完成文件读写，无需显式调用<code>read()</code>/<code>write()</code>。
• <strong>高效大文件处理</strong>：按需加载，避免一次性加载大文件的延迟和内存浪费。</p>
</li>
<li>
<p><strong>性能对比</strong>：
• <strong>顺序访问</strong>：mmap与<code>read()</code>性能接近，但省去拷贝时间。
• <strong>随机访问</strong>：mmap显著优于传统IO，减少多次<code>lseek()</code>和<code>read()</code>的开销。
• <strong>适用场景</strong>：适合频繁读写或需要随机访问的大文件（如数据库、图像处理）。</p>
</li>
</ol>
<hr>
<h3 id="三mmap与内存分配的关系">三、mmap与内存分配的关系</h3>
<ol>
<li>
<p><strong>动态内存分配</strong>：
• <strong>glibc的malloc策略</strong>：
◦ 小块内存（如&lt;128KB）使用<code>brk()</code>扩展堆内存。
◦ 大块内存使用<code>mmap(MAP_ANONYMOUS)</code>独立映射，避免内存碎片。
• <strong>优势</strong>：<code>mmap</code>分配的内存可独立释放（<code>munmap()</code>），而<code>brk()</code>释放需依赖堆顶内存释放顺序。</p>
</li>
<li>
<p><strong>匿名映射的应用</strong>：
• <strong>进程间共享内存</strong>：通过<code>MAP_SHARED</code>标志，多个进程可共享同一物理内存，高效通信。
• <strong>自定义内存管理</strong>：替代<code>malloc</code>，用于需要精细控制的大内存分配（如内存池）。</p>
</li>
<li>
<p><strong>与传统堆内存的对比</strong>：</p>
<table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>mmap分配</strong></th>
          <th><strong>brk()分配</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>内存来源</td>
          <td>独立虚拟内存区域</td>
          <td>进程堆区</td>
      </tr>
      <tr>
          <td>释放方式</td>
          <td>立即归还系统（<code>munmap</code>）</td>
          <td>依赖堆顶收缩，易产生碎片</td>
      </tr>
      <tr>
          <td>适用场景</td>
          <td>大块内存、共享内存</td>
          <td>小块内存、频繁分配释放</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<hr>
<h3 id="四总结与扩展">四、总结与扩展</h3>
<p>• <strong>核心价值</strong>：mmap通过内存映射机制，统一了文件IO与内存操作，同时优化了动态内存分配策略。
• <strong>与页缓存的关系</strong>：mmap直接操作内核页缓存，而传统IO需显式读写页缓存，因此mmap在频繁访问时更高效。
• <strong>注意事项</strong>：
• <strong>32位系统限制</strong>：虚拟地址空间有限，映射大文件可能失败。
• <strong>文件截断问题</strong>：文件被外部修改时需处理<code>SIGBUS</code>信号。
• <strong>延迟加载风险</strong>：首次访问可能因缺页中断引入延迟。</p>
<p><strong>应用场景示例</strong>：
• <strong>数据库系统</strong>：使用mmap加速数据文件的随机访问。
• <strong>进程间通信</strong>：通过匿名共享内存传递大量数据。
• <strong>动态库加载</strong>：系统通过mmap将共享库映射到多个进程，节省内存。</p>
<p>mmap通过将文件、内存和进程虚拟地址空间紧密结合，成为高性能IO和灵活内存管理的基石。</p>
<hr>
<h1 id="零拷贝">零拷贝</h1>
<p>在Linux系统中，零拷贝（Zero-Copy）是一种优化数据传输效率的核心技术，旨在减少或消除数据在内核空间与用户空间之间的冗余拷贝操作。以下是针对该问题的结构化回答：</p>
<hr>
<h3 id="1-零拷贝的核心概念"><strong>1. 零拷贝的核心概念</strong></h3>
<p>零拷贝通过避免数据在内存中的多次复制，降低CPU和内存带宽的消耗，尤其适用于高吞吐量场景（如文件传输、网络通信）。其核心目标包括：
• <strong>减少CPU拷贝次数</strong>：利用DMA（直接内存访问）等技术，让硬件直接传输数据。
• <strong>减少上下文切换</strong>：通过内核态与用户态的协作优化系统调用次数。
• <strong>最大化内存利用率</strong>：直接操作内核缓冲区或共享内存区域。</p>
<hr>
<h3 id="2-传统io的瓶颈"><strong>2. 传统IO的瓶颈</strong></h3>
<p>以读取文件并通过网络发送为例，传统流程涉及多次数据拷贝和上下文切换：</p>
<ol>
<li><strong>磁盘到内核缓冲区</strong>：DMA将文件数据从磁盘拷贝到内核的页缓存（Page Cache）。</li>
<li><strong>内核到用户空间</strong>：<code>read()</code>系统调用将数据从页缓存拷贝到用户空间缓冲区（CPU参与）。</li>
<li><strong>用户空间到Socket缓冲区</strong>：<code>write()</code>系统调用将数据从用户空间拷贝到内核的Socket缓冲区（CPU参与）。</li>
<li><strong>Socket缓冲区到网卡</strong>：DMA将数据从Socket缓冲区发送到网卡。</li>
</ol>
<p><strong>问题</strong>：共4次拷贝（2次DMA，2次CPU拷贝），2次系统调用（read + write）。</p>
<hr>
<h3 id="3-linux零拷贝的实现方式"><strong>3. Linux零拷贝的实现方式</strong></h3>
<h4 id="1-mmap--write">**(1) **<code>mmap</code> + <code>write</code></h4>
<p>• <strong>原理</strong>：通过内存映射（<code>mmap</code>）将文件映射到用户空间，直接操作内核缓冲区，避免用户空间拷贝。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">mmap</span>(file_fd, ...);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">write</span>(socket_fd, addr, file_size);
</span></span></code></pre></div><p>• <strong>优化</strong>：减少1次CPU拷贝（用户空间到内核的拷贝）。
• <strong>剩余拷贝</strong>：3次拷贝（2次DMA，1次CPU拷贝）。
• <strong>适用场景</strong>：需要频繁读写文件内容（如数据库）。</p>
<h4 id="2-sendfile"><strong>(2) <code>sendfile</code></strong></h4>
<p>• <strong>原理</strong>：通过<code>sendfile</code>系统调用直接在文件描述符和Socket之间传输数据，完全在内核态完成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">sendfile</span>(socket_fd, file_fd, NULL, file_size);
</span></span></code></pre></div><p>• <strong>优化</strong>：消除用户空间参与，减少2次上下文切换，2次拷贝（仅1次CPU拷贝）。
• <strong>剩余拷贝</strong>：3次拷贝（2次DMA，1次CPU拷贝）。
• <strong>增强版（Linux 2.4+）</strong>：支持SG-DMA（Scatter-Gather DMA），直接从页缓存到网卡，<strong>仅需2次DMA拷贝</strong>，完全消除CPU拷贝。
• <strong>适用场景</strong>：静态文件传输（如Nginx发送大文件）。</p>
<h4 id="3-splice"><strong>(3) <code>splice</code></strong></h4>
<p>• <strong>原理</strong>：通过管道（Pipe）在内核中移动数据，无需用户空间参与。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">splice</span>(file_fd, NULL, pipe_fd, NULL, file_size, SPLICE_F_MOVE);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">splice</span>(pipe_fd, NULL, socket_fd, NULL, file_size, SPLICE_F_MOVE);
</span></span></code></pre></div><p>• <strong>优化</strong>：类似<code>sendfile</code>，但支持任意文件描述符（包括管道）。
• <strong>剩余拷贝</strong>：2次DMA拷贝（SG-DMA支持时）。
• <strong>适用场景</strong>：非文件到网络的数据传输（如进程间数据转发）。</p>
<h4 id="4-直接ioo_direct"><strong>(4) 直接IO（O_DIRECT）</strong></h4>
<p>• <strong>原理</strong>：绕过页缓存，直接从用户空间缓冲区读写磁盘（需硬件对齐）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">open</span>(file_path, O_RDWR <span style="color:#f92672">|</span> O_DIRECT);
</span></span></code></pre></div><p>• <strong>优化</strong>：避免页缓存拷贝，但需应用自行管理缓存。
• <strong>适用场景</strong>：自缓存应用（如某些数据库）。</p>
<hr>
<h3 id="4-零拷贝的对比与选择"><strong>4. 零拷贝的对比与选择</strong></h3>
<table>
  <thead>
      <tr>
          <th><strong>技术</strong></th>
          <th><strong>CPU拷贝次数</strong></th>
          <th><strong>上下文切换</strong></th>
          <th><strong>适用场景</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>传统<code>read/write</code></td>
          <td>2</td>
          <td>4（read+write）</td>
          <td>通用，但性能差</td>
      </tr>
      <tr>
          <td><code>mmap</code> + <code>write</code></td>
          <td>1</td>
          <td>4</td>
          <td>需修改文件内容</td>
      </tr>
      <tr>
          <td><code>sendfile</code></td>
          <td>0（SG-DMA）</td>
          <td>2</td>
          <td>文件到网络的单向传输（如Nginx）</td>
      </tr>
      <tr>
          <td><code>splice</code></td>
          <td>0（SG-DMA）</td>
          <td>2</td>
          <td>任意描述符间传输（需管道支持）</td>
      </tr>
      <tr>
          <td>O_DIRECT</td>
          <td>0</td>
          <td>4</td>
          <td>自管理缓存的专用场景</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="5-零拷贝的实际应用"><strong>5. 零拷贝的实际应用</strong></h3>
<p>• <strong>Nginx</strong>：使用<code>sendfile</code>加速静态文件传输。
• <strong>Kafka</strong>：通过<code>sendfile</code>高效传输日志文件。
• <strong>数据库</strong>：结合<code>mmap</code>或O_DIRECT优化磁盘IO。
• <strong>虚拟化</strong>：VMware/VirtIO使用零拷贝减少虚拟机间数据传输开销。</p>
<hr>
<h3 id="6-注意事项与局限性"><strong>6. 注意事项与局限性</strong></h3>
<p>• <strong>硬件依赖</strong>：SG-DMA需要网卡支持分散-聚集操作。
• <strong>数据修改</strong>：零拷贝技术通常适用于只读或无需修改数据的场景。
• <strong>小文件</strong>：零拷贝的优化效果在大文件中更显著，小文件可能因系统调用开销掩盖优势。
• <strong>兼容性</strong>：<code>sendfile</code>在传输带数据头的内容时需结合其他技术（如<code>writev</code>）。</p>
<hr>
<h3 id="7-扩展问题准备"><strong>7. 扩展问题准备</strong></h3>
<p>• <strong>DMA的作用</strong>：允许外设直接访问内存，减少CPU负担。
• <strong>Page Cache的影响</strong>：零拷贝依赖内核缓冲区管理，频繁写入可能导致缓存膨胀。
• <strong>与内存映射的关系</strong>：<code>mmap</code>是零拷贝的基石，但并非所有零拷贝都依赖内存映射。</p>
<hr>
<p><strong>总结回答示例</strong>：<br>
“零拷贝技术通过减少数据在内核与用户空间之间的冗余拷贝，显著提升IO性能。Linux中主要通过<code>mmap</code>、<code>sendfile</code>和<code>splice</code>等系统调用实现。例如，<code>sendfile</code>在内核态直接将文件数据从页缓存发送到网卡，避免了用户空间的参与，适合静态文件传输。选择时需要结合场景：<code>sendfile</code>适合单向传输，<code>mmap</code>适合需要读写文件内容，而<code>splice</code>更灵活但依赖管道。实际应用中需注意硬件支持和数据特性。”</p>
<hr>
<h1 id="mmap-和-dma-的关系">mmap 和 DMA 的关系</h1>
<p><strong>mmap 不是 DMA 的一种</strong>，它们是两个完全不同的技术，但可以协同工作以提高系统性能。以下是详细对比和解释：</p>
<hr>
<h3 id="1-核心概念对比"><strong>1. 核心概念对比</strong></h3>
<table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>mmap</strong></th>
          <th><strong>DMA（直接内存访问）</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>定义</strong></td>
          <td>内存映射技术，将文件或设备映射到进程的虚拟地址空间</td>
          <td>硬件技术，允许外设直接访问内存，无需CPU参与</td>
      </tr>
      <tr>
          <td><strong>作用层级</strong></td>
          <td>操作系统/软件层（内存管理、文件I/O优化）</td>
          <td>硬件/驱动层（数据传输优化）</td>
      </tr>
      <tr>
          <td><strong>主要目的</strong></td>
          <td>减少用户态与内核态的数据拷贝</td>
          <td>减少CPU在数据传输中的负担</td>
      </tr>
      <tr>
          <td><strong>依赖关系</strong></td>
          <td>依赖操作系统内存管理机制（如页表、缺页中断）</td>
          <td>依赖硬件支持（如DMA控制器、设备兼容性）</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="2-技术原理差异"><strong>2. 技术原理差异</strong></h3>
<h4 id="mmap-的工作流程"><strong>mmap 的工作流程</strong></h4>
<ol>
<li><strong>映射文件到内存</strong>：调用 <code>mmap</code> 后，文件被映射到进程的虚拟地址空间。</li>
<li><strong>按需加载数据</strong>：访问内存时触发缺页中断，内核将文件内容从磁盘加载到物理内存（可能通过DMA）。</li>
<li><strong>直接操作内存</strong>：应用程序通过指针读写内存，无需调用 <code>read()</code>/<code>write()</code>。</li>
<li><strong>同步数据</strong>：修改后的数据由内核异步写回磁盘（或通过 <code>msync()</code> 强制同步）。</li>
</ol>
<h4 id="dma-的工作流程"><strong>DMA 的工作流程</strong></h4>
<ol>
<li><strong>CPU 初始化传输</strong>：CPU 设置DMA传输参数（源地址、目标地址、数据大小）。</li>
<li><strong>DMA 接管数据传输</strong>：DMA控制器直接在外设（如磁盘）和内存之间搬运数据。</li>
<li><strong>传输完成中断</strong>：DMA完成后，通过中断通知CPU。</li>
<li><strong>CPU 处理后续逻辑</strong>：如更新状态、唤醒等待的进程。</li>
</ol>
<hr>
<h3 id="3-协同工作场景"><strong>3. 协同工作场景</strong></h3>
<p>虽然 mmap 和 DMA 是独立的技术，但它们可以在某些场景下配合使用：</p>
<h4 id="示例通过-mmap-读取文件"><strong>示例：通过 mmap 读取文件</strong></h4>
<ol>
<li><strong>mmap 映射文件</strong>：文件被映射到用户空间，但物理内存中可能尚未加载数据。</li>
<li><strong>首次访问触发缺页中断</strong>：内核调用磁盘驱动，使用 <strong>DMA 将文件数据从磁盘读取到物理内存</strong>。</li>
<li><strong>后续访问直接操作内存</strong>：无需CPU参与数据拷贝，直接读写内存即可。</li>
</ol>
<p><strong>优势</strong>：<br>
• <strong>减少CPU拷贝</strong>：DMA负责磁盘到内存的传输，mmap避免用户态与内核态的数据复制。
• <strong>零拷贝优化</strong>：在文件处理中，mmap + DMA的组合是零拷贝技术的一部分。</p>
<hr>
<h3 id="4-常见误解澄清"><strong>4. 常见误解澄清</strong></h3>
<h4 id="误解1mmap直接使用dma传输数据"><strong>误解1：“mmap直接使用DMA传输数据”</strong></h4>
<p>• <strong>真相</strong>：mmap本身不控制数据传输方式，数据加载到内存的具体过程（是否用DMA）由内核和驱动决定。DMA的调用是透明的，对mmap不可见。</p>
<h4 id="误解2dma只能在mmap中使用"><strong>误解2：“DMA只能在mmap中使用”</strong></h4>
<p>• <strong>真相</strong>：DMA广泛用于所有IO场景，包括传统<code>read()</code>/<code>write()</code>。例如：
• <code>read()</code>：磁盘 → 内核缓冲区（DMA） → 用户缓冲区（CPU拷贝）。
• <code>mmap</code>：磁盘 → 内核缓冲区（DMA） → 用户直接访问（无需CPU拷贝）。</p>
<hr>
<h3 id="5-总结"><strong>5. 总结</strong></h3>
<p>• <strong>mmap ≠ DMA</strong>：mmap是软件层的内存映射技术，DMA是硬件层的数据传输技术。
• <strong>协同关系</strong>：在mmap访问文件时，DMA可能被内核用于磁盘到内存的数据传输，但这是内核的底层优化，与mmap无直接关联。
• <strong>性能优化</strong>：两者结合可实现零拷贝（如<code>mmap</code> + <code>write</code>），但DMA的参与是隐式的，由操作系统自动管理。</p>
<hr>
<p><strong>回答示例</strong>：<br>
“mmap和DMA是不同层级的技术。mmap是操作系统提供的内存映射机制，用于让应用程序直接访问文件数据，减少数据拷贝；而DMA是硬件功能，允许外设直接读写内存，无需CPU参与。虽然mmap访问文件时，数据加载到内存的过程可能由DMA完成，但mmap本身并不等同于DMA，它们是互补关系，共同实现高效IO。”</p>
]]></content></item><item><title>内核的用户态和内核态</title><link>https://jekyulll.github.io/posts/linux-%E5%86%85%E6%A0%B8%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</link><pubDate>Fri, 07 Mar 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E5%86%85%E6%A0%B8%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</guid><description>&lt;p>线程的管理和调度涉及用户态与内核态的协作，不同编程语言和操作系统对线程的处理方式也有所差异。&lt;/p>
&lt;hr>
&lt;h3 id="一线程概念的双重性用户态与内核态的交织">一、线程概念的双重性：用户态与内核态的交织&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>用户态线程（用户级线程）&lt;/strong>&lt;br>
用户态线程由用户空间的线程库直接管理，内核对其无感知。这类线程的创建、调度、同步等操作完全在用户空间完成，无需内核介入。&lt;br>
存在明显局限性：&lt;br>
• &lt;strong>阻塞问题&lt;/strong>：若一个用户态线程因系统调用阻塞（如I/O操作），整个进程的所有线程都会被阻塞；
• &lt;strong>多核利用率低&lt;/strong>：内核无法将用户态线程调度到多个CPU核心上运行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>内核态线程（内核级线程）&lt;/strong>&lt;br>
内核直接管理线程的创建、调度和销毁，每个线程对应一个内核线程（如Linux的轻量级进程LWP）。&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>轻量级进程&lt;/em>（Light Weight Process, LWP）作为用户线程与内核线程的桥梁，负责处理系统调用、资源分配和CPU映射。当用户线程发起系统调用时，LWP接管请求，避免因单个用户线程阻塞导致整个进程挂起。&lt;/p>
&lt;/blockquote>
&lt;p>• &lt;strong>多核并行&lt;/strong>：内核可将不同线程分配到多个CPU核心；
• &lt;strong>独立阻塞&lt;/strong>：单个线程阻塞不会影响其他线程；
• &lt;strong>切换开销大&lt;/strong>：线程切换需通过内核态，涉及用户栈和内核栈的切换、寄存器保存与恢复等操作。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二内核如何处理线程">二、内核如何处理线程？&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>线程模型的映射关系&lt;/strong>&lt;br>
现代操作系统（如Linux）通常采用&lt;strong>混合型线程模型&lt;/strong>。内核通过以下机制管理线程：&lt;br>
• &lt;strong>TCB（线程控制块）&lt;/strong>：存储线程的内核栈指针、状态、优先级等信息（进程控制块是PCB）；
• &lt;strong>调度器&lt;/strong>：基于时间片轮转或优先级策略分配CPU资源，触发上下文切换。&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>混合型线程模型&lt;/em>（Hybrid Thread Model）是一种结合用户级线程（ULT）和内核级线程（KLT）优势的线程实现方式。通过N:M映射实现用户线程与内核线程的关联，即多个用户线程（N）动态绑定到少量内核线程（M）。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>用户态与内核态的切换机制&lt;/strong>&lt;br>
当线程执行系统调用、发生异常或中断时，会触发用户态到内核态的切换：&lt;br>
• &lt;strong>系统调用流程&lt;/strong>：用户线程通过中断（如Linux的&lt;code>int 80h&lt;/code>）进入内核态，内核完成操作后恢复用户态执行；
• &lt;strong>上下文保存&lt;/strong>：切换时需要保存用户栈的寄存器状态（如程序计数器、栈指针）到内存，并加载内核栈信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能优化策略&lt;/strong>&lt;br>
内核通过以下方式减少切换开销：&lt;br>
• &lt;strong>避免频繁切换&lt;/strong>：采用无锁编程、CAS算法等减少线程竞争；
• &lt;strong>轻量级进程（LWP）&lt;/strong>：通过线程池复用内核线程，降低创建销毁成本。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="三语言案例">三、语言案例&lt;/h3>
&lt;p>Java线程在JDK1.2之后采用&lt;em>1:1模型&lt;/em>，每个Java线程对应一个内核线程。
支持多核并行、避免单线程阻塞影响整体进程；线程创建和切换需要内核介入。&lt;/p>
&lt;p>C++11及之后的标准库（如&lt;code>&amp;lt;thread&amp;gt;&lt;/code>）通过&lt;code>std::thread&lt;/code>直接调用操作系统线程（如Linux的POSIX线程或Windows线程），采用&lt;em>1:1线程模型&lt;/em>。&lt;/p>
&lt;p>Go未直接使用操作系统线程，而是通过Goroutine实现并发。Goroutine由Go运行时调度，采用M:N线程模型​（多个Goroutine映射到少量内核线程），由运行时动态分配CPU时间片。&lt;/p></description><content type="html"><![CDATA[<p>线程的管理和调度涉及用户态与内核态的协作，不同编程语言和操作系统对线程的处理方式也有所差异。</p>
<hr>
<h3 id="一线程概念的双重性用户态与内核态的交织">一、线程概念的双重性：用户态与内核态的交织</h3>
<ol>
<li>
<p><strong>用户态线程（用户级线程）</strong><br>
用户态线程由用户空间的线程库直接管理，内核对其无感知。这类线程的创建、调度、同步等操作完全在用户空间完成，无需内核介入。<br>
存在明显局限性：<br>
• <strong>阻塞问题</strong>：若一个用户态线程因系统调用阻塞（如I/O操作），整个进程的所有线程都会被阻塞；
• <strong>多核利用率低</strong>：内核无法将用户态线程调度到多个CPU核心上运行。</p>
</li>
<li>
<p><strong>内核态线程（内核级线程）</strong><br>
内核直接管理线程的创建、调度和销毁，每个线程对应一个内核线程（如Linux的轻量级进程LWP）。</p>
<blockquote>
<p><em>轻量级进程</em>（Light Weight Process, LWP）作为用户线程与内核线程的桥梁，负责处理系统调用、资源分配和CPU映射。当用户线程发起系统调用时，LWP接管请求，避免因单个用户线程阻塞导致整个进程挂起。</p>
</blockquote>
<p>• <strong>多核并行</strong>：内核可将不同线程分配到多个CPU核心；
• <strong>独立阻塞</strong>：单个线程阻塞不会影响其他线程；
• <strong>切换开销大</strong>：线程切换需通过内核态，涉及用户栈和内核栈的切换、寄存器保存与恢复等操作。</p>
</li>
</ol>
<hr>
<h3 id="二内核如何处理线程">二、内核如何处理线程？</h3>
<ol>
<li>
<p><strong>线程模型的映射关系</strong><br>
现代操作系统（如Linux）通常采用<strong>混合型线程模型</strong>。内核通过以下机制管理线程：<br>
• <strong>TCB（线程控制块）</strong>：存储线程的内核栈指针、状态、优先级等信息（进程控制块是PCB）；
• <strong>调度器</strong>：基于时间片轮转或优先级策略分配CPU资源，触发上下文切换。</p>
<blockquote>
<p><em>混合型线程模型</em>（Hybrid Thread Model）是一种结合用户级线程（ULT）和内核级线程（KLT）优势的线程实现方式。通过N:M映射实现用户线程与内核线程的关联，即多个用户线程（N）动态绑定到少量内核线程（M）。</p>
</blockquote>
</li>
<li>
<p><strong>用户态与内核态的切换机制</strong><br>
当线程执行系统调用、发生异常或中断时，会触发用户态到内核态的切换：<br>
• <strong>系统调用流程</strong>：用户线程通过中断（如Linux的<code>int 80h</code>）进入内核态，内核完成操作后恢复用户态执行；
• <strong>上下文保存</strong>：切换时需要保存用户栈的寄存器状态（如程序计数器、栈指针）到内存，并加载内核栈信息。</p>
</li>
<li>
<p><strong>性能优化策略</strong><br>
内核通过以下方式减少切换开销：<br>
• <strong>避免频繁切换</strong>：采用无锁编程、CAS算法等减少线程竞争；
• <strong>轻量级进程（LWP）</strong>：通过线程池复用内核线程，降低创建销毁成本。</p>
</li>
</ol>
<hr>
<h3 id="三语言案例">三、语言案例</h3>
<p>Java线程在JDK1.2之后采用<em>1:1模型</em>，每个Java线程对应一个内核线程。
支持多核并行、避免单线程阻塞影响整体进程；线程创建和切换需要内核介入。</p>
<p>C++11及之后的标准库（如<code>&lt;thread&gt;</code>）通过<code>std::thread</code>直接调用操作系统线程（如Linux的POSIX线程或Windows线程），采用<em>1:1线程模型</em>。</p>
<p>Go未直接使用操作系统线程，而是通过Goroutine实现并发。Goroutine由Go运行时调度，采用M:N线程模型​（多个Goroutine映射到少量内核线程），由运行时动态分配CPU时间片。</p>
]]></content></item><item><title>进程、线程、协程的资源消耗简述</title><link>https://jekyulll.github.io/posts/linux-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%E7%AE%80%E8%BF%B0/</link><pubDate>Fri, 07 Mar 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%E7%AE%80%E8%BF%B0/</guid><description>&lt;p>&lt;strong>一、线程切换 vs 进程切换&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>地址空间与页表&lt;/strong>&lt;br>
进程拥有独立的虚拟地址空间和页表，切换进程时需更新页表并刷新 &lt;strong>TLB（地址转换缓存）&lt;/strong>，导致内存访问速度下降。而线程共享进程的地址空间和页表，切换时无需此操作，TLB 缓存保持有效。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>上下文保存的内容&lt;/strong>&lt;br>
• &lt;strong>进程切换&lt;/strong>：需保存完整的上下文，包括寄存器、程序计数器、栈指针、内存映射、文件描述符等。&lt;br>
• &lt;strong>线程切换&lt;/strong>：仅需保存线程私有的寄存器、栈和程序计数器，共享资源（如代码段、文件）无需处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缓存利用率&lt;/strong>&lt;br>
进程切换会导致 CPU 缓存（如 L1/L2/L3）失效，需重新加载数据，降低性能。线程切换时，缓存因共享地址空间仍有效，减少了数据重载的开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>资源分配&lt;/strong>&lt;br>
进程是资源分配的基本单位（如内存、文件），切换时需重新分配资源；线程共享进程资源，切换仅涉及执行流调度。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>二、协程切换 vs 线程切换&lt;/strong>&lt;/p>
&lt;p>协程的切换开销更小，原因在于其 &lt;strong>用户态调度&lt;/strong> 和 &lt;strong>轻量级设计&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>用户态调度&lt;/strong>&lt;br>
协程切换完全由用户态代码控制，无需陷入内核态，避免了 &lt;strong>用户态-内核态切换&lt;/strong> 的开销。而线程切换需操作系统介入，涉及模式切换和内核调度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>上下文信息更少&lt;/strong>&lt;br>
协程只需保存少量寄存器（如 PC、SP）和栈指针，且栈空间通常仅需 KB 级别（线程栈为 MB 级别）。例如，Go 协程的初始栈仅 2KB，而 Java 线程默认为 1MB。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>非阻塞与协作式调度&lt;/strong>&lt;br>
协程通过主动让出（如 &lt;code>yield&lt;/code> 或 &lt;code>await&lt;/code>）实现协作式调度，减少抢占式调度的竞争和锁需求。线程通常依赖操作系统的抢占式调度，可能因频繁切换导致性能损耗。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>内存与并发效率&lt;/strong>&lt;br>
单线程可运行数万协程（如 Go 的 Goroutine），而同等数量线程会因内存和调度开销过大而崩溃。协程的轻量级特性尤其适合高并发 I/O 密集型任务。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>维度&lt;/strong>&lt;/th>
&lt;th>&lt;strong>进程切换&lt;/strong>&lt;/th>
&lt;th>&lt;strong>线程切换&lt;/strong>&lt;/th>
&lt;th>&lt;strong>协程切换&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>地址空间&lt;/strong>&lt;/td>
&lt;td>切换（独立）&lt;/td>
&lt;td>不切换（共享）&lt;/td>
&lt;td>不切换（共享）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>上下文大小&lt;/strong>&lt;/td>
&lt;td>大（含全部资源）&lt;/td>
&lt;td>较小（仅寄存器）&lt;/td>
&lt;td>极小（仅关键寄存器）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>调度模式&lt;/strong>&lt;/td>
&lt;td>内核抢占式&lt;/td>
&lt;td>内核抢占式&lt;/td>
&lt;td>用户协作式&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>内存开销&lt;/strong>&lt;/td>
&lt;td>高（独立资源）&lt;/td>
&lt;td>中（共享资源）&lt;/td>
&lt;td>极低（KB 级栈）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;u>线程通过共享资源减少开销，协程通过用户态轻量级调度进一步优化，两者均通过减少内核参与和资源复用来提升性能&lt;/u>&amp;gt;。&lt;/p></description><content type="html"><![CDATA[<p><strong>一、线程切换 vs 进程切换</strong></p>
<ol>
<li>
<p><strong>地址空间与页表</strong><br>
进程拥有独立的虚拟地址空间和页表，切换进程时需更新页表并刷新 <strong>TLB（地址转换缓存）</strong>，导致内存访问速度下降。而线程共享进程的地址空间和页表，切换时无需此操作，TLB 缓存保持有效。</p>
</li>
<li>
<p><strong>上下文保存的内容</strong><br>
• <strong>进程切换</strong>：需保存完整的上下文，包括寄存器、程序计数器、栈指针、内存映射、文件描述符等。<br>
• <strong>线程切换</strong>：仅需保存线程私有的寄存器、栈和程序计数器，共享资源（如代码段、文件）无需处理。</p>
</li>
<li>
<p><strong>缓存利用率</strong><br>
进程切换会导致 CPU 缓存（如 L1/L2/L3）失效，需重新加载数据，降低性能。线程切换时，缓存因共享地址空间仍有效，减少了数据重载的开销。</p>
</li>
<li>
<p><strong>资源分配</strong><br>
进程是资源分配的基本单位（如内存、文件），切换时需重新分配资源；线程共享进程资源，切换仅涉及执行流调度。</p>
</li>
</ol>
<p><strong>二、协程切换 vs 线程切换</strong></p>
<p>协程的切换开销更小，原因在于其 <strong>用户态调度</strong> 和 <strong>轻量级设计</strong>：</p>
<ol>
<li>
<p><strong>用户态调度</strong><br>
协程切换完全由用户态代码控制，无需陷入内核态，避免了 <strong>用户态-内核态切换</strong> 的开销。而线程切换需操作系统介入，涉及模式切换和内核调度。</p>
</li>
<li>
<p><strong>上下文信息更少</strong><br>
协程只需保存少量寄存器（如 PC、SP）和栈指针，且栈空间通常仅需 KB 级别（线程栈为 MB 级别）。例如，Go 协程的初始栈仅 2KB，而 Java 线程默认为 1MB。</p>
</li>
<li>
<p><strong>非阻塞与协作式调度</strong><br>
协程通过主动让出（如 <code>yield</code> 或 <code>await</code>）实现协作式调度，减少抢占式调度的竞争和锁需求。线程通常依赖操作系统的抢占式调度，可能因频繁切换导致性能损耗。</p>
</li>
<li>
<p><strong>内存与并发效率</strong><br>
单线程可运行数万协程（如 Go 的 Goroutine），而同等数量线程会因内存和调度开销过大而崩溃。协程的轻量级特性尤其适合高并发 I/O 密集型任务。</p>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th><strong>维度</strong></th>
          <th><strong>进程切换</strong></th>
          <th><strong>线程切换</strong></th>
          <th><strong>协程切换</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>地址空间</strong></td>
          <td>切换（独立）</td>
          <td>不切换（共享）</td>
          <td>不切换（共享）</td>
      </tr>
      <tr>
          <td><strong>上下文大小</strong></td>
          <td>大（含全部资源）</td>
          <td>较小（仅寄存器）</td>
          <td>极小（仅关键寄存器）</td>
      </tr>
      <tr>
          <td><strong>调度模式</strong></td>
          <td>内核抢占式</td>
          <td>内核抢占式</td>
          <td>用户协作式</td>
      </tr>
      <tr>
          <td><strong>内存开销</strong></td>
          <td>高（独立资源）</td>
          <td>中（共享资源）</td>
          <td>极低（KB 级栈）</td>
      </tr>
  </tbody>
</table>
<p><u>线程通过共享资源减少开销，协程通过用户态轻量级调度进一步优化，两者均通过减少内核参与和资源复用来提升性能</u>&gt;。</p>
]]></content></item><item><title>在运行的时候，修改并且覆盖该二进制文件会如何？</title><link>https://jekyulll.github.io/posts/linux-%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E4%BF%AE%E6%94%B9%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E8%AF%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BC%9A%E5%A6%82%E4%BD%95/</link><pubDate>Thu, 06 Mar 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E4%BF%AE%E6%94%B9%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E8%AF%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BC%9A%E5%A6%82%E4%BD%95/</guid><description>&lt;blockquote>
&lt;p>Linux上有个二进制程序一直在运行，修改代码后重新编译把原来的二进制程序覆盖了，会怎么样？
该问题来自一道天美后台开发面试题：&lt;a href="https://zhuanlan.zhihu.com/p/677307438">天美一面 后台开发（凉） - 牛客面经的文章 - 知乎&lt;/a>。此处尝试进行回答。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>第一想法一般是：“原程序被操作系统加载进内存，不会受到影响。”&lt;br>
系统会创建一个新的&lt;code>inode&lt;/code>指向新文件，而正在运行的进程仍会继续使用旧的&lt;code>inode&lt;/code>对应的代码段。&lt;/p>
&lt;p>但实际上拓展到一个问题：“二进制文件会全部加载到内存吗？”&lt;/p>
&lt;p>ELF二进制文件在加载时，操作系统通常采用按需分页的机制，只将当前需要的部分加载到物理内存，而不是一次性加载整个文件。虚拟内存映射允许文件的部分内容驻留在磁盘，直到被访问时才调入内存。&lt;br>
同时，动态链接库的延迟加载和内存映射文件技术（&lt;code>mmap&lt;/code>）也帮助减少实际内存占用。因此，如果二进制文件很大，不会全部加载到物理内存中，而是按需加载，利用虚拟内存管理技术优化资源使用。&lt;/p>
&lt;p>但是：真的会在运行时加载新的内容吗？&lt;/p>
&lt;p>ELF文件在启动时如何决定哪些内容加载到内存？主要依赖于其&lt;strong>程序头表&lt;/strong>（Program Header Table）​中定义的段（Segment）信息。程序头表由多个&lt;code>Elf64_Phdr&lt;/code>结构体组成，每个结构体描述了一个需要加载到内存的段（如代码段、数据段、动态链接信息段等）。这些段通常包含多个&lt;em>节&lt;/em>（Section）的集合。&lt;/p>
&lt;p>覆盖原文件后，旧文件的磁盘空间不会被立即释放，需等待所有关联进程结束后才能回收（通过&lt;code>lsof&lt;/code>可查看占用进程）。&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>：&lt;br>
​已运行的进程不受影响：Linux通过&lt;code>inode&lt;/code>标识文件，旧进程继续执行内存中已加载的旧代码，与原磁盘文件解耦。&lt;/p>
&lt;hr>
&lt;h3 id="1-elf文件的按需加载机制">1. &lt;strong>ELF文件的按需加载机制&lt;/strong>&lt;/h3>
&lt;p>ELF二进制文件通过&lt;strong>程序头表（Program Header Table）&lt;strong>中的&lt;code>PT_LOAD&lt;/code>段描述需要加载的代码和数据区域。内核的&lt;code>load_elf_binary()&lt;/code>函数会将这些段映射到进程的虚拟地址空间，但实际物理内存的占用是&lt;/strong>按需分页&lt;/strong>的：
• 仅当程序访问某个页（通常4KB大小）时，才会触发缺页异常，将对应内容从磁盘加载到物理内存。
• 未使用的代码或数据（如未执行的函数）可能永远不会被加载到物理内存中。&lt;/p>
&lt;h3 id="2-虚拟内存映射与内存优化">2. &lt;strong>虚拟内存映射与内存优化&lt;/strong>&lt;/h3>
&lt;p>• &lt;strong>虚拟内存优势&lt;/strong>：ELF文件通过&lt;code>mmap()&lt;/code>系统调用映射到虚拟地址空间，此时文件内容并不直接占用物理内存，而是由内核通过页表管理。
• &lt;strong>写时复制（Copy-on-Write）&lt;/strong>：对于只读段（如代码段），多个进程可以共享同一物理内存页；对于可写段，修改时才会复制新页。&lt;/p>
&lt;h3 id="3-动态链接与延迟加载">3. &lt;strong>动态链接与延迟加载&lt;/strong>&lt;/h3>
&lt;p>动态链接库（如&lt;code>.so&lt;/code>文件）在程序运行时通过&lt;code>ld-linux&lt;/code>动态加载器按需载入。例如：
• 首次调用某个库函数时，动态链接器才会加载对应的代码段到内存。
• 部分库可能仅在特定条件下被使用，从而减少初始内存占用。&lt;/p>
&lt;h3 id="4-大文件的实际内存占用">4. &lt;strong>大文件的实际内存占用&lt;/strong>&lt;/h3>
&lt;p>• &lt;strong>物理内存限制&lt;/strong>：若二进制文件极大（如8GB），但程序实际执行的代码路径有限，物理内存占用可能远小于文件大小。
• &lt;strong>交换空间（Swap）&lt;/strong>：当物理内存不足时，操作系统会将不活跃的内存页交换到磁盘，腾出空间供当前进程使用。&lt;/p></description><content type="html"><![CDATA[<blockquote>
<p>Linux上有个二进制程序一直在运行，修改代码后重新编译把原来的二进制程序覆盖了，会怎么样？
该问题来自一道天美后台开发面试题：<a href="https://zhuanlan.zhihu.com/p/677307438">天美一面 后台开发（凉） - 牛客面经的文章 - 知乎</a>。此处尝试进行回答。</p>
</blockquote>
<hr>
<p>第一想法一般是：“原程序被操作系统加载进内存，不会受到影响。”<br>
系统会创建一个新的<code>inode</code>指向新文件，而正在运行的进程仍会继续使用旧的<code>inode</code>对应的代码段。</p>
<p>但实际上拓展到一个问题：“二进制文件会全部加载到内存吗？”</p>
<p>ELF二进制文件在加载时，操作系统通常采用按需分页的机制，只将当前需要的部分加载到物理内存，而不是一次性加载整个文件。虚拟内存映射允许文件的部分内容驻留在磁盘，直到被访问时才调入内存。<br>
同时，动态链接库的延迟加载和内存映射文件技术（<code>mmap</code>）也帮助减少实际内存占用。因此，如果二进制文件很大，不会全部加载到物理内存中，而是按需加载，利用虚拟内存管理技术优化资源使用。</p>
<p>但是：真的会在运行时加载新的内容吗？</p>
<p>ELF文件在启动时如何决定哪些内容加载到内存？主要依赖于其<strong>程序头表</strong>（Program Header Table）​中定义的段（Segment）信息。程序头表由多个<code>Elf64_Phdr</code>结构体组成，每个结构体描述了一个需要加载到内存的段（如代码段、数据段、动态链接信息段等）。这些段通常包含多个<em>节</em>（Section）的集合。</p>
<p>覆盖原文件后，旧文件的磁盘空间不会被立即释放，需等待所有关联进程结束后才能回收（通过<code>lsof</code>可查看占用进程）。</p>
<p><strong>总结</strong>：<br>
​已运行的进程不受影响：Linux通过<code>inode</code>标识文件，旧进程继续执行内存中已加载的旧代码，与原磁盘文件解耦。</p>
<hr>
<h3 id="1-elf文件的按需加载机制">1. <strong>ELF文件的按需加载机制</strong></h3>
<p>ELF二进制文件通过<strong>程序头表（Program Header Table）<strong>中的<code>PT_LOAD</code>段描述需要加载的代码和数据区域。内核的<code>load_elf_binary()</code>函数会将这些段映射到进程的虚拟地址空间，但实际物理内存的占用是</strong>按需分页</strong>的：
• 仅当程序访问某个页（通常4KB大小）时，才会触发缺页异常，将对应内容从磁盘加载到物理内存。
• 未使用的代码或数据（如未执行的函数）可能永远不会被加载到物理内存中。</p>
<h3 id="2-虚拟内存映射与内存优化">2. <strong>虚拟内存映射与内存优化</strong></h3>
<p>• <strong>虚拟内存优势</strong>：ELF文件通过<code>mmap()</code>系统调用映射到虚拟地址空间，此时文件内容并不直接占用物理内存，而是由内核通过页表管理。
• <strong>写时复制（Copy-on-Write）</strong>：对于只读段（如代码段），多个进程可以共享同一物理内存页；对于可写段，修改时才会复制新页。</p>
<h3 id="3-动态链接与延迟加载">3. <strong>动态链接与延迟加载</strong></h3>
<p>动态链接库（如<code>.so</code>文件）在程序运行时通过<code>ld-linux</code>动态加载器按需载入。例如：
• 首次调用某个库函数时，动态链接器才会加载对应的代码段到内存。
• 部分库可能仅在特定条件下被使用，从而减少初始内存占用。</p>
<h3 id="4-大文件的实际内存占用">4. <strong>大文件的实际内存占用</strong></h3>
<p>• <strong>物理内存限制</strong>：若二进制文件极大（如8GB），但程序实际执行的代码路径有限，物理内存占用可能远小于文件大小。
• <strong>交换空间（Swap）</strong>：当物理内存不足时，操作系统会将不活跃的内存页交换到磁盘，腾出空间供当前进程使用。</p>
]]></content></item><item><title>线程池调度：动态优先级老化（Aging）+ 双队列混合轮询</title><link>https://jekyulll.github.io/posts/cpp-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E5%BA%A6%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E8%80%81%E5%8C%96aging+-%E5%8F%8C%E9%98%9F%E5%88%97%E6%B7%B7%E5%90%88%E8%BD%AE%E8%AF%A2/</link><pubDate>Tue, 25 Feb 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E5%BA%A6%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E8%80%81%E5%8C%96aging+-%E5%8F%8C%E9%98%9F%E5%88%97%E6%B7%B7%E5%90%88%E8%BD%AE%E8%AF%A2/</guid><description>&lt;p>C++中线程池一般使用队列（&lt;code>std::queue&lt;/code>）配合外部的&lt;code>std::condition_variable&lt;/code>，或者手动构建阻塞队列（BlockQueue）来设计。&lt;/p>
&lt;p>而需要使用任务优先级的时候，一般使用大根堆/小根堆的优先级队列&lt;code>std::priority_queue&lt;/code>来实现。&lt;/p>
&lt;p>那么问题来了，在任务优先级比较不均的时候，怎么避免低优先级任务的长时间饥饿呢？&lt;/p>
&lt;p>为了实现动态公平调度：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>动态优先级老化（Aging）：优先级动态调整&lt;/strong>：任务在队列中等待时间越长，其有效优先级逐渐升高。&lt;/li>
&lt;li>&lt;strong>双队列混合轮询&lt;/strong>：每处理一定数量的高优先级任务后，强制处理低优先级任务。&lt;/li>
&lt;/ul>
&lt;p>首先抽象出一个&lt;code>Task&lt;/code>用于记录任务的初始优先级和入队时间：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;chrono&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Task&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> base_priority; &lt;span style="color:#75715e">// 初始优先级
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>steady_clock&lt;span style="color:#f92672">::&lt;/span>time_point enqueue_time;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> job;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 计算动态优先级（等待时间越长，优先级越高）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">dynamic_priority&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> now &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>steady_clock&lt;span style="color:#f92672">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> wait_time &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>duration_cast&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>seconds&lt;span style="color:#f92672">&amp;gt;&lt;/span>(now &lt;span style="color:#f92672">-&lt;/span> enqueue_time).count();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> base_priority &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(wait_time &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0.1&lt;/span>); &lt;span style="color:#75715e">// 老化系数可调
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 重载比较运算符（实际比较动态优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Task&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dynamic_priority() &lt;span style="color:#f92672">&amp;lt;&lt;/span> other.dynamic_priority();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>整体的线程池类设计：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;thread&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;condition_variable&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadPool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadPool(size_t threads, size_t high_freq &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> high_processing_count(&lt;span style="color:#ae81ff">0&lt;/span>), high_freq_(high_freq) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(size_t i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> threads; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workers.emplace_back([&lt;span style="color:#66d9ef">this&lt;/span>] { worker_loop(); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_task&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> priority, std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(queue_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue.emplace(Task{priority, std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>steady_clock&lt;span style="color:#f92672">::&lt;/span>now(), task});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> condition.notify_one();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>ThreadPool() { &lt;span style="color:#75715e">/* ... 省略资源回收代码 ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>mutex queue_mutex;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>condition_variable condition;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Task&lt;span style="color:#f92672">&amp;gt;&lt;/span> queue; &lt;span style="color:#75715e">// 主队列（动态优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> low_priority_queue; &lt;span style="color:#75715e">// 辅助队列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> workers;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 轮询控制
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> high_processing_count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> high_freq_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">worker_loop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(true) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(queue_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> condition.wait(lock, [&lt;span style="color:#66d9ef">this&lt;/span>] { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>queue.empty(); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 动态老化：每处理high_freq_个高优任务后强制处理低优
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">++&lt;/span>high_processing_count &lt;span style="color:#f92672">%&lt;/span> high_freq_ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">!&lt;/span>low_priority_queue.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="color:#f92672">=&lt;/span> low_priority_queue.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low_priority_queue.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="color:#f92672">=&lt;/span> queue.top().job;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(task) task();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>&lt;strong>拓展&lt;/strong>：&lt;/p></description><content type="html"><![CDATA[<p>C++中线程池一般使用队列（<code>std::queue</code>）配合外部的<code>std::condition_variable</code>，或者手动构建阻塞队列（BlockQueue）来设计。</p>
<p>而需要使用任务优先级的时候，一般使用大根堆/小根堆的优先级队列<code>std::priority_queue</code>来实现。</p>
<p>那么问题来了，在任务优先级比较不均的时候，怎么避免低优先级任务的长时间饥饿呢？</p>
<p>为了实现动态公平调度：</p>
<ul>
<li><strong>动态优先级老化（Aging）：优先级动态调整</strong>：任务在队列中等待时间越长，其有效优先级逐渐升高。</li>
<li><strong>双队列混合轮询</strong>：每处理一定数量的高优先级任务后，强制处理低优先级任务。</li>
</ul>
<p>首先抽象出一个<code>Task</code>用于记录任务的初始优先级和入队时间：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;chrono&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Task</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> base_priority; <span style="color:#75715e">// 初始优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>time_point enqueue_time;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> job;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算动态优先级（等待时间越长，优先级越高）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dynamic_priority</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> now <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> wait_time <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>duration_cast<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>seconds<span style="color:#f92672">&gt;</span>(now <span style="color:#f92672">-</span> enqueue_time).count();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> base_priority <span style="color:#f92672">+</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(wait_time <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.1</span>); <span style="color:#75715e">// 老化系数可调
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重载比较运算符（实际比较动态优先级）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">const</span> Task<span style="color:#f92672">&amp;</span> other) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>dynamic_priority() <span style="color:#f92672">&lt;</span> other.dynamic_priority(); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>整体的线程池类设计：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;condition_variable&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPool</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ThreadPool(size_t threads, size_t high_freq <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>) 
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> high_processing_count(<span style="color:#ae81ff">0</span>), high_freq_(high_freq) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> threads; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            workers.emplace_back([<span style="color:#66d9ef">this</span>] { worker_loop(); });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_task</span>(<span style="color:#66d9ef">int</span> priority, std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task) {
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(queue_mutex);
</span></span><span style="display:flex;"><span>            queue.emplace(Task{priority, std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now(), task});
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        condition.notify_one();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>ThreadPool() { <span style="color:#75715e">/* ... 省略资源回收代码 ... */</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>mutex queue_mutex;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>condition_variable condition;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>priority_queue<span style="color:#f92672">&lt;</span>Task<span style="color:#f92672">&gt;</span> queue; <span style="color:#75715e">// 主队列（动态优先级）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;&gt;</span> low_priority_queue; <span style="color:#75715e">// 辅助队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">&gt;</span> workers;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 轮询控制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> high_processing_count;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> high_freq_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">worker_loop</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(true) {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task;
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(queue_mutex);
</span></span><span style="display:flex;"><span>                condition.wait(lock, [<span style="color:#66d9ef">this</span>] { <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>queue.empty(); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 动态老化：每处理high_freq_个高优任务后强制处理低优
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">++</span>high_processing_count <span style="color:#f92672">%</span> high_freq_ <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> 
</span></span><span style="display:flex;"><span>                   <span style="color:#f92672">!</span>low_priority_queue.empty()) {
</span></span><span style="display:flex;"><span>                    task <span style="color:#f92672">=</span> low_priority_queue.front();
</span></span><span style="display:flex;"><span>                    low_priority_queue.pop();
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    task <span style="color:#f92672">=</span> queue.top().job;
</span></span><span style="display:flex;"><span>                    queue.pop();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(task) task();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<p><strong>拓展</strong>：</p>
<ul>
<li><strong>（处理超时）时间阈值兜底</strong>：可添加最大等待时间监控，对超时任务直接提升到最高优先级</li>
<li><strong>优先级区间划分</strong>：将任务分为<code>URGENT</code>/<code>HIGH</code>/<code>NORMAL</code>等级别，不同级别采用不同老化系数</li>
<li>根据系统负载动态调整<code>high_freq_</code>参数</li>
<li>根据队列负载动态增减线程，避免资源浪费（如 C++17 的 <code>std::jthread</code>）。</li>
</ul>
<p>线程池常见实现：<a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池 - Skykey的文章 - 知乎</a>。</p>
<p><a href="https://paul.pub/cpp-concurrency/">C++ 并发编程（从C++11到C++17）</a>。<br>
<a href="https://segmentfault.com/a/1190000002706259">货比三家：C++ 中的 task based 并发</a>。</p>
]]></content></item><item><title>计时器 timer 的设计</title><link>https://jekyulll.github.io/posts/cpp-%E8%AE%A1%E6%97%B6%E5%99%A8-timer-%E7%9A%84%E8%AE%BE%E8%AE%A1/</link><pubDate>Tue, 25 Feb 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E8%AE%A1%E6%97%B6%E5%99%A8-timer-%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid><description>&lt;p>三种经典算法：小顶堆、红黑树、时间轮。&lt;br>
Linux内核多采用时间轮处理中断定时器，而Nginx使用红黑树管理定时事件。&lt;/p>
&lt;ul>
&lt;li>&lt;em>Redis&lt;/em>: &lt;code>usUntilEarliestTimer()&lt;/code>&lt;/li>
&lt;li>&lt;em>Nginx&lt;/em>: &lt;code>ngx_event_find_timer()&lt;/code> 红黑树&lt;/li>
&lt;li>&lt;em>Skynet&lt;/em>:&lt;/li>
&lt;li>&lt;em>Netty&lt;/em>: 时间轮&lt;/li>
&lt;li>&lt;em>Libevent&lt;/em>: 最小堆&lt;/li>
&lt;li>&lt;em>Linux&lt;/em>: 时间轮&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>算法&lt;/strong>&lt;/th>
&lt;th>&lt;strong>插入&lt;/strong>&lt;/th>
&lt;th>&lt;strong>删除&lt;/strong>&lt;/th>
&lt;th>&lt;strong>触发效率&lt;/strong>&lt;/th>
&lt;th>&lt;strong>适用场景&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>小顶堆&lt;/td>
&lt;td>&lt;code>O(log n)&lt;/code>&lt;/td>
&lt;td>&lt;code>O(n)&lt;/code>&lt;/td>
&lt;td>高（仅处理堆顶）&lt;/td>
&lt;td>任务量大，无需频繁取消非堆顶任务&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>红黑树&lt;/td>
&lt;td>&lt;code>O(log n)&lt;/code>&lt;/td>
&lt;td>&lt;code>O(log n)&lt;/code>&lt;/td>
&lt;td>中（遍历有序数据）&lt;/td>
&lt;td>需动态增删改任务&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>时间轮&lt;/td>
&lt;td>&lt;code>O(1)&lt;/code>&lt;/td>
&lt;td>&lt;code>O(1)&lt;/code>&lt;/td>
&lt;td>高（批量处理槽）&lt;/td>
&lt;td>海量短周期任务，固定时间精度&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="一小顶堆">一、小顶堆&lt;/h3>
&lt;ul>
&lt;li>​优先级队列结构，堆顶元素始终是最小的（即最近的到期时间）。&lt;/li>
&lt;li>​插入和删除堆顶操作效率高，但删除任意节点效率低。&lt;/li>
&lt;/ul>
&lt;h4 id="复杂度">复杂度&lt;/h4>
&lt;ul>
&lt;li>插入：&lt;code>O(log n)&lt;/code>&lt;/li>
&lt;li>删除堆顶：&lt;code>O(log n)&lt;/code>&lt;/li>
&lt;li>删除任意节点：&lt;code>O(n)&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="适用场景">适用场景&lt;/h4>
&lt;ul>
&lt;li>定时任务数量大，且&lt;strong>频繁触发最近任务&lt;/strong>的场景。&lt;/li>
&lt;li>不适用于需要频繁取消或修改非堆顶任务的场景。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Timer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int64_t&lt;/span> expire; &lt;span style="color:#75715e">// 到期时间戳
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 小顶堆比较函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Compare&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">operator&lt;/span>()(&lt;span style="color:#66d9ef">const&lt;/span> Timer&lt;span style="color:#f92672">&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">const&lt;/span> Timer&lt;span style="color:#f92672">&amp;amp;&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a.expire &lt;span style="color:#f92672">&amp;gt;&lt;/span> b.expire;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Timer, std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Timer&lt;span style="color:#f92672">&amp;gt;&lt;/span>, Compare&lt;span style="color:#f92672">&amp;gt;&lt;/span> min_heap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 添加定时任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_timer&lt;/span>(&lt;span style="color:#66d9ef">int64_t&lt;/span> expire, std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min_heap.push({expire, task});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 驱动逻辑（在事件循环中调用）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">check_expire&lt;/span>(&lt;span style="color:#66d9ef">int64_t&lt;/span> current_time) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>min_heap.empty() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> min_heap.top().expire &lt;span style="color:#f92672">&amp;lt;=&lt;/span> current_time) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> task &lt;span style="color:#f92672">=&lt;/span> min_heap.top().task;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min_heap.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task(); &lt;span style="color:#75715e">// 执行任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="二红黑树">二、红黑树&lt;/h3>
&lt;ul>
&lt;li>使用&lt;strong>有序容器&lt;/strong>（如 &lt;code>std::multimap&lt;/code>）管理定时任务，键为到期时间。&lt;/li>
&lt;li>支持高效的&lt;strong>插入&lt;/strong>、&lt;strong>删除&lt;/strong>和&lt;strong>查找&lt;/strong>操作。&lt;/li>
&lt;/ul>
&lt;h4 id="复杂度-1">复杂度&lt;/h4>
&lt;ul>
&lt;li>插入、删除、查找：&lt;code>O(log n)&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="适用场景-1">适用场景&lt;/h4>
&lt;ul>
&lt;li>需要频繁&lt;strong>取消或修改定时任务&lt;/strong>的场景。&lt;/li>
&lt;li>适合时间跨度大或需要动态调整任务的场景。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Timer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> id; &lt;span style="color:#75715e">// 唯一标识符，用于取消任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>multimap&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int64_t&lt;/span>, Timer&lt;span style="color:#f92672">&amp;gt;&lt;/span> timer_map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 添加定时任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_timer&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> id, &lt;span style="color:#66d9ef">int64_t&lt;/span> expire, std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timer_map.insert({expire, {id, task}});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 取消定时任务（需遍历）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cancel_timer&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> timer_map.begin(); it &lt;span style="color:#f92672">!=&lt;/span> timer_map.end();) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>second.id &lt;span style="color:#f92672">==&lt;/span> id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it &lt;span style="color:#f92672">=&lt;/span> timer_map.erase(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>it;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 驱动逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">check_expire&lt;/span>(&lt;span style="color:#66d9ef">int64_t&lt;/span> current_time) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> timer_map.begin();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (it &lt;span style="color:#f92672">!=&lt;/span> timer_map.end() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first &lt;span style="color:#f92672">&amp;lt;=&lt;/span> current_time) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>second.task(); &lt;span style="color:#75715e">// 执行任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> timer_map.erase(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="三时间轮">三、时间轮&lt;/h3>
&lt;blockquote>
&lt;p>其实可以理解为一种变相的哈希表。&lt;/p></description><content type="html"><![CDATA[<p>三种经典算法：小顶堆、红黑树、时间轮。<br>
Linux内核多采用时间轮处理中断定时器，而Nginx使用红黑树管理定时事件。</p>
<ul>
<li><em>Redis</em>:		<code>usUntilEarliestTimer()</code></li>
<li><em>Nginx</em>: 		<code>ngx_event_find_timer()</code> 红黑树</li>
<li><em>Skynet</em>:</li>
<li><em>Netty</em>: 		时间轮</li>
<li><em>Libevent</em>: 	最小堆</li>
<li><em>Linux</em>: 		时间轮</li>
</ul>
<table>
  <thead>
      <tr>
          <th><strong>算法</strong></th>
          <th><strong>插入</strong></th>
          <th><strong>删除</strong></th>
          <th><strong>触发效率</strong></th>
          <th><strong>适用场景</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>小顶堆</td>
          <td><code>O(log n)</code></td>
          <td><code>O(n)</code></td>
          <td>高（仅处理堆顶）</td>
          <td>任务量大，无需频繁取消非堆顶任务</td>
      </tr>
      <tr>
          <td>红黑树</td>
          <td><code>O(log n)</code></td>
          <td><code>O(log n)</code></td>
          <td>中（遍历有序数据）</td>
          <td>需动态增删改任务</td>
      </tr>
      <tr>
          <td>时间轮</td>
          <td><code>O(1)</code></td>
          <td><code>O(1)</code></td>
          <td>高（批量处理槽）</td>
          <td>海量短周期任务，固定时间精度</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="一小顶堆">一、小顶堆</h3>
<ul>
<li>​优先级队列结构，堆顶元素始终是最小的（即最近的到期时间）。</li>
<li>​插入和删除堆顶操作效率高，但删除任意节点效率低。</li>
</ul>
<h4 id="复杂度">复杂度</h4>
<ul>
<li>插入：<code>O(log n)</code></li>
<li>删除堆顶：<code>O(log n)</code></li>
<li>删除任意节点：<code>O(n)</code></li>
</ul>
<h4 id="适用场景">适用场景</h4>
<ul>
<li>定时任务数量大，且<strong>频繁触发最近任务</strong>的场景。</li>
<li>不适用于需要频繁取消或修改非堆顶任务的场景。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Timer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int64_t</span> expire;  <span style="color:#75715e">// 到期时间戳
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 小顶堆比较函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Compare</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">const</span> Timer<span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> Timer<span style="color:#f92672">&amp;</span> b) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a.expire <span style="color:#f92672">&gt;</span> b.expire;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>priority_queue<span style="color:#f92672">&lt;</span>Timer, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Timer<span style="color:#f92672">&gt;</span>, Compare<span style="color:#f92672">&gt;</span> min_heap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 添加定时任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_timer</span>(<span style="color:#66d9ef">int64_t</span> expire, std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task) {
</span></span><span style="display:flex;"><span>    min_heap.push({expire, task});
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 驱动逻辑（在事件循环中调用）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">check_expire</span>(<span style="color:#66d9ef">int64_t</span> current_time) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>min_heap.empty() <span style="color:#f92672">&amp;&amp;</span> min_heap.top().expire <span style="color:#f92672">&lt;=</span> current_time) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> task <span style="color:#f92672">=</span> min_heap.top().task;
</span></span><span style="display:flex;"><span>        min_heap.pop();
</span></span><span style="display:flex;"><span>        task();  <span style="color:#75715e">// 执行任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="二红黑树">二、红黑树</h3>
<ul>
<li>使用<strong>有序容器</strong>（如 <code>std::multimap</code>）管理定时任务，键为到期时间。</li>
<li>支持高效的<strong>插入</strong>、<strong>删除</strong>和<strong>查找</strong>操作。</li>
</ul>
<h4 id="复杂度-1">复杂度</h4>
<ul>
<li>插入、删除、查找：<code>O(log n)</code></li>
</ul>
<h4 id="适用场景-1">适用场景</h4>
<ul>
<li>需要频繁<strong>取消或修改定时任务</strong>的场景。</li>
<li>适合时间跨度大或需要动态调整任务的场景。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Timer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> id;  <span style="color:#75715e">// 唯一标识符，用于取消任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>multimap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int64_t</span>, Timer<span style="color:#f92672">&gt;</span> timer_map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 添加定时任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_timer</span>(<span style="color:#66d9ef">int</span> id, <span style="color:#66d9ef">int64_t</span> expire, std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task) {
</span></span><span style="display:flex;"><span>    timer_map.insert({expire, {id, task}});
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 取消定时任务（需遍历）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cancel_timer</span>(<span style="color:#66d9ef">int</span> id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> timer_map.begin(); it <span style="color:#f92672">!=</span> timer_map.end();) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (it<span style="color:#f92672">-&gt;</span>second.id <span style="color:#f92672">==</span> id) {
</span></span><span style="display:flex;"><span>            it <span style="color:#f92672">=</span> timer_map.erase(it);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 驱动逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">check_expire</span>(<span style="color:#66d9ef">int64_t</span> current_time) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> timer_map.begin();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (it <span style="color:#f92672">!=</span> timer_map.end() <span style="color:#f92672">&amp;&amp;</span> it<span style="color:#f92672">-&gt;</span>first <span style="color:#f92672">&lt;=</span> current_time) {
</span></span><span style="display:flex;"><span>        it<span style="color:#f92672">-&gt;</span>second.task();  <span style="color:#75715e">// 执行任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        it <span style="color:#f92672">=</span> timer_map.erase(it);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="三时间轮">三、时间轮</h3>
<blockquote>
<p>其实可以理解为一种变相的哈希表。</p>
</blockquote>
<ul>
<li>将时间划分为多个槽（slot），每个槽对应一个时间间隔。</li>
<li>通过指针周期性移动触发当前槽的任务，<strong>插入和删除操作高效</strong>。</li>
</ul>
<p><strong>分层</strong>：<br>
如果时间轮的槽数有限，比如60个槽，每个槽代表1秒，那么最大只能处理60秒内的任务。超过这个时间的任务无法直接放置，所以需要分层来解决这个问题。</p>
<ul>
<li>比如，像钟表一样，有小时、分钟、秒的分层结构。当高层时间轮指针转动时，将任务降级到低层时间轮（类似钟表的进位机制）。</li>
</ul>
<h4 id="复杂度-2">复杂度</h4>
<ul>
<li>插入、删除：<code>O(1)</code>（理想情况下）</li>
</ul>
<h4 id="适用场景-2">适用场景</h4>
<ul>
<li><strong>海量定时任务</strong>且<strong>时间精度固定</strong>的场景（如游戏技能冷却）、超大规模定时任务​（例如百万级连接的心跳检测）。</li>
<li>不适用于时间跨度极大或需要高精度动态调整的场景。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 单层的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> WHEEL_SIZE <span style="color:#f92672">=</span> <span style="color:#ae81ff">60</span>;  <span style="color:#75715e">// 时间轮槽数（如60秒）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Timer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rotation;  <span style="color:#75715e">// 剩余轮数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span>Timer<span style="color:#f92672">&gt;&gt;</span> time_wheel(WHEEL_SIZE);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> current_slot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 添加定时任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_timer</span>(<span style="color:#66d9ef">int</span> interval, std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> slots <span style="color:#f92672">=</span> interval <span style="color:#f92672">%</span> WHEEL_SIZE;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rotation <span style="color:#f92672">=</span> interval <span style="color:#f92672">/</span> WHEEL_SIZE;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> (current_slot <span style="color:#f92672">+</span> slots) <span style="color:#f92672">%</span> WHEEL_SIZE;
</span></span><span style="display:flex;"><span>    time_wheel[pos].push_back({rotation, task});
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 驱动逻辑（每秒调用一次）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tick</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> tasks <span style="color:#f92672">=</span> time_wheel[current_slot];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> tasks.begin();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (it <span style="color:#f92672">!=</span> tasks.end()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (it<span style="color:#f92672">-&gt;</span>rotation <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            it<span style="color:#f92672">-&gt;</span>rotation<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            it<span style="color:#f92672">-&gt;</span>task();  <span style="color:#75715e">// 执行任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            it <span style="color:#f92672">=</span> tasks.erase(it);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    current_slot <span style="color:#f92672">=</span> (current_slot <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> WHEEL_SIZE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 三层时间轮
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 时间轮层级定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TimingWheel</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> wheel_size;    <span style="color:#75715e">// 槽数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> current_slot;  <span style="color:#75715e">// 当前槽位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> tick;          <span style="color:#75715e">// 时间精度（单位：秒）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;&gt;&gt;</span> slots;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TimingWheel(<span style="color:#66d9ef">int</span> size, <span style="color:#66d9ef">int</span> tick_unit) 
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> wheel_size(size), current_slot(<span style="color:#ae81ff">0</span>), tick(tick_unit), slots(size) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 三层时间轮：小时级、分钟级、秒级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TimingWheel <span style="color:#a6e22e">hour_wheel</span>(<span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">3600</span>);    <span style="color:#75715e">// 1小时/槽，总范围60小时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TimingWheel <span style="color:#a6e22e">minute_wheel</span>(<span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">60</span>);    <span style="color:#75715e">// 1分钟/槽，总范围60分钟
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TimingWheel <span style="color:#a6e22e">second_wheel</span>(<span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">1</span>);     <span style="color:#75715e">// 1秒/槽，总范围60秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 插入任务（假设时间单位为秒）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_task</span>(<span style="color:#66d9ef">int</span> interval, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;&amp;</span> task) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (interval <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">60</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 插入秒级时间轮
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> (second_wheel.current_slot <span style="color:#f92672">+</span> interval) <span style="color:#f92672">%</span> <span style="color:#ae81ff">60</span>;
</span></span><span style="display:flex;"><span>        second_wheel.slots[pos].push_back(task);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (interval <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3600</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 插入分钟级时间轮
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> (minute_wheel.current_slot <span style="color:#f92672">+</span> interval <span style="color:#f92672">/</span> <span style="color:#ae81ff">60</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">60</span>;
</span></span><span style="display:flex;"><span>        minute_wheel.slots[pos].push_back(task);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 插入小时级时间轮
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> (hour_wheel.current_slot <span style="color:#f92672">+</span> interval <span style="color:#f92672">/</span> <span style="color:#ae81ff">3600</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">60</span>;
</span></span><span style="display:flex;"><span>        hour_wheel.slots[pos].push_back(task);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 驱动逻辑（每秒调用一次）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tick</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理秒级时间轮
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> second_tasks <span style="color:#f92672">=</span> second_wheel.slots[second_wheel.current_slot];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> task : second_tasks) task();
</span></span><span style="display:flex;"><span>    second_tasks.clear();
</span></span><span style="display:flex;"><span>    second_wheel.current_slot <span style="color:#f92672">=</span> (second_wheel.current_slot <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">60</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 每分钟触发分钟级时间轮迁移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (second_wheel.current_slot <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> minute_tasks <span style="color:#f92672">=</span> minute_wheel.slots[minute_wheel.current_slot];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> task : minute_tasks) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 重新计算剩余时间并降级到秒级时间轮
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> remain_time <span style="color:#f92672">=</span> ...; <span style="color:#75715e">// 根据业务逻辑计算剩余秒数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            add_task(remain_time, task);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        minute_tasks.clear();
</span></span><span style="display:flex;"><span>        minute_wheel.current_slot <span style="color:#f92672">=</span> (minute_wheel.current_slot <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">60</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 每小时触发小时级时间轮迁移（类似逻辑）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><a href="https://blog.csdn.net/weixin_45203607/article/details/127095268">c语言-手撕多级时间轮定时器(纯手写)</a>。</p>
<hr>
<p><strong>拓展</strong>：</p>
<ul>
<li><u>redis延时队列如何实现？</u></li>
<li>非活跃的连接自动断开如何实现？</li>
<li>主从节点随机心跳检测如何实现？</li>
<li>下单后30分钟内未付款自动取消订单如何实现？</li>
</ul>
]]></content></item><item><title>如何让函数安全返回 std::string 的 c_str</title><link>https://jekyulll.github.io/posts/cpp-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAc_str%E7%9A%84%E5%B0%8F%E5%9D%91/</link><pubDate>Sun, 23 Feb 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAc_str%E7%9A%84%E5%B0%8F%E5%9D%91/</guid><description>&lt;p>观察以下这段明显错误的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">get_c&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> s.c_str();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;danger : %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, get_c());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>字符串&lt;code>s&lt;/code>是一个函数内部的临时对象，返回的&lt;code>const char*&lt;/code>实际上是一个指针。函数结束后&lt;code>s&lt;/code>会析构，而指针理论上会变成悬空的。&lt;br>
实际上正确打印出了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>danger : hello world
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(实际上只是因为该段内存没有被立刻覆盖，理论上是不安全的)&lt;/p>
&lt;p>查看一下汇编：&lt;/p>
&lt;ol>
&lt;li>构造 &lt;code>s&lt;/code>：&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code class="language-ass" data-lang="ass">leaq .LC0(%rip), %rcx ; 加载 &amp;#34;hello world&amp;#34; 地址到 %rcx
leaq -64(%rbp), %rax ; 栈上分配 s 的内存
call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_ ; 调用构造函数
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>字符串 &lt;code>&amp;quot;hello world&amp;quot;&lt;/code> 存储在 &lt;code>.rodata&lt;/code> 只读数据段（.LC0）。&lt;/li>
&lt;li>s 在栈上构造，通过 SSO 直接存储字符串内容。&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>获取 &lt;code>c_str()&lt;/code>：&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code class="language-ass" data-lang="ass">leaq -64(%rbp), %rax
call _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv@PLT
movq %rax, %rbx ; 将 c_str() 指针保存到 %rbx
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>析构 &lt;code>s&lt;/code>：&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code class="language-ass" data-lang="ass">leaq -64(%rbp), %rax
movq %rax, %rdi
call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@PLT ; 调用析构函数
&lt;/code>&lt;/pre>&lt;p>对于较短的字符串（如 &amp;ldquo;&lt;code>hello world&lt;/code>&amp;quot;），&lt;code>std::string&lt;/code> 可能使用 短字符串优化（SSO），将数据直接存储在对象内部的栈空间中，而非堆内存。&lt;br>
在&lt;code>get_c&lt;/code>中，&lt;code>s&lt;/code>是在栈上分配的，当函数返回时，栈空间可能未被其他数据覆盖，所以字符串内容仍然保留。此时调用printf，可能仍然能读取到原来的数据，但这只是巧合，属于未定义行为的表现。&lt;/p></description><content type="html"><![CDATA[<p>观察以下这段明显错误的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">get_c</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> s.c_str();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;danger : %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, get_c());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>字符串<code>s</code>是一个函数内部的临时对象，返回的<code>const char*</code>实际上是一个指针。函数结束后<code>s</code>会析构，而指针理论上会变成悬空的。<br>
实际上正确打印出了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>danger : hello world
</span></span></code></pre></div><p>(实际上只是因为该段内存没有被立刻覆盖，理论上是不安全的)</p>
<p>查看一下汇编：</p>
<ol>
<li>构造 <code>s</code>：</li>
</ol>
<pre tabindex="0"><code class="language-ass" data-lang="ass">leaq    .LC0(%rip), %rcx         ; 加载 &#34;hello world&#34; 地址到 %rcx
leaq    -64(%rbp), %rax          ; 栈上分配 s 的内存
call    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_ ; 调用构造函数
</code></pre><ul>
<li>字符串 <code>&quot;hello world&quot;</code> 存储在 <code>.rodata</code> 只读数据段（.LC0）。</li>
<li>s 在栈上构造，通过 SSO 直接存储字符串内容。</li>
</ul>
<ol start="2">
<li>获取 <code>c_str()</code>：</li>
</ol>
<pre tabindex="0"><code class="language-ass" data-lang="ass">leaq    -64(%rbp), %rax
call    _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv@PLT
movq    %rax, %rbx               ; 将 c_str() 指针保存到 %rbx
</code></pre><ol start="3">
<li>析构 <code>s</code>：</li>
</ol>
<pre tabindex="0"><code class="language-ass" data-lang="ass">leaq    -64(%rbp), %rax
movq    %rax, %rdi
call    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@PLT ; 调用析构函数
</code></pre><p>对于较短的字符串（如 &ldquo;<code>hello world</code>&quot;），<code>std::string</code> 可能使用 短字符串优化（SSO），将数据直接存储在对象内部的栈空间中，而非堆内存。<br>
在<code>get_c</code>中，<code>s</code>是在栈上分配的，当函数返回时，栈空间可能未被其他数据覆盖，所以字符串内容仍然保留。此时调用printf，可能仍然能读取到原来的数据，但这只是巧合，属于未定义行为的表现。</p>
<hr>
<h3 id="前情提要">前情提要</h3>
<p>写 webserver 的时候，设计了一个配置加载类用于加载配置文件。<br>
<em>eg</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[<span style="color:#a6e22e">redis</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">host</span> = <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">port</span> = <span style="color:#ae81ff">6379</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">password</span> = <span style="color:#e6db74">&#34;donotpanic&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">db</span> = <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>逻辑差不多长这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Config Config<span style="color:#f92672">::</span>_instance;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> Config<span style="color:#f92672">::</span>_configMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string Config<span style="color:#f92672">::</span>GetConfig(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> key) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> _configMap.find(key);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> _configMap.end()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    LOG_W(<span style="color:#e6db74">&#34;Config &#39;{}&#39; not found&#34;</span>, key);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我想让其返回<code>c_str</code>，直接返回是不行的。添加一个<code>static</code>的<code>string</code>作为cache即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> Config<span style="color:#f92672">::</span>GetConfig(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> key) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>string cache;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> _configMap.find(key);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> _configMap.end()) {
</span></span><span style="display:flex;"><span>        cache <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cache.c_str;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    LOG_W(<span style="color:#e6db74">&#34;Config &#39;{}&#39; not found&#34;</span>, key);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>Linux 内核中 C 语言的面向对象</title><link>https://jekyulll.github.io/posts/cpp-linux-%E5%86%85%E6%A0%B8%E4%B8%AD-c-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Fri, 21 Feb 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-linux-%E5%86%85%E6%A0%B8%E4%B8%AD-c-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>&lt;p>Linux 内核使用 &lt;strong>结构体&lt;/strong> 和 &lt;strong>函数指针&lt;/strong> 的组合模拟面向对象（OO）编程范式。&lt;/p>
&lt;hr>
&lt;h3 id="1-结构体封装数据与行为">1. &lt;strong>结构体封装数据与行为&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>数据抽象&lt;/strong>：将相关属性和状态封装在一个 &lt;code>struct&lt;/code> 中。&lt;/li>
&lt;li>&lt;strong>行为绑定&lt;/strong>：通过函数指针将操作绑定到结构体上，实现动态调用。&lt;/li>
&lt;/ul>
&lt;h4 id="示例struct-file_operations">示例：&lt;code>struct file_operations&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 定义文件操作的函数指针表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> file_operations {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ssize_t&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>read)(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">char&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">size_t&lt;/span>, &lt;span style="color:#66d9ef">loff_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ssize_t&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>write)(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">size_t&lt;/span>, &lt;span style="color:#66d9ef">loff_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 其他方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 具体文件系统的实现（如 ext4）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations ext4_fops &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .read &lt;span style="color:#f92672">=&lt;/span> ext4_read,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .write &lt;span style="color:#f92672">=&lt;/span> ext4_write,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 初始化其他方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 注册到 VFS 层时关联 fops
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> ...;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_fop &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>ext4_fops; &lt;span style="color:#75715e">// 绑定特定方法集
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="2-多态与继承">2. &lt;strong>多态与继承&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>父子结构体&lt;/strong>：子结构体嵌入父结构体以继承接口。&lt;/li>
&lt;li>&lt;strong>类型安全转换&lt;/strong>：通过 &lt;code>container_of&lt;/code> 宏从父指针获取子结构体。&lt;/li>
&lt;/ul>
&lt;h4 id="示例struct-kobject-与自定义对象">示例：&lt;code>struct kobject&lt;/code> 与自定义对象&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 父结构体（类似抽象基类）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> kobject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> kset &lt;span style="color:#f92672">*&lt;/span>kset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 公共方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>release)(&lt;span style="color:#66d9ef">struct&lt;/span> kobject &lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 子结构体（具体实现）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> my_device {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> kobject kobj; &lt;span style="color:#75715e">// 继承 kobject
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 实现父类的方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">my_device_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> kobject &lt;span style="color:#f92672">*&lt;/span>kobj) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> my_device &lt;span style="color:#f92672">*&lt;/span>dev &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">container_of&lt;/span>(kobj, &lt;span style="color:#66d9ef">struct&lt;/span> my_device, kobj);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 清理资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 初始化时绑定方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> my_device &lt;span style="color:#f92672">*&lt;/span>dev &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">kzalloc&lt;/span>(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>dev), GFP_KERNEL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>kobj.release &lt;span style="color:#f92672">=&lt;/span> my_device_release;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kobject_init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>dev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>kobj, &lt;span style="color:#f92672">&amp;amp;&lt;/span>my_device_ktype); &lt;span style="color:#75715e">// 注册类型
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="3-组合与接口分离">3. &lt;strong>组合与接口分离&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>模块化设计&lt;/strong>：通过组合而非继承复用代码。&lt;/li>
&lt;li>&lt;strong>统一接口&lt;/strong>：顶层结构体定义标准接口，底层实现差异化逻辑。&lt;/li>
&lt;/ul>
&lt;h4 id="示例struct-block_device">示例：&lt;code>struct block_device&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 通用块设备接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> block_device {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> gendisk &lt;span style="color:#f92672">*&lt;/span>disk;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通用方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>ioctl)(&lt;span style="color:#66d9ef">struct&lt;/span> block_device &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 桌面硬盘驱动实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> my_disk {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> block_device bdev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 私有数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 实现接口方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">my_disk_ioctl&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> block_device &lt;span style="color:#f92672">*&lt;/span>bdev, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> cmd, ...) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> my_disk &lt;span style="color:#f92672">*&lt;/span>disk &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">container_of&lt;/span>(bdev, &lt;span style="color:#66d9ef">struct&lt;/span> my_disk, bdev);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">custom_ioctl&lt;/span>(disk, cmd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="4-运行时多态">4. &lt;strong>运行时多态&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>函数指针作为虚函数表（vtable），根据对象类型动态调用不同实现。&lt;/li>
&lt;/ul>
&lt;h4 id="示例struct-net_device_ops">示例：&lt;code>struct net_device_ops&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 网络设备操作接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> net_device_ops {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>ndo_open)(&lt;span style="color:#66d9ef">struct&lt;/span> net_device &lt;span style="color:#f92672">*&lt;/span>dev);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>ndo_stop)(&lt;span style="color:#66d9ef">struct&lt;/span> net_device &lt;span style="color:#f92672">*&lt;/span>dev);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 以太网驱动实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> net_device_ops eth_ops &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ndo_open &lt;span style="color:#f92672">=&lt;/span> eth_open,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ndo_stop &lt;span style="color:#f92672">=&lt;/span> eth_stop,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 注册网络设备时绑定 ops
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> net_device &lt;span style="color:#f92672">*&lt;/span>netdev &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">alloc_etherdev&lt;/span>(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> priv_data));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>netdev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>netdev_ops &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>eth_ops;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="5-关键技巧">5. &lt;strong>关键技巧&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>自引用结构体&lt;/strong>：通过指针成员隐式关联自身。&lt;/li>
&lt;li>&lt;strong>宏简化代码&lt;/strong>：如 &lt;code>container_of&lt;/code> 用于反向查找结构体。&lt;/li>
&lt;li>&lt;strong>模块化加载&lt;/strong>：通过 &lt;code>struct module&lt;/code> 动态注册/卸载驱动。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>Linux 内核通过 &lt;strong>结构体+函数指针&lt;/strong> 实现了以下 OO 特性：&lt;/p></description><content type="html"><![CDATA[<p>Linux 内核使用 <strong>结构体</strong> 和 <strong>函数指针</strong> 的组合模拟面向对象（OO）编程范式。</p>
<hr>
<h3 id="1-结构体封装数据与行为">1. <strong>结构体封装数据与行为</strong></h3>
<ul>
<li><strong>数据抽象</strong>：将相关属性和状态封装在一个 <code>struct</code> 中。</li>
<li><strong>行为绑定</strong>：通过函数指针将操作绑定到结构体上，实现动态调用。</li>
</ul>
<h4 id="示例struct-file_operations">示例：<code>struct file_operations</code></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 定义文件操作的函数指针表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> file_operations {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ssize_t</span> (<span style="color:#f92672">*</span>read)(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>, <span style="color:#66d9ef">size_t</span>, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ssize_t</span> (<span style="color:#f92672">*</span>write)(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>, <span style="color:#66d9ef">size_t</span>, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... 其他方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 具体文件系统的实现（如 ext4）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> file_operations ext4_fops <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    .read <span style="color:#f92672">=</span> ext4_read,
</span></span><span style="display:flex;"><span>    .write <span style="color:#f92672">=</span> ext4_write,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... 初始化其他方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 注册到 VFS 层时关联 fops
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>inode <span style="color:#f92672">=</span> ...;
</span></span><span style="display:flex;"><span>inode<span style="color:#f92672">-&gt;</span>i_fop <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>ext4_fops; <span style="color:#75715e">// 绑定特定方法集
</span></span></span></code></pre></div><hr>
<h3 id="2-多态与继承">2. <strong>多态与继承</strong></h3>
<ul>
<li><strong>父子结构体</strong>：子结构体嵌入父结构体以继承接口。</li>
<li><strong>类型安全转换</strong>：通过 <code>container_of</code> 宏从父指针获取子结构体。</li>
</ul>
<h4 id="示例struct-kobject-与自定义对象">示例：<code>struct kobject</code> 与自定义对象</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 父结构体（类似抽象基类）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> kobject {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> kset <span style="color:#f92672">*</span>kset;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 公共方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>release)(<span style="color:#66d9ef">struct</span> kobject <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 子结构体（具体实现）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> my_device {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> kobject kobj; <span style="color:#75715e">// 继承 kobject
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 实现父类的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">my_device_release</span>(<span style="color:#66d9ef">struct</span> kobject <span style="color:#f92672">*</span>kobj) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> my_device <span style="color:#f92672">*</span>dev <span style="color:#f92672">=</span> <span style="color:#a6e22e">container_of</span>(kobj, <span style="color:#66d9ef">struct</span> my_device, kobj);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 清理资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化时绑定方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> my_device <span style="color:#f92672">*</span>dev <span style="color:#f92672">=</span> <span style="color:#a6e22e">kzalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>dev), GFP_KERNEL);
</span></span><span style="display:flex;"><span>dev<span style="color:#f92672">-&gt;</span>kobj.release <span style="color:#f92672">=</span> my_device_release;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kobject_init</span>(<span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>kobj, <span style="color:#f92672">&amp;</span>my_device_ktype); <span style="color:#75715e">// 注册类型
</span></span></span></code></pre></div><hr>
<h3 id="3-组合与接口分离">3. <strong>组合与接口分离</strong></h3>
<ul>
<li><strong>模块化设计</strong>：通过组合而非继承复用代码。</li>
<li><strong>统一接口</strong>：顶层结构体定义标准接口，底层实现差异化逻辑。</li>
</ul>
<h4 id="示例struct-block_device">示例：<code>struct block_device</code></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 通用块设备接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> block_device {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> gendisk <span style="color:#f92672">*</span>disk;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 通用方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>ioctl)(<span style="color:#66d9ef">struct</span> block_device <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 桌面硬盘驱动实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> my_disk {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> block_device bdev;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 私有数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 实现接口方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">my_disk_ioctl</span>(<span style="color:#66d9ef">struct</span> block_device <span style="color:#f92672">*</span>bdev, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, ...) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> my_disk <span style="color:#f92672">*</span>disk <span style="color:#f92672">=</span> <span style="color:#a6e22e">container_of</span>(bdev, <span style="color:#66d9ef">struct</span> my_disk, bdev);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">custom_ioctl</span>(disk, cmd);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="4-运行时多态">4. <strong>运行时多态</strong></h3>
<ul>
<li>函数指针作为虚函数表（vtable），根据对象类型动态调用不同实现。</li>
</ul>
<h4 id="示例struct-net_device_ops">示例：<code>struct net_device_ops</code></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 网络设备操作接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> net_device_ops {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>ndo_open)(<span style="color:#66d9ef">struct</span> net_device <span style="color:#f92672">*</span>dev);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>ndo_stop)(<span style="color:#66d9ef">struct</span> net_device <span style="color:#f92672">*</span>dev);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 以太网驱动实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> net_device_ops eth_ops <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    .ndo_open <span style="color:#f92672">=</span> eth_open,
</span></span><span style="display:flex;"><span>    .ndo_stop <span style="color:#f92672">=</span> eth_stop,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 注册网络设备时绑定 ops
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> net_device <span style="color:#f92672">*</span>netdev <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_etherdev</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> priv_data));
</span></span><span style="display:flex;"><span>netdev<span style="color:#f92672">-&gt;</span>netdev_ops <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>eth_ops;
</span></span></code></pre></div><hr>
<h3 id="5-关键技巧">5. <strong>关键技巧</strong></h3>
<ul>
<li><strong>自引用结构体</strong>：通过指针成员隐式关联自身。</li>
<li><strong>宏简化代码</strong>：如 <code>container_of</code> 用于反向查找结构体。</li>
<li><strong>模块化加载</strong>：通过 <code>struct module</code> 动态注册/卸载驱动。</li>
</ul>
<hr>
<h3 id="总结">总结</h3>
<p>Linux 内核通过 <strong>结构体+函数指针</strong> 实现了以下 OO 特性：</p>
<ul>
<li><strong>封装</strong>：隐藏内部细节（如 <code>struct inode</code> 的实现）。</li>
<li><strong>多态</strong>：同一接口（如 <code>read()</code>）适配多种设备。</li>
<li><strong>继承</strong>：子结构体复用父结构体的方法。</li>
<li><strong>动态绑定</strong>：运行时选择具体函数实现。</li>
</ul>
<p>这种设计平衡了 C 语言的静态特性与内核对灵活性的需求，成为高效且可扩展的系统核心。</p>
<hr>
<p><a href="https://blog.csdn.net/u011029104/article/details/136190755">container_of函数详解</a>。</p>
<p>主要作用就是根据结构体中的已知的成员变量的地址，来寻求该结构体的首地址。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * container_of - cast a member of a structure out to the containing structure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @ptr:    the pointer to the member.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @type:   the type of the container struct this is embedded in.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @member: the name of the member within the struct.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * WARNING: any const qualifier of @ptr is lost.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#define container_of(ptr, type, member) ({              \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     void *__mptr = (void *)(ptr);                   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) ||   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">               __same_type(*(ptr), void),            \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">               &#34;pointer type mismatch in container_of()&#34;);   \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     ((type *)(__mptr - offsetof(type, member))); })
</span></span></span></code></pre></div>]]></content></item><item><title>web 访问认证机制</title><link>https://jekyulll.github.io/posts/web-web-%E8%AE%BF%E9%97%AE%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 17 Feb 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-web-%E8%AE%BF%E9%97%AE%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</guid><description>&lt;p>&lt;a href="https://time.geekbang.org/column/article/398410">25 | 认证机制：应用程序如何进行访问认证？&lt;/a>讲得非常好，图文结合。&lt;/p>
&lt;p>&lt;strong>IAM&lt;/strong>：身份识别与访问管理（Identity and Access Management）。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>认证&lt;/strong>（Authentication，英文缩写 &lt;strong>authn&lt;/strong>）：用来验证某个用户是否具有访问系统的权限。如果认证通过，该用户就可以访问系统，从而创建、修改、删除、查询平台支持的资源。&lt;/li>
&lt;li>&lt;strong>授权&lt;/strong>（Authorization，英文缩写 &lt;strong>authz&lt;/strong>）：用来验证某个用户是否具有访问某个资源的权限，如果授权通过，该用户就能对资源做增删改查等操作。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>认证证明了你是谁，授权决定了你能做什么。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;u>四种基本的认证方式：&lt;em>Basic&lt;/em>、&lt;em>Digest&lt;/em>、&lt;em>OAuth&lt;/em>、&lt;em>Bearer&lt;/em>&lt;/u>。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Basic&lt;/strong> 基础认证&lt;br>
Basic 认证（基础认证），是最简单的认证方式。它简单地将用户名:密码进行 &lt;code>base64&lt;/code> 编码后，放到 HTTP Authorization Header 中。HTTP 请求到达后端服务后，后端服务会解析出 Authorization Header 中的 &lt;code>base64&lt;/code> 字符串，解码获取用户名和密码，并将用户名和密码跟数据库中记录的值进行比较，如果匹配则认证通过。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Digest&lt;/strong> 摘要认证&lt;br>
Digest 认证（摘要认证）与基本认证兼容，但修复了基本认证的严重缺陷。&lt;br>
Digest 具有如下特点：&lt;/p>
&lt;ul>
&lt;li>绝不会用明文方式在网络上发送密码。&lt;/li>
&lt;li>可以有效防止恶意用户进行重放攻击。&lt;/li>
&lt;li>可以有选择地防止对报文内容的篡改。
四步：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>客户端请求服务端的资源。&lt;/li>
&lt;li>在客户端能够证明它知道密码从而确认其身份之前，服务端认证失败，返回&lt;code>401 Unauthorized&lt;/code>，并返回&lt;code>WWW-Authenticate&lt;/code>头，里面包含认证需要的信息。&lt;/li>
&lt;li>客户端根据&lt;code>WWW-Authenticate&lt;/code>头中的信息，选择加密算法，并使用密码随机数 &lt;code>nonce&lt;/code>(防止&lt;em>重放攻击&lt;/em>)，计算出密码摘要 &lt;code>response&lt;/code>，并再次请求服务端。&lt;/li>
&lt;li>服务器将客户端提供的密码摘要与服务器内部计算出的摘要进行对比。如果匹配，就说明客户端知道密码，认证通过，并返回一些与授权会话相关的附加信息，放在 &lt;code>Authorization-Info&lt;/code> 中。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>OAuth&lt;/strong> 开放授权&lt;br>
OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一 Web 服务上存储的私密资源（例如照片、视频、音频等），而无需将用户名和密码提供给第三方应用。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>OAuth2.0 一共分为四种授权方式，分别为&lt;em>密码式&lt;/em>、&lt;em>隐藏式&lt;/em>、&lt;em>凭借式&lt;/em>和&lt;em>授权码&lt;/em>模式。&lt;/p>
&lt;/blockquote>
&lt;ol start="4">
&lt;li>&lt;strong>Bearer&lt;/strong> 令牌认证&lt;br>
Bearer 认证是一种 HTTP 身份验证方法。Bearer 认证的核心是 &lt;code>bearer token&lt;/code>。&lt;code>bearer token&lt;/code> 是一个加密字符串，通常由服务端根据密钥生成。客户端在请求服务端时，必须在请求头中包含&lt;code>Authorization: Bearer&lt;/code> 。服务端收到请求后，解析出&lt;code>&amp;lt;token&amp;gt;&lt;/code>，并校验&lt;code>&amp;lt;token&amp;gt;&lt;/code>的合法性，如果校验通过，则认证通过。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>跟基本认证一样，Bearer 认证需要配合 HTTPS 一起使用，来保证认证安全性。&lt;/p></description><content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/article/398410">25 | 认证机制：应用程序如何进行访问认证？</a>讲得非常好，图文结合。</p>
<p><strong>IAM</strong>：身份识别与访问管理（Identity and Access Management）。</p>
<ul>
<li><strong>认证</strong>（Authentication，英文缩写 <strong>authn</strong>）：用来验证某个用户是否具有访问系统的权限。如果认证通过，该用户就可以访问系统，从而创建、修改、删除、查询平台支持的资源。</li>
<li><strong>授权</strong>（Authorization，英文缩写 <strong>authz</strong>）：用来验证某个用户是否具有访问某个资源的权限，如果授权通过，该用户就能对资源做增删改查等操作。</li>
</ul>
<blockquote>
<p>认证证明了你是谁，授权决定了你能做什么。</p>
</blockquote>
<p><u>四种基本的认证方式：<em>Basic</em>、<em>Digest</em>、<em>OAuth</em>、<em>Bearer</em></u>。</p>
<ol>
<li>
<p><strong>Basic</strong> 基础认证<br>
Basic 认证（基础认证），是最简单的认证方式。它简单地将用户名:密码进行 <code>base64</code> 编码后，放到 HTTP Authorization Header 中。HTTP 请求到达后端服务后，后端服务会解析出 Authorization Header 中的 <code>base64</code> 字符串，解码获取用户名和密码，并将用户名和密码跟数据库中记录的值进行比较，如果匹配则认证通过。</p>
</li>
<li>
<p><strong>Digest</strong> 摘要认证<br>
Digest 认证（摘要认证）与基本认证兼容，但修复了基本认证的严重缺陷。<br>
Digest 具有如下特点：</p>
<ul>
<li>绝不会用明文方式在网络上发送密码。</li>
<li>可以有效防止恶意用户进行重放攻击。</li>
<li>可以有选择地防止对报文内容的篡改。
四步：</li>
</ul>
<ol>
<li>客户端请求服务端的资源。</li>
<li>在客户端能够证明它知道密码从而确认其身份之前，服务端认证失败，返回<code>401 Unauthorized</code>，并返回<code>WWW-Authenticate</code>头，里面包含认证需要的信息。</li>
<li>客户端根据<code>WWW-Authenticate</code>头中的信息，选择加密算法，并使用密码随机数 <code>nonce</code>(防止<em>重放攻击</em>)，计算出密码摘要 <code>response</code>，并再次请求服务端。</li>
<li>服务器将客户端提供的密码摘要与服务器内部计算出的摘要进行对比。如果匹配，就说明客户端知道密码，认证通过，并返回一些与授权会话相关的附加信息，放在 <code>Authorization-Info</code> 中。</li>
</ol>
</li>
<li>
<p><strong>OAuth</strong> 开放授权<br>
OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一 Web 服务上存储的私密资源（例如照片、视频、音频等），而无需将用户名和密码提供给第三方应用。</p>
</li>
</ol>
<blockquote>
<p>OAuth2.0 一共分为四种授权方式，分别为<em>密码式</em>、<em>隐藏式</em>、<em>凭借式</em>和<em>授权码</em>模式。</p>
</blockquote>
<ol start="4">
<li><strong>Bearer</strong> 令牌认证<br>
Bearer 认证是一种 HTTP 身份验证方法。Bearer 认证的核心是 <code>bearer token</code>。<code>bearer token</code> 是一个加密字符串，通常由服务端根据密钥生成。客户端在请求服务端时，必须在请求头中包含<code>Authorization: Bearer</code> 。服务端收到请求后，解析出<code>&lt;token&gt;</code>，并校验<code>&lt;token&gt;</code>的合法性，如果校验通过，则认证通过。</li>
</ol>
<blockquote>
<p>跟基本认证一样，Bearer 认证需要配合 HTTPS 一起使用，来保证认证安全性。</p>
</blockquote>
<h6 id="jwt">JWT</h6>
<p>JSON Web Token（JWT）是 Bearer Token 的一个具体实现，由 JSON 数据格式组成，通过 HASH 散列算法生成一个字符串。该字符串可以用来进行授权和信息交换。</p>
<ol>
<li>客户端使用用户名和密码请求登录。</li>
<li>服务端收到请求后，会去验证用户名和密码。如果用户名和密码跟数据库记录不一致，则验证失败；如果一致则验证通过，服务端会签发一个 Token 返回给客户端。</li>
<li>客户端收到请求后会将 Token 缓存起来，比如放在浏览器 Cookie 中或者 LocalStorage 中，之后每次请求都会携带该 Token。</li>
<li>服务端收到请求后，会验证请求中的 Token，验证通过则进行业务逻辑处理，处理完后返回处理后的结果。</li>
</ol>
<p>JWT 由三部分组成，分别是 <code>Header</code>、<code>Payload</code> 和 <code>Signature</code>。</p>
<ul>
<li><code>Header</code>：包含了 Token 的类型、Token 使用的加密算法。在某些场景下，你还可以添加 kid 字段，用来标识一个密钥 ID。</li>
<li><code>Payload</code>：Payload 中携带 Token 的具体内容，由 JWT 标准中注册的声明、公共的声明和私有的声明三部分组成。</li>
<li><code>Signature</code>：Signature 是 Token 的签名部分，程序通过验证 Signature 是否合法，来决定认证是否通过。</li>
</ul>
<p><em>问</em>：JWT的Token存储在哪里比较好？<br>
cookie中比较好，可由服务端保存，localstorage在纯前端，中很容易泄露。<br>
服务器可以将 cookie 设置为 HTTP - Only，无法被 JavaScript 脚本访问。<br>
localStorage 完全处于前端控制之下，可以被同源的 JavaScript 代码访问和修改。</p>
<p>(Basic 认证用在前端登陆的场景，Bearer 认证用在调用后端 API 服务的场景下。)</p>
]]></content></item><item><title>扫描线算法计算区间重叠</title><link>https://jekyulll.github.io/posts/alg-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/</link><pubDate>Sat, 15 Feb 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/alg-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/</guid><description>&lt;p>题目来源：&lt;a href="https://www.marscode.cn/practice/jn1075jrp7j47d?problem_id=7424418560930611244">Marscode&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>小C和小U有一个从&lt;code>0&lt;/code>开始的数组&lt;code>nums&lt;/code>，以及一个非负整数&lt;code>k&lt;/code>。每次操作中，小C可以选择一个尚未选择的下标&lt;code>i&lt;/code>（范围在 &lt;code>[0, nums.length - 1]&lt;/code>），然后将&lt;code>nums[i]&lt;/code>替换为&lt;code>[nums[i] - k, nums[i] + k]&lt;/code>之间的任意整数（包含边界）。&lt;br>
在应用任意次数的操作后，返回数组&lt;code>nums&lt;/code>可能达到的最大分数。数组的分数被定义为数组中最多重复的元素个数。注意，每个下标只能被操作一次。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h3 id="暴力解超时-onk">暴力解（超时） &lt;code>O(n²k)&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">solution&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maxCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 至少有一个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 遍历每个数作为可能的目标值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以nums[i]为中心，考虑范围[nums[i]-k, nums[i]+k]内的所有可能值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> nums[i]&lt;span style="color:#f92672">-&lt;/span>k; target &lt;span style="color:#f92672">&amp;lt;=&lt;/span> nums[i]&lt;span style="color:#f92672">+&lt;/span>k; target&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 检查每个位置的数是否能变成target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (abs(nums[j] &lt;span style="color:#f92672">-&lt;/span> target) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxCount &lt;span style="color:#f92672">=&lt;/span> max(maxCount, count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> maxCount;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="优化暴力解-on">优化暴力解 &lt;code>O(n²)&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">solution&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maxCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 只需要考虑将某些数变成数组中已有的数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> nums[i]; &lt;span style="color:#75715e">// 以当前数作为目标值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (abs(nums[j] &lt;span style="color:#f92672">-&lt;/span> target) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxCount &lt;span style="color:#f92672">=&lt;/span> max(maxCount, count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> maxCount;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="扫描线算法-onlogn">扫描线算法 &lt;code>O(nlogn)&lt;/code>&lt;/h3>
&lt;p>像是在数某个时刻有多少个区间重叠。一条水平线从左向右扫过，每个起点让重叠数+1，每个终点让重叠数-1，过程中的最大重叠数就是答案。&lt;/p></description><content type="html"><![CDATA[<p>题目来源：<a href="https://www.marscode.cn/practice/jn1075jrp7j47d?problem_id=7424418560930611244">Marscode</a>。</p>
<blockquote>
<p>小C和小U有一个从<code>0</code>开始的数组<code>nums</code>，以及一个非负整数<code>k</code>。每次操作中，小C可以选择一个尚未选择的下标<code>i</code>（范围在 <code>[0, nums.length - 1]</code>），然后将<code>nums[i]</code>替换为<code>[nums[i] - k, nums[i] + k]</code>之间的任意整数（包含边界）。<br>
在应用任意次数的操作后，返回数组<code>nums</code>可能达到的最大分数。数组的分数被定义为数组中最多重复的元素个数。注意，每个下标只能被操作一次。</p>
</blockquote>
<hr>
<h3 id="暴力解超时-onk">暴力解（超时） <code>O(n²k)</code></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">solution</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> nums.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// 至少有一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历每个数作为可能的目标值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 以nums[i]为中心，考虑范围[nums[i]-k, nums[i]+k]内的所有可能值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> target <span style="color:#f92672">=</span> nums[i]<span style="color:#f92672">-</span>k; target <span style="color:#f92672">&lt;=</span> nums[i]<span style="color:#f92672">+</span>k; target<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 检查每个位置的数是否能变成target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (abs(nums[j] <span style="color:#f92672">-</span> target) <span style="color:#f92672">&lt;=</span> k) {
</span></span><span style="display:flex;"><span>                    count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            maxCount <span style="color:#f92672">=</span> max(maxCount, count);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> maxCount;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="优化暴力解-on">优化暴力解 <code>O(n²)</code></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">solution</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> nums.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只需要考虑将某些数变成数组中已有的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> target <span style="color:#f92672">=</span> nums[i];  <span style="color:#75715e">// 以当前数作为目标值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (abs(nums[j] <span style="color:#f92672">-</span> target) <span style="color:#f92672">&lt;=</span> k) {
</span></span><span style="display:flex;"><span>                count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        maxCount <span style="color:#f92672">=</span> max(maxCount, count);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> maxCount;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="扫描线算法-onlogn">扫描线算法 <code>O(nlogn)</code></h3>
<p>像是在数某个时刻有多少个区间重叠。一条水平线从左向右扫过，每个起点让重叠数+1，每个终点让重叠数-1，过程中的最大重叠数就是答案。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">solution</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> nums.size();
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> ranges;  <span style="color:#75715e">// 存储每个数可以变化的范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算每个数可以变化的范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ranges.push_back({nums[i] <span style="color:#f92672">-</span> k, <span style="color:#ae81ff">1</span>});  <span style="color:#75715e">// 范围起点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ranges.push_back({nums[i] <span style="color:#f92672">+</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>});  <span style="color:#75715e">// 范围终点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 按照位置排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sort(ranges.begin(), ranges.end());
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 扫描线算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> range : ranges) {
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> range.second;
</span></span><span style="display:flex;"><span>        maxCount <span style="color:#f92672">=</span> max(maxCount, count);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> maxCount;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><em>注</em>：<br>
<code>std::sort</code> 对 <code>std::pair</code> 的默认排序规则是：首先比较 <code>first</code> 成员，如果 <code>first</code> 相等，则比较 <code>second</code> 成员。</p>
<hr>
<p>完整代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">solution</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> nums.size();
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> ranges;  <span style="color:#75715e">// 存储每个数可以变化的范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算每个数可以变化的范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ranges.push_back({nums[i] <span style="color:#f92672">-</span> k, <span style="color:#ae81ff">1</span>});  <span style="color:#75715e">// 范围起点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ranges.push_back({nums[i] <span style="color:#f92672">+</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>});  <span style="color:#75715e">// 范围终点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 按照位置排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sort(ranges.begin(), ranges.end());
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 扫描线算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> range : ranges) {
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> range.second;
</span></span><span style="display:flex;"><span>        maxCount <span style="color:#f92672">=</span> max(maxCount, count);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> maxCount;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums1 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> (solution(nums1, <span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums2 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>};
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> (solution(nums2, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums3 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>};
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> (solution(nums3, <span style="color:#ae81ff">3</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>C++ 同一进程的线程之间共享哪些资源？</title><link>https://jekyulll.github.io/posts/cpp-c++-%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</link><pubDate>Sat, 08 Feb 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</guid><description>&lt;p>同一进程内的线程共享的资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>代码段&lt;/strong>：存放程序的可执行指令，所有线程共享相同的代码段，因此任何线程都可以执行程序中的函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据段&lt;/strong>：包含全局变量和静态变量，这些变量在程序运行期间只有一个实例，所有线程都可以访问和修改它们。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>堆&lt;/strong>：用于动态内存分配，线程可以在堆上分配和释放内存，因此堆上的数据对所有线程可见。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>打开的文件&lt;/strong>：如果程序在运行过程中打开了文件，文件描述符等信息在进程地址空间中保存，所有线程都可以访问这些打开的文件。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>每个线程的私有资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>栈&lt;/strong>：每个线程都有自己的栈空间，用于存储函数的局部变量、返回地址等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>寄存器&lt;/strong>：线程在执行过程中使用的寄存器集是独立的，包括程序计数器（PC）等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>线程局部存储（Thread Local Storage）&lt;/strong>：存放线程私有的全局变量，即使变量名相同，不同线程访问的也是各自独立的副本。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;em>注意&lt;/em>：虽然栈是线程私有的，但由于线程间没有严格的内存隔离机制，一个线程可以通过指针访问和修改另一个线程的栈数据。&lt;/p></description><content type="html"><![CDATA[<p>同一进程内的线程共享的资源：</p>
<ul>
<li>
<p><strong>代码段</strong>：存放程序的可执行指令，所有线程共享相同的代码段，因此任何线程都可以执行程序中的函数。</p>
</li>
<li>
<p><strong>数据段</strong>：包含全局变量和静态变量，这些变量在程序运行期间只有一个实例，所有线程都可以访问和修改它们。</p>
</li>
<li>
<p><strong>堆</strong>：用于动态内存分配，线程可以在堆上分配和释放内存，因此堆上的数据对所有线程可见。</p>
</li>
<li>
<p><strong>打开的文件</strong>：如果程序在运行过程中打开了文件，文件描述符等信息在进程地址空间中保存，所有线程都可以访问这些打开的文件。</p>
</li>
</ul>
<p>每个线程的私有资源：</p>
<ul>
<li>
<p><strong>栈</strong>：每个线程都有自己的栈空间，用于存储函数的局部变量、返回地址等。</p>
</li>
<li>
<p><strong>寄存器</strong>：线程在执行过程中使用的寄存器集是独立的，包括程序计数器（PC）等。</p>
</li>
<li>
<p><strong>线程局部存储（Thread Local Storage）</strong>：存放线程私有的全局变量，即使变量名相同，不同线程访问的也是各自独立的副本。</p>
</li>
</ul>
<p><em>注意</em>：虽然栈是线程私有的，但由于线程间没有严格的内存隔离机制，一个线程可以通过指针访问和修改另一个线程的栈数据。</p>
]]></content></item><item><title>运行时是把整个动态库都加载到内存中吗？</title><link>https://jekyulll.github.io/posts/cpp-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%98%AF%E6%8A%8A%E6%95%B4%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93%E9%83%BD%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%90%97/</link><pubDate>Sat, 08 Feb 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%98%AF%E6%8A%8A%E6%95%B4%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93%E9%83%BD%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%90%97/</guid><description>&lt;p>在 C++ 中，动态库（如 &lt;code>.dll&lt;/code> 或 &lt;code>.so&lt;/code> 文件）在加载时，操作系统会将整个库文件映射到进程的地址空间中。
&lt;u>具体的函数和数据只有在被实际使用时才会被加载到内存中。&lt;/u>
(动态库作为一个整体被映射，但其中的各个部分仅在需要时才占用物理内存。)&lt;/p>
&lt;p>另外：&lt;br>
C++ 提供了&lt;strong>显式运行时链接&lt;/strong>的机制，程序可以在运行时根据需要动态加载库的特定部分。(&lt;code>dlopen&lt;/code>、&lt;code>dlsym&lt;/code> 等函数)程序可以在运行时按需加载特定的符号（函数或变量）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;dlfcn.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">dlopen&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>filename, &lt;span style="color:#66d9ef">int&lt;/span> flag);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>flag&lt;/code>：指定加载选项：
- &lt;code>RTLD_LAZY&lt;/code>：延迟解析符号，即在实际使用时才解析。&lt;br>
- &lt;code>RTLD_NOW&lt;/code>：立即解析所有未定义的符号。如果无法解析，&lt;code>dlopen&lt;/code> 将返回 &lt;code>NULL&lt;/code>。&lt;br>
- &lt;code>RTLD_GLOBAL&lt;/code>：使加载的库中的符号在后续加载的其他库中可见。&lt;br>
- &lt;code>RTLD_LOCAL&lt;/code>：与 &lt;code>RTLD_GLOBAL&lt;/code> 相反，加载的库中的符号对后续加载的库不可见（这是默认行为）。&lt;/p></description><content type="html"><![CDATA[<p>在 C++ 中，动态库（如 <code>.dll</code> 或 <code>.so</code> 文件）在加载时，操作系统会将整个库文件映射到进程的地址空间中。
<u>具体的函数和数据只有在被实际使用时才会被加载到内存中。</u>
(动态库作为一个整体被映射，但其中的各个部分仅在需要时才占用物理内存。)</p>
<p>另外：<br>
C++ 提供了<strong>显式运行时链接</strong>的机制，程序可以在运行时根据需要动态加载库的特定部分。(<code>dlopen</code>、<code>dlsym</code> 等函数)程序可以在运行时按需加载特定的符号（函数或变量）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;dlfcn.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">dlopen</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">int</span> flag);
</span></span></code></pre></div><p><code>flag</code>：指定加载选项：
- <code>RTLD_LAZY</code>：延迟解析符号，即在实际使用时才解析。<br>
- <code>RTLD_NOW</code>：立即解析所有未定义的符号。如果无法解析，<code>dlopen</code> 将返回 <code>NULL</code>。<br>
- <code>RTLD_GLOBAL</code>：使加载的库中的符号在后续加载的其他库中可见。<br>
- <code>RTLD_LOCAL</code>：与 <code>RTLD_GLOBAL</code> 相反，加载的库中的符号对后续加载的库不可见（这是默认行为）。</p>
]]></content></item><item><title>检查字符串是否是另一个的子串</title><link>https://jekyulll.github.io/posts/cpp-%E6%A3%80%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9A%84%E5%AD%90%E4%B8%B2/</link><pubDate>Wed, 29 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E6%A3%80%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9A%84%E5%AD%90%E4%B8%B2/</guid><description>&lt;h2 id="常见-cc-api">常见 C/C++ API&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;code>std::string&lt;/code>的 &lt;code>string::find&lt;/code> 成员函数&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isSubstring&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> mainStr, &lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> subStr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mainStr.find(subStr) &lt;span style="color:#f92672">!=&lt;/span> string&lt;span style="color:#f92672">::&lt;/span>npos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>大多数标准库的 &lt;code>strstr&lt;/code>（如Glibc）和 &lt;code>string::find&lt;/code>（如MSVC、libc++）已针对子串搜索优化。&lt;br>
实现中可能直接调用 &lt;code>memmem&lt;/code> 或 &lt;code>strstr&lt;/code>，性能与 &lt;code>strstr&lt;/code> 相当。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>C标准库的 &lt;code>strstr&lt;/code> 函数&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isSubstring&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> mainStr, &lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> subStr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> strstr(mainStr.c_str(), subStr.c_str()) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要将 &lt;code>std::string&lt;/code> 转换为C风格字符串，可能引入额外开销。&lt;/p>
&lt;blockquote>
&lt;p>Glibc的 &lt;code>strstr&lt;/code> 使用Two-Way算法，适合长文本和模式。时间复杂度接近&lt;code>O(n)&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>STL &lt;code>std::search&lt;/code>&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isSubstring&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> mainStr, &lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> subStr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>search(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mainStr.begin(), mainStr.end(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> subStr.begin(), subStr.end()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) &lt;span style="color:#f92672">!=&lt;/span> mainStr.end();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="算法">算法&lt;/h2>
&lt;h3 id="1-暴力法brute-force">&lt;strong>1. 暴力法（Brute Force）&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isSubstringBruteForce&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> mainStr, &lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> subStr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (subStr.empty()) &lt;span style="color:#66d9ef">return&lt;/span> true; &lt;span style="color:#75715e">// 空子串是任何字符串的子串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> mainStr.length(), n &lt;span style="color:#f92672">=&lt;/span> subStr.length();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (m &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m &lt;span style="color:#f92672">-&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> j;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (mainStr[i &lt;span style="color:#f92672">+&lt;/span> j] &lt;span style="color:#f92672">!=&lt;/span> subStr[j]) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (j &lt;span style="color:#f92672">==&lt;/span> n) &lt;span style="color:#66d9ef">return&lt;/span> true; &lt;span style="color:#75715e">// 完全匹配
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>时间复杂度&lt;/strong>：最坏情况为 (O(m \times n))（如主串为&lt;code>AAAAAAB&lt;/code>，子串为&lt;code>AAAB&lt;/code>）。&lt;/li>
&lt;li>&lt;strong>空间复杂度&lt;/strong>：(O(1))。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-kmp算法knuth-morris-pratt">&lt;strong>2. KMP算法（Knuth-Morris-Pratt）&lt;/strong>&lt;/h3>
&lt;p>通过预处理子串生成部分匹配表（Longest Prefix Suffix, LPS），利用已匹配的信息跳过不必要的比较。&lt;/p></description><content type="html"><![CDATA[<h2 id="常见-cc-api">常见 C/C++ API</h2>
<ol>
<li>
<p><strong><code>std::string</code>的 <code>string::find</code> 成员函数</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSubstring</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> mainStr, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> subStr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> mainStr.find(subStr) <span style="color:#f92672">!=</span> string<span style="color:#f92672">::</span>npos;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>大多数标准库的 <code>strstr</code>（如Glibc）和 <code>string::find</code>（如MSVC、libc++）已针对子串搜索优化。<br>
实现中可能直接调用 <code>memmem</code> 或 <code>strstr</code>，性能与 <code>strstr</code> 相当。</p>
</blockquote>
</li>
<li>
<p><strong>C标准库的 <code>strstr</code> 函数</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSubstring</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> mainStr, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> subStr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> strstr(mainStr.c_str(), subStr.c_str()) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要将 <code>std::string</code> 转换为C风格字符串，可能引入额外开销。</p>
<blockquote>
<p>Glibc的 <code>strstr</code> 使用Two-Way算法，适合长文本和模式。时间复杂度接近<code>O(n)</code>。</p>
</blockquote>
</li>
<li>
<p><strong>STL <code>std::search</code></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSubstring</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> mainStr, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> subStr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>search(
</span></span><span style="display:flex;"><span>        mainStr.begin(), mainStr.end(),
</span></span><span style="display:flex;"><span>        subStr.begin(), subStr.end()
</span></span><span style="display:flex;"><span>    ) <span style="color:#f92672">!=</span> mainStr.end();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<hr>
<h2 id="算法">算法</h2>
<h3 id="1-暴力法brute-force"><strong>1. 暴力法（Brute Force）</strong></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSubstringBruteForce</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> mainStr, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> subStr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (subStr.empty()) <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// 空子串是任何字符串的子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> mainStr.length(), n <span style="color:#f92672">=</span> subStr.length();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (m <span style="color:#f92672">&lt;</span> n) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> m <span style="color:#f92672">-</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (mainStr[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">!=</span> subStr[j]) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> n) <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// 完全匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>时间复杂度</strong>：最坏情况为 (O(m \times n))（如主串为<code>AAAAAAB</code>，子串为<code>AAAB</code>）。</li>
<li><strong>空间复杂度</strong>：(O(1))。</li>
</ul>
<hr>
<h3 id="2-kmp算法knuth-morris-pratt"><strong>2. KMP算法（Knuth-Morris-Pratt）</strong></h3>
<p>通过预处理子串生成部分匹配表（Longest Prefix Suffix, LPS），利用已匹配的信息跳过不必要的比较。</p>
<ol>
<li><strong>构建部分匹配表（LPS）</strong>：
<ul>
<li>计算子串每个位置的最长相等前缀和后缀的长度。</li>
</ul>
</li>
<li><strong>双指针匹配</strong>：
<ul>
<li>主串指针<code>i</code>和子串指针<code>j</code>同时移动，匹配失败时根据LPS表回退<code>j</code>。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 预处理LPS表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> computeLPS(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> subStr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> subStr.length();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> lps(n, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 当前最长前缀后缀长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n;) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (subStr[i] <span style="color:#f92672">==</span> subStr[len]) {
</span></span><span style="display:flex;"><span>            lps[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>len;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (len <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) len <span style="color:#f92672">=</span> lps[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> lps[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lps;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// KMP匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSubstringKMP</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> mainStr, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> subStr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (subStr.empty()) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> mainStr.length(), n <span style="color:#f92672">=</span> subStr.length();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (m <span style="color:#f92672">&lt;</span> n) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> lps <span style="color:#f92672">=</span> computeLPS(subStr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// i:主串指针, j:子串指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> m) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (mainStr[i] <span style="color:#f92672">==</span> subStr[j]) {
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> n) <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// 完全匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) j <span style="color:#f92672">=</span> lps[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 回退j
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> i<span style="color:#f92672">++</span>; <span style="color:#75715e">// 无法回退，移动i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>时间复杂度</strong>：(O(m + n))，预处理LPS表 (O(n))，匹配过程 (O(m))。</li>
<li><strong>空间复杂度</strong>：(O(n))（存储LPS表）。</li>
</ul>
<p>适合处理长文本或频繁匹配同一子串。</p>
<hr>
<h3 id="3-sunday算法"><strong>3. Sunday算法</strong></h3>
<p>利用坏字符规则，根据主字符串中当前匹配窗口后的第一个字符决定跳跃步长。</p>
<ol>
<li><strong>预处理偏移表</strong>：
<ul>
<li>记录子串中每个字符最后出现的位置距末尾的距离。</li>
</ul>
</li>
<li><strong>匹配与跳跃</strong>：
<ul>
<li>匹配失败时，根据主字符串中下一个字符的位置跳跃。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSubstringSunday</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> mainStr, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> subStr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (subStr.empty()) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> mainStr.length(), n <span style="color:#f92672">=</span> subStr.length();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (m <span style="color:#f92672">&lt;</span> n) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 预处理偏移表：字符到跳跃步长的映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> shift;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        shift[subStr[i]] <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> i; <span style="color:#75715e">// 字符最后出现的位置距末尾的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> m <span style="color:#f92672">-</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> match <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (mainStr[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">!=</span> subStr[j]) {
</span></span><span style="display:flex;"><span>                match <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (match) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 计算跳跃步长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">char</span> nextChar <span style="color:#f92672">=</span> (i <span style="color:#f92672">+</span> n <span style="color:#f92672">&lt;</span> m) <span style="color:#f92672">?</span> mainStr[i <span style="color:#f92672">+</span> n] <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> step <span style="color:#f92672">=</span> (shift.find(nextChar) <span style="color:#f92672">!=</span> shift.end()) <span style="color:#f92672">?</span> shift[nextChar] <span style="color:#f92672">:</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">+=</span> step;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>时间复杂度</strong>：平均 (O(m))，最坏 (O(m \times n))。</li>
<li><strong>空间复杂度</strong>：(O(k))（k为字符集大小）。</li>
</ul>
<p>适合字符分布不均匀的场景（如英文文本）。</p>
<hr>
<table>
  <thead>
      <tr>
          <th>算法</th>
          <th>时间复杂度</th>
          <th>空间复杂度</th>
          <th>适用场景</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>暴力法</td>
          <td>(O(m \times n))</td>
          <td>(O(1))</td>
          <td>短文本、简单场景</td>
      </tr>
      <tr>
          <td>KMP</td>
          <td>(O(m + n))</td>
          <td>(O(n))</td>
          <td>长文本、需频繁匹配同一子串</td>
      </tr>
      <tr>
          <td>Sunday</td>
          <td>平均 (O(m))</td>
          <td>(O(k))</td>
          <td>字符分布不均匀（如自然语言）</td>
      </tr>
  </tbody>
</table>
]]></content></item><item><title>写个相对现代的 C++ 二叉搜索树</title><link>https://jekyulll.github.io/posts/cpp-%E5%86%99%E4%B8%AA%E7%9B%B8%E5%AF%B9%E7%8E%B0%E4%BB%A3%E7%9A%84-c++-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Tue, 21 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E5%86%99%E4%B8%AA%E7%9B%B8%E5%AF%B9%E7%8E%B0%E4%BB%A3%E7%9A%84-c++-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;optional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">concept&lt;/span> Comparable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">requires&lt;/span>(T a, T b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { a &lt;span style="color:#f92672">&amp;lt;&lt;/span> b } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>convertible_to&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { a &lt;span style="color:#f92672">&amp;gt;&lt;/span> b } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>convertible_to&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { a &lt;span style="color:#f92672">==&lt;/span> b } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>convertible_to&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">concept&lt;/span> Streamable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">requires&lt;/span>(T a, std&lt;span style="color:#f92672">::&lt;/span>ostream&lt;span style="color:#f92672">&amp;amp;&lt;/span> os) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { os &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> a } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>same_as&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>ostream&lt;span style="color:#f92672">&amp;amp;&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>Comparable K, Streamable V&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PairBSTree&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> Pair &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair _pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> _left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> _right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> _pair(pair), _left(&lt;span style="color:#66d9ef">nullptr&lt;/span>), _right(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode(Pair&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> pair)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> _pair(std&lt;span style="color:#f92672">::&lt;/span>move(pair)), _left(&lt;span style="color:#66d9ef">nullptr&lt;/span>), _right(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>TreeNode() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> _root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">build_&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair : nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Insert(pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">build_&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&amp;amp;&lt;/span> nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair : nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Insert(std&lt;span style="color:#f92672">::&lt;/span>move(pair));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">destroy_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destroy_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destroy_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> search_(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node, K key) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node &lt;span style="color:#f92672">||&lt;/span> key &lt;span style="color:#f92672">==&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (key &lt;span style="color:#f92672">&amp;lt;&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">search_&lt;/span>(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">search_&lt;/span>(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">insert_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node, &lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TreeNode(pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> key &lt;span style="color:#f92672">=&lt;/span> pair.first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (key &lt;span style="color:#f92672">==&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair &lt;span style="color:#f92672">=&lt;/span> pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (key &lt;span style="color:#f92672">&amp;lt;&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> insert_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left, pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> insert_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right, pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> go_to_max_(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> go_to_min_(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">delete_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node, K key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> search_(node, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> max_in_left &lt;span style="color:#f92672">=&lt;/span> go_to_max_(target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair &lt;span style="color:#f92672">=&lt;/span> max_in_left&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 常规的递归，把整个左子树当做新的树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// delete_(target-&amp;gt;_left, max_in_left-&amp;gt;_pair.first);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 2. 直接传入 max_in_left 即可
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// delete_(max_in_left, max_in_left-&amp;gt;_pair.first);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 3. 实际上不需要递归，因为 max_in_left 是左边最大的值，一定没有右子树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> TreeNode&lt;span style="color:#f92672">*&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> max_in_left&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> max_in_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_in_left &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 我开始时候的代码（有误）：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// auto&amp;amp; max_in_left = go_to_max_(node-&amp;gt;_left); // 应该是
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// current-&amp;gt;_left current-&amp;gt;_pair = max_in_left-&amp;gt;_pair; delete
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// (max_in_left); max_in_left = nullptr;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 第三种和我开始时候的逻辑类似
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 但我当时忘了保留 max_in_left 的左子树（如果存在）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">normal_print_func_&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pair.second &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; | &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">in_order_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&lt;/span> node, std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span>)&lt;span style="color:#f92672">&amp;gt;&lt;/span> func) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in_order_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left, func);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in_order_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right, func);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree() &lt;span style="color:#f92672">:&lt;/span> _root(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> pairs) &lt;span style="color:#f92672">:&lt;/span> _root(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build_(pairs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&amp;amp;&lt;/span> pairs) &lt;span style="color:#f92672">:&lt;/span> _root(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build_(std&lt;span style="color:#f92672">::&lt;/span>move(pairs));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>PairBSTree() { destroy_(_root); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>V&lt;span style="color:#f92672">&amp;gt;&lt;/span> Search(K key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> node &lt;span style="color:#f92672">=&lt;/span> search_(_root, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>nullopt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Insert&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair) { insert_(_root, pair); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Delete&lt;/span>(K key) { delete_(_root, key); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">InOrder&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>(Pair)&lt;span style="color:#f92672">&amp;gt;&lt;/span> func &lt;span style="color:#f92672">=&lt;/span> normal_print_func_) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in_order_(_root, func);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">[[nodiscard]]&lt;/span> size_t Size() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InOrder([&lt;span style="color:#f92672">&amp;amp;&lt;/span>size](std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span>) { &lt;span style="color:#f92672">++&lt;/span>size; });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">[[nodiscard]]&lt;/span> V Max() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> _root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> go_to_max_(temp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">[[nodiscard]]&lt;/span> V Min() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> _root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> go_to_min_(temp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> pairs &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Bob&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Jack&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Lucy&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">23&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Evan&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Gorge&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Lily&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Mono&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">90&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Rick&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">14&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Lance&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">76&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Molly&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">24&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Stan&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">11&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Scot&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">54&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Mint&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">37&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Biance&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">35&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Cower&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Brick&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree tree(pairs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Name of 9: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tree.Search(&lt;span style="color:#ae81ff">9&lt;/span>).value_or(&lt;span style="color:#e6db74">&amp;#34;nothing&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tree.Size() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// std::cout &amp;lt;&amp;lt; &amp;#34;Min: &amp;#34; &amp;lt;&amp;lt; tree.Min() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// std::cout &amp;lt;&amp;lt; &amp;#34;Max: &amp;#34; &amp;lt;&amp;lt; tree.Max() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.InOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.Delete(&lt;span style="color:#ae81ff">15&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tree.Size() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.InOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> names_in_order;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.InOrder([&lt;span style="color:#f92672">&amp;amp;&lt;/span>names_in_order](std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> pair) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pair.second &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; -- &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> names_in_order.push_back(pair.second);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description><content type="html"><![CDATA[<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;optional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> Comparable <span style="color:#f92672">=</span> <span style="color:#66d9ef">requires</span>(T a, T b) {
</span></span><span style="display:flex;"><span>    { a <span style="color:#f92672">&lt;</span> b } <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>convertible_to<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    { a <span style="color:#f92672">&gt;</span> b } <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>convertible_to<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    { a <span style="color:#f92672">==</span> b } <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>convertible_to<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> Streamable <span style="color:#f92672">=</span> <span style="color:#66d9ef">requires</span>(T a, std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> os) {
</span></span><span style="display:flex;"><span>    { os <span style="color:#f92672">&lt;&lt;</span> a } <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>same_as<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;&gt;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>Comparable K, Streamable V<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PairBSTree</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> Pair <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>K, V<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>        Pair _pair;
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> _left;
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> _right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        TreeNode() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>        TreeNode(<span style="color:#66d9ef">const</span> Pair<span style="color:#f92672">&amp;</span> pair)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">:</span> _pair(pair), _left(<span style="color:#66d9ef">nullptr</span>), _right(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>        TreeNode(Pair<span style="color:#f92672">&amp;&amp;</span> pair)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">:</span> _pair(std<span style="color:#f92672">::</span>move(pair)), _left(<span style="color:#66d9ef">nullptr</span>), _right(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">~</span>TreeNode() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> _root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build_</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Pair<span style="color:#f92672">&gt;&amp;</span> nodes) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> pair : nodes) {
</span></span><span style="display:flex;"><span>            Insert(pair);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build_</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Pair<span style="color:#f92672">&gt;&amp;&amp;</span> nodes) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Pair<span style="color:#f92672">&amp;</span> pair : nodes) {
</span></span><span style="display:flex;"><span>            Insert(std<span style="color:#f92672">::</span>move(pair));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">destroy_</span>(TreeNode<span style="color:#f92672">*</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node) {
</span></span><span style="display:flex;"><span>            destroy_(node<span style="color:#f92672">-&gt;</span>_left);
</span></span><span style="display:flex;"><span>            destroy_(node<span style="color:#f92672">-&gt;</span>_right);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>            node <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*&amp;</span> search_(TreeNode<span style="color:#f92672">*&amp;</span> node, K key) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node <span style="color:#f92672">||</span> key <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>_pair.first) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>_pair.first) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">search_</span>(node<span style="color:#f92672">-&gt;</span>_left, key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">search_</span>(node<span style="color:#f92672">-&gt;</span>_right, key);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert_</span>(TreeNode<span style="color:#f92672">*&amp;</span> node, <span style="color:#66d9ef">const</span> Pair<span style="color:#f92672">&amp;</span> pair) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node) {
</span></span><span style="display:flex;"><span>            node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(pair);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> key <span style="color:#f92672">=</span> pair.first;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>_pair.first) {
</span></span><span style="display:flex;"><span>            node<span style="color:#f92672">-&gt;</span>_pair <span style="color:#f92672">=</span> pair;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>_pair.first) {
</span></span><span style="display:flex;"><span>            insert_(node<span style="color:#f92672">-&gt;</span>_left, pair);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            insert_(node<span style="color:#f92672">-&gt;</span>_right, pair);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*&amp;</span> go_to_max_(TreeNode<span style="color:#f92672">*&amp;</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (node<span style="color:#f92672">-&gt;</span>_right) {
</span></span><span style="display:flex;"><span>            node <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>_right;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*&amp;</span> go_to_min_(TreeNode<span style="color:#f92672">*&amp;</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (node<span style="color:#f92672">-&gt;</span>_left) {
</span></span><span style="display:flex;"><span>            node <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>_left;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete_</span>(TreeNode<span style="color:#f92672">*&amp;</span> node, K key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> target <span style="color:#f92672">=</span> search_(node, key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>target) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>target<span style="color:#f92672">-&gt;</span>_left <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>target<span style="color:#f92672">-&gt;</span>_right) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> target;
</span></span><span style="display:flex;"><span>            target <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>target<span style="color:#f92672">-&gt;</span>_left) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> target<span style="color:#f92672">-&gt;</span>_right;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> target;
</span></span><span style="display:flex;"><span>            target <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>target<span style="color:#f92672">-&gt;</span>_right) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> target<span style="color:#f92672">-&gt;</span>_left;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> target;
</span></span><span style="display:flex;"><span>            target <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> max_in_left <span style="color:#f92672">=</span> go_to_max_(target<span style="color:#f92672">-&gt;</span>_left);
</span></span><span style="display:flex;"><span>        target<span style="color:#f92672">-&gt;</span>_pair <span style="color:#f92672">=</span> max_in_left<span style="color:#f92672">-&gt;</span>_pair;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 常规的递归，把整个左子树当做新的树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// delete_(target-&gt;_left, max_in_left-&gt;_pair.first);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 2. 直接传入 max_in_left 即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// delete_(max_in_left, max_in_left-&gt;_pair.first);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 3. 实际上不需要递归，因为 max_in_left 是左边最大的值，一定没有右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        TreeNode<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> max_in_left<span style="color:#f92672">-&gt;</span>_left;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> max_in_left;
</span></span><span style="display:flex;"><span>        max_in_left <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 我开始时候的代码（有误）：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// auto&amp; max_in_left = go_to_max_(node-&gt;_left);  // 应该是
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// current-&gt;_left current-&gt;_pair = max_in_left-&gt;_pair; delete
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// (max_in_left); max_in_left = nullptr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 第三种和我开始时候的逻辑类似
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 但我当时忘了保留 max_in_left 的左子树（如果存在）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">normal_print_func_</span>(<span style="color:#66d9ef">const</span> Pair<span style="color:#f92672">&amp;</span> pair) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> pair.second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; | &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">in_order_</span>(TreeNode<span style="color:#f92672">*</span> node, std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>(<span style="color:#66d9ef">const</span> Pair<span style="color:#f92672">&amp;</span>)<span style="color:#f92672">&gt;</span> func) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        in_order_(node<span style="color:#f92672">-&gt;</span>_left, func);
</span></span><span style="display:flex;"><span>        func(node<span style="color:#f92672">-&gt;</span>_pair);
</span></span><span style="display:flex;"><span>        in_order_(node<span style="color:#f92672">-&gt;</span>_right, func);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    PairBSTree() <span style="color:#f92672">:</span> _root(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PairBSTree(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Pair<span style="color:#f92672">&gt;&amp;</span> pairs) <span style="color:#f92672">:</span> _root(<span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>        build_(pairs);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PairBSTree(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Pair<span style="color:#f92672">&gt;&amp;&amp;</span> pairs) <span style="color:#f92672">:</span> _root(<span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>        build_(std<span style="color:#f92672">::</span>move(pairs));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>PairBSTree() { destroy_(_root); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> Search(K key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> node <span style="color:#f92672">=</span> search_(_root, key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>nullopt;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node<span style="color:#f92672">-&gt;</span>_pair.second;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Insert</span>(<span style="color:#66d9ef">const</span> Pair<span style="color:#f92672">&amp;</span> pair) { insert_(_root, pair); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Delete</span>(K key) { delete_(_root, key); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InOrder</span>(std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>(Pair)<span style="color:#f92672">&gt;</span> func <span style="color:#f92672">=</span> normal_print_func_) {
</span></span><span style="display:flex;"><span>        in_order_(_root, func);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">[[nodiscard]]</span> size_t Size() {
</span></span><span style="display:flex;"><span>        size_t size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        InOrder([<span style="color:#f92672">&amp;</span>size](std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>K, V<span style="color:#f92672">&gt;</span>) { <span style="color:#f92672">++</span>size; });
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> size;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">[[nodiscard]]</span> V Max() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> temp <span style="color:#f92672">=</span> _root;
</span></span><span style="display:flex;"><span>        go_to_max_(temp);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> temp<span style="color:#f92672">-&gt;</span>_pair.second;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">[[nodiscard]]</span> V Min() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> temp <span style="color:#f92672">=</span> _root;
</span></span><span style="display:flex;"><span>        go_to_min_(temp);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> temp<span style="color:#f92672">-&gt;</span>_pair.second;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;&gt;</span> pairs <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;Bob&#34;</span>},    {<span style="color:#ae81ff">9</span>, <span style="color:#e6db74">&#34;Jack&#34;</span>},    {<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#34;Lucy&#34;</span>},   {<span style="color:#ae81ff">23</span>, <span style="color:#e6db74">&#34;Evan&#34;</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;Gorge&#34;</span>},  {<span style="color:#ae81ff">12</span>, <span style="color:#e6db74">&#34;Lily&#34;</span>},   {<span style="color:#ae81ff">15</span>, <span style="color:#e6db74">&#34;Mono&#34;</span>},  {<span style="color:#ae81ff">90</span>, <span style="color:#e6db74">&#34;Rick&#34;</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">14</span>, <span style="color:#e6db74">&#34;Lance&#34;</span>}, {<span style="color:#ae81ff">76</span>, <span style="color:#e6db74">&#34;Molly&#34;</span>},  {<span style="color:#ae81ff">24</span>, <span style="color:#e6db74">&#34;Stan&#34;</span>},  {<span style="color:#ae81ff">11</span>, <span style="color:#e6db74">&#34;Scot&#34;</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">54</span>, <span style="color:#e6db74">&#34;Mint&#34;</span>},  {<span style="color:#ae81ff">37</span>, <span style="color:#e6db74">&#34;Biance&#34;</span>}, {<span style="color:#ae81ff">35</span>, <span style="color:#e6db74">&#34;Cower&#34;</span>}, {<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Brick&#34;</span>},
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PairBSTree tree(pairs);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Name of 9: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> tree.Search(<span style="color:#ae81ff">9</span>).value_or(<span style="color:#e6db74">&#34;nothing&#34;</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Size: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> tree.Size() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// std::cout &lt;&lt; &#34;Min: &#34; &lt;&lt; tree.Min() &lt;&lt; &#39;\n&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// std::cout &lt;&lt; &#34;Max: &#34; &lt;&lt; tree.Max() &lt;&lt; &#39;\n&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    tree.InOrder();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tree.Delete(<span style="color:#ae81ff">15</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Size: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> tree.Size() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tree.InOrder();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> names_in_order;
</span></span><span style="display:flex;"><span>    tree.InOrder([<span style="color:#f92672">&amp;</span>names_in_order](std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> pair) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> pair.second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; -- &#34;</span>;
</span></span><span style="display:flex;"><span>        names_in_order.push_back(pair.second);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>C++ std::function 之脱裤子放屁的优化</title><link>https://jekyulll.github.io/posts/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/</link><pubDate>Wed, 15 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/</guid><description>&lt;p>看到一句话：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>std::function&lt;/code> 很强大，但是代价也很高，在创建函数对象的时候总是会有 &lt;code>new&lt;/code> 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。&lt;/p>
&lt;/blockquote>
&lt;p>于是草草找一下资料，看看有没有隐藏的性能优化。&lt;/p>
&lt;hr>
&lt;h3 id="stdfunction-的实现">&lt;code>std::function&lt;/code> 的实现&lt;/h3>
&lt;p>&lt;a href="https://zh.cppreference.com/w/cpp/utility/functional/function">&lt;code>std::function&lt;/code>&lt;/a> 是一个可变参类模板，是一个通用的函数包装器（Polymorphic function wrapper）。&lt;br>
通过类型擦除（type erasure）机制，将具体类型的可调用对象封装到一个统一的接口中。&lt;/p>
&lt;blockquote>
&lt;p>其实例可以存储、复制和调用任何可复制构造的可调用目标，包括普通函数、成员函数、类对象（重载了operator()的类的对象）、Lambda表达式等。是对C++现有的可调用实体的一种类型安全的包裹（相比而言，函数指针这种可调用实体，是类型不安全的）。 &amp;ndash; &lt;a href="https://zhuanlan.zhihu.com/p/560964284">STL源码分析之std::function&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> _Res, &lt;span style="color:#66d9ef">typename&lt;/span>... _ArgTypes&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">function&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>_Res(_ArgTypes...)&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> _Maybe_unary_or_binary_function&lt;span style="color:#f92672">&amp;lt;&lt;/span>_Res, _ArgTypes...&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> , &lt;span style="color:#66d9ef">private&lt;/span> _Function_base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> _Invoker_type &lt;span style="color:#f92672">=&lt;/span> _Res (&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#66d9ef">const&lt;/span> _Any_data&lt;span style="color:#f92672">&amp;amp;&lt;/span>, _ArgTypes&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _Invoker_type _M_invoker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>std::function&lt;/code> 的内部有两个部分：&lt;/p>
&lt;ul>
&lt;li>一个指向实际存储区域的指针：存储实际的可调用对象（函数对象、lambda、函数指针等）。&lt;/li>
&lt;li>一个&lt;em>接口表&lt;/em>（vtable 等效机制）：存储操作函数（如调用函数、复制、销毁等）的地址。&lt;/li>
&lt;/ul>
&lt;p>其类型擦除通过接口表的方式实现，类似于虚函数机制，但它通常采用静态接口表和手动的动态分配来支持多种类型的可调用对象。&lt;/p>
&lt;hr>
&lt;h3 id="性能分析">性能分析&lt;/h3>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/370563773">关于std function和lambda function的性能调试 &amp;ndash;法号桑菜&lt;/a>。&lt;br>
&lt;a href="https://blog.demofox.org/2015/02/25/avoiding-the-performance-hazzards-of-stdfunction/">Avoiding The Performance Hazzards of std::function&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>There are two performance implications of using &lt;code>std::function&lt;/code> that might surprise you:&lt;/p>
&lt;ol>
&lt;li>When calling a &lt;code>std::function&lt;/code>, it does a virtual function call.&lt;/li>
&lt;li>When assigning a lambda with significant captures to a &lt;code>std::function&lt;/code>, it will do a dynamic memory allocation!&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>一是&lt;code>std::function&lt;/code> 会使用虚函数调用，有开销。&lt;/li>
&lt;li>二是将 lambda 赋给&lt;code>std::function&lt;/code>的时候，如果捕获内容较多，会需要额外的动态内存分配。&lt;/li>
&lt;/ul>
&lt;p>第二点其实说的就是：&lt;br>
&lt;code>std::function&lt;/code> 对小型的可调用对象会使用“&lt;strong>小对象优化&lt;/strong>（Small Object Optimization, SOO）”，避免动态分配堆内存。但如果对象超过了实现中的小对象优化阈值，则会触发堆分配（&lt;code>new&lt;/code> 操作）。&lt;/p></description><content type="html"><![CDATA[<p>看到一句话：</p>
<blockquote>
<p><code>std::function</code> 很强大，但是代价也很高，在创建函数对象的时候总是会有 <code>new</code> 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。</p>
</blockquote>
<p>于是草草找一下资料，看看有没有隐藏的性能优化。</p>
<hr>
<h3 id="stdfunction-的实现"><code>std::function</code> 的实现</h3>
<p><a href="https://zh.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a> 是一个可变参类模板，是一个通用的函数包装器（Polymorphic function wrapper）。<br>
通过类型擦除（type erasure）机制，将具体类型的可调用对象封装到一个统一的接口中。</p>
<blockquote>
<p>其实例可以存储、复制和调用任何可复制构造的可调用目标，包括普通函数、成员函数、类对象（重载了operator()的类的对象）、Lambda表达式等。是对C++现有的可调用实体的一种类型安全的包裹（相比而言，函数指针这种可调用实体，是类型不安全的）。 &ndash; <a href="https://zhuanlan.zhihu.com/p/560964284">STL源码分析之std::function</a></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Res, <span style="color:#66d9ef">typename</span>... _ArgTypes<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">function</span><span style="color:#f92672">&lt;</span>_Res(_ArgTypes...)<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> _Maybe_unary_or_binary_function<span style="color:#f92672">&lt;</span>_Res, _ArgTypes...<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  , <span style="color:#66d9ef">private</span> _Function_base
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> _Invoker_type <span style="color:#f92672">=</span> _Res (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">const</span> _Any_data<span style="color:#f92672">&amp;</span>, _ArgTypes<span style="color:#f92672">&amp;&amp;</span>...);
</span></span><span style="display:flex;"><span>    _Invoker_type _M_invoker;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p><code>std::function</code> 的内部有两个部分：</p>
<ul>
<li>一个指向实际存储区域的指针：存储实际的可调用对象（函数对象、lambda、函数指针等）。</li>
<li>一个<em>接口表</em>（vtable 等效机制）：存储操作函数（如调用函数、复制、销毁等）的地址。</li>
</ul>
<p>其类型擦除通过接口表的方式实现，类似于虚函数机制，但它通常采用静态接口表和手动的动态分配来支持多种类型的可调用对象。</p>
<hr>
<h3 id="性能分析">性能分析</h3>
<p><a href="https://zhuanlan.zhihu.com/p/370563773">关于std function和lambda function的性能调试 &ndash;法号桑菜</a>。<br>
<a href="https://blog.demofox.org/2015/02/25/avoiding-the-performance-hazzards-of-stdfunction/">Avoiding The Performance Hazzards of std::function</a>。</p>
<blockquote>
<p>There are two performance implications of using <code>std::function</code> that might surprise you:</p>
<ol>
<li>When calling a <code>std::function</code>, it does a virtual function call.</li>
<li>When assigning a lambda with significant captures to a <code>std::function</code>, it will do a dynamic memory allocation!</li>
</ol>
</blockquote>
<ul>
<li>一是<code>std::function</code> 会使用虚函数调用，有开销。</li>
<li>二是将 lambda 赋给<code>std::function</code>的时候，如果捕获内容较多，会需要额外的动态内存分配。</li>
</ul>
<p>第二点其实说的就是：<br>
<code>std::function</code> 对小型的可调用对象会使用“<strong>小对象优化</strong>（Small Object Optimization, SOO）”，避免动态分配堆内存。但如果对象超过了实现中的小对象优化阈值，则会触发堆分配（<code>new</code> 操作）。</p>
<hr>
<h3 id="一些可能有用的优化">一些可能有用的优化</h3>
<ol>
<li>手动使用模板代替 <code>std::function</code>：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Callable<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> invoke(Callable f) {
</span></span><span style="display:flex;"><span>    f();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>直接在编译期确定类型，避免了类型擦除和动态分配。<br>
缺点就是使用场景受限于编译期类型，灵活性不如 <code>std::function</code>。</p>
<ol start="2">
<li>向 <code>std::function</code> 传递 lambda 的时候使用 <code>std::ref()</code> / <code>std::cref()</code></li>
</ol>
<blockquote>
<p><code>std::ref()</code> and <code>std::cref()</code> return reference wrappers (costant ref wrapper in the cref case) which can hold arbitrary types as references. If you put your large capture lambda into one of these functions and give it to <code>std::function</code>, there’s a <code>std::function</code> constructor which is able to take this reference, and use that instead of allocating more memory.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>array i;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> A <span style="color:#f92672">=</span> [<span style="color:#f92672">=</span>]() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (i[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> i[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> i[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> i[<span style="color:#ae81ff">3</span>]) <span style="color:#f92672">^</span> i[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// no allocation, std::function stores a reference to A instead of A itself
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>function <span style="color:#a6e22e">fA</span>(ref(A));
</span></span></code></pre></div><ol start="3">
<li>使用 <code>std::variant</code>：</li>
</ol>
<p>通过 <code>std::variant</code> 直接存储无类型擦除的函数对象。似乎有点跑题，在此处作用有限。<br>
<code>std::variant</code> 的内存是静态分配的：其大小是所有可能存储的类型大小的最大值，避免了堆分配的开销。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PrintHello</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">operator</span>()() <span style="color:#66d9ef">const</span> { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello, Struct!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Callable <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>variant<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>)(), PrintHello<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">invoke</span>(<span style="color:#66d9ef">const</span> Callable<span style="color:#f92672">&amp;</span> f) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>visit([](<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> func) { func(); }, f);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    invoke([]() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello, Function Pointer!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; });  <span style="color:#75715e">// 函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    invoke(PrintHello{});  <span style="color:#75715e">// 自定义的函数对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="4">
<li>
<p>Stack Allocation: 给 <code>std::function</code> 一个自定义分配器&hellip;</p>
</li>
<li>
<p>Lambda 的 <code>+</code></p>
</li>
</ol>
<p>一个无捕获的 lambda 表达式不依赖于任何外部状态，可以被隐式转换为函数指针：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> lambda <span style="color:#f92672">=</span> []() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello, Lambda!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>funcPtr)() <span style="color:#f92672">=</span> lambda; <span style="color:#75715e">// 无需显式转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>funcPtr(); <span style="color:#75715e">// 调用函数指针，输出 &#34;Hello, Lambda!&#34;
</span></span></span></code></pre></div><p>在 lambda 表达式前使用<code>+</code>，会强制将 lambda 转换为函数指针：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">invoke</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>func)()) {
</span></span><span style="display:flex;"><span>    func();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    invoke(<span style="color:#f92672">+</span>[]() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello, Lambda!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; }); <span style="color:#75715e">// 显式转换为函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><hr>
<p>All in all:</p>
<p><img src="/images/stdfunction.png" alt="确实"></p>
]]></content></item><item><title>在 C++ 里实现 Golang 的 defer</title><link>https://jekyulll.github.io/posts/cpp-%E7%94%A8-c++-%E5%AE%9E%E7%8E%B0-golang-%E7%9A%84-defer/</link><pubDate>Wed, 15 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E7%94%A8-c++-%E5%AE%9E%E7%8E%B0-golang-%E7%9A%84-defer/</guid><description>&lt;p>利用 RAII 和 C++ 的析构函数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Defer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">explicit&lt;/span> Defer(std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> func) &lt;span style="color:#f92672">:&lt;/span> func_(std&lt;span style="color:#f92672">::&lt;/span>move(func)), active_(true) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 禁止复制
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Defer(&lt;span style="color:#66d9ef">const&lt;/span> Defer&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Defer&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Defer&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 允许移动
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Defer(Defer&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> other) &lt;span style="color:#66d9ef">noexcept&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> func_(std&lt;span style="color:#f92672">::&lt;/span>move(other.func_)), active_(other.active_) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> other.active_ &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 析构函数中调用defer的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Defer() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (active_ &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> func_) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func_();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cancel&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> active_ &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> func_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> active_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define CONCAT_IMPL(x, y) x##y
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define CONCAT(x, y) CONCAT_IMPL(x, y)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define defer(func) Defer CONCAT(_defer_, __LINE__)(func)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Start of main function&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defer([]() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Deferred action 1&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defer([]() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Deferred action in scope&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Inside scope&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defer([]() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Deferred action 2&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;End of main function&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些宏的目的是为 &lt;code>defer&lt;/code> 提供一种易用的语法，同时确保每次使用 &lt;code>defer&lt;/code> 都会创建一个唯一的变量名，从而避免变量名冲突。&lt;/p></description><content type="html"><![CDATA[<p>利用 RAII 和 C++ 的析构函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Defer</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">explicit</span> Defer(std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> func) <span style="color:#f92672">:</span> func_(std<span style="color:#f92672">::</span>move(func)), active_(true) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 禁止复制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Defer(<span style="color:#66d9ef">const</span> Defer<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>    Defer<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Defer<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 允许移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Defer(Defer<span style="color:#f92672">&amp;&amp;</span> other) <span style="color:#66d9ef">noexcept</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> func_(std<span style="color:#f92672">::</span>move(other.func_)), active_(other.active_) {
</span></span><span style="display:flex;"><span>        other.active_ <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 析构函数中调用defer的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>Defer() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (active_ <span style="color:#f92672">&amp;&amp;</span> func_) {
</span></span><span style="display:flex;"><span>            func_();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cancel</span>() {
</span></span><span style="display:flex;"><span>        active_ <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> func_;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> active_;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define CONCAT_IMPL(x, y) x##y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define CONCAT(x, y) CONCAT_IMPL(x, y)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define defer(func) Defer CONCAT(_defer_, __LINE__)(func)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Start of main function&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    defer([]() {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Deferred action 1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        defer([]() {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Deferred action in scope&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Inside scope&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    defer([]() {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Deferred action 2&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;End of main function&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这些宏的目的是为 <code>defer</code> 提供一种易用的语法，同时确保每次使用 <code>defer</code> 都会创建一个唯一的变量名，从而避免变量名冲突。</p>
<ol>
<li><code>CONCAT_IMPL(x, y)</code> 和 <code>CONCAT(x, y)</code></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define CONCAT_IMPL(x, y) x##y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define CONCAT(x, y) CONCAT_IMPL(x, y)
</span></span></span></code></pre></div><ul>
<li><strong><code>x##y</code></strong> 是 C++ 预处理器的标记连接运算符，将 <code>x</code> 和 <code>y</code> 拼接成一个标识符。</li>
<li><code>CONCAT_IMPL</code> 是底层的宏，用于直接连接标识符。</li>
<li><code>CONCAT</code> 是一个包装宏，它确保在预处理器展开过程中，所有参数被正确解析后再拼接。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CONCAT(foo, bar) <span style="color:#75715e">// 展开为 foobar
</span></span></span></code></pre></div><ol start="2">
<li><code>defer(func)</code></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define defer(func) Defer CONCAT(_defer_, __LINE__)(func)
</span></span></span></code></pre></div><ul>
<li><code>__LINE__</code> 是预处理器的内置宏，表示当前代码所在的行号。</li>
<li><code>CONCAT(_defer_, __LINE__)</code> 会将 <code>_defer_</code> 和当前行号拼接，生成一个唯一的变量名。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>defer([]() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Cleanup!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; });
</span></span></code></pre></div><p>假设这段代码位于第 25 行，则展开后为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Defer <span style="color:#a6e22e">_defer_25</span>([]() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Cleanup!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; });
</span></span></code></pre></div><p>这样每次调用 <code>defer</code> 时生成的变量名都唯一，避免了同一作用域中多个 <code>defer</code> 语句导致变量名冲突的问题。</p>
]]></content></item><item><title>[转载] C++的POD以及如何判断是否POD</title><link>https://jekyulll.github.io/posts/cpp-%E8%BD%AC%E8%BD%BD-c++%E7%9A%84pod%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6pod/</link><pubDate>Thu, 09 Jan 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E8%BD%AC%E8%BD%BD-c++%E7%9A%84pod%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6pod/</guid><description>&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/17003601237">C++的POD以及如何判断是否POD - cheeto的文章 - 知乎&lt;/a>。&lt;/p>
&lt;hr>
&lt;p>在C++11及以后的版本中，POD类型（Plain Old Data）的定义被细化为两个核心概念：&lt;br>
&lt;strong>平凡类型&lt;/strong>（Trivial Type）和&lt;strong>标准布局类型&lt;/strong>（Standard Layout Type）。当类型为Trivial &amp;amp;&amp;amp; Standard Layout时才能被认为是POD。&lt;/p>
&lt;h3 id="平凡类型trivial-type">平凡类型（Trivial Type）&lt;/h3>
&lt;p>满足以下条件：&lt;/p>
&lt;ul>
&lt;li>默认构造函数：没有用户定义的构造函数，即使用默认构造函数。&lt;/li>
&lt;li>默认拷贝构造函数：没有用户定义的拷贝构造函数。&lt;/li>
&lt;li>默认析构函数：没有用户定义的析构函数。&lt;/li>
&lt;li>默认赋值操作符：没有用户定义的拷贝赋值和移动赋值操作符。&lt;/li>
&lt;/ul>
&lt;p>对于平凡类型，编译器会为其提供默认的构造、拷贝和析构行为，无需用户显式定义。&lt;/p>
&lt;p>比如说以下&lt;code>Trivial&lt;/code>，即使它有构造函数和析构函数 只要不是用户自定义而是&lt;code>default&lt;/code>也可以&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Trivial&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Trivial() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>; &lt;span style="color:#75715e">// 默认构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Trivial() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>; &lt;span style="color:#75715e">// 默认析构函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="标准布局类型standard-layout-type">标准布局类型（Standard Layout Type）&lt;/h3>
&lt;p>满足以下条件：&lt;/p>
&lt;ul>
&lt;li>无虚函数：它没有虚函数。&lt;/li>
&lt;li>无虚基类：它没有虚基类。&lt;/li>
&lt;li>成员变量顺序：它的成员变量是按声明顺序排列的。&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>直接用&lt;code>std::is_standard_layout_v&lt;/code>判断即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define Print(x) std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">safe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">unsafe_cons&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unsafe_cons(unsafe_cons &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">unsafe_vir&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">unsafe_tem&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Trivial&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Trivial() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>; &lt;span style="color:#75715e">// 默认构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Trivial() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>; &lt;span style="color:#75715e">// 默认析构函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">StandardLayout&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> a; &lt;span style="color:#75715e">// 1 byte
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> b; &lt;span style="color:#75715e">// 4 bytes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 用于检查是否为 POD 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">is_pod&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> value &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>is_trivial&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>is_standard_layout&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>is_trivially_default_constructible&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">test1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Print(is_pod&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(is_pod&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(is_pod&lt;span style="color:#f92672">&amp;lt;&lt;/span>Trivial&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(is_pod&lt;span style="color:#f92672">&amp;lt;&lt;/span>StandardLayout&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(std&lt;span style="color:#f92672">::&lt;/span>is_trivial&lt;span style="color:#f92672">&amp;lt;&lt;/span>Trivial&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(std&lt;span style="color:#f92672">::&lt;/span>is_trivial&lt;span style="color:#f92672">&amp;lt;&lt;/span>StandardLayout&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(std&lt;span style="color:#f92672">::&lt;/span>is_standard_layout_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>StandardLayout&lt;span style="color:#f92672">&amp;gt;&lt;/span>); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的标准布局的判定反而没有这么严格&lt;/p></description><content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/17003601237">C++的POD以及如何判断是否POD - cheeto的文章 - 知乎</a>。</p>
<hr>
<p>在C++11及以后的版本中，POD类型（Plain Old Data）的定义被细化为两个核心概念：<br>
<strong>平凡类型</strong>（Trivial Type）和<strong>标准布局类型</strong>（Standard Layout Type）。当类型为Trivial &amp;&amp; Standard Layout时才能被认为是POD。</p>
<h3 id="平凡类型trivial-type">平凡类型（Trivial Type）</h3>
<p>满足以下条件：</p>
<ul>
<li>默认构造函数：没有用户定义的构造函数，即使用默认构造函数。</li>
<li>默认拷贝构造函数：没有用户定义的拷贝构造函数。</li>
<li>默认析构函数：没有用户定义的析构函数。</li>
<li>默认赋值操作符：没有用户定义的拷贝赋值和移动赋值操作符。</li>
</ul>
<p>对于平凡类型，编译器会为其提供默认的构造、拷贝和析构行为，无需用户显式定义。</p>
<p>比如说以下<code>Trivial</code>，即使它有构造函数和析构函数 只要不是用户自定义而是<code>default</code>也可以</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Trivial</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span> Trivial() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;  <span style="color:#75715e">// 默认构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#f92672">~</span>Trivial() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>; <span style="color:#75715e">// 默认析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h3 id="标准布局类型standard-layout-type">标准布局类型（Standard Layout Type）</h3>
<p>满足以下条件：</p>
<ul>
<li>无虚函数：它没有虚函数。</li>
<li>无虚基类：它没有虚基类。</li>
<li>成员变量顺序：它的成员变量是按声明顺序排列的。</li>
<li></li>
</ul>
<p>直接用<code>std::is_standard_layout_v</code>判断即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define Print(x) std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">safe</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> m;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">unsafe_cons</span> {
</span></span><span style="display:flex;"><span> unsafe_cons(unsafe_cons <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span>) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">unsafe_vir</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">unsafe_tem</span> {
</span></span><span style="display:flex;"><span> T data;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Trivial</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span> Trivial() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;  <span style="color:#75715e">// 默认构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#f92672">~</span>Trivial() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>; <span style="color:#75715e">// 默认析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">StandardLayout</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">char</span> a; <span style="color:#75715e">// 1 byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> b;  <span style="color:#75715e">// 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 用于检查是否为 POD 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">is_pod</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> value <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span> std<span style="color:#f92672">::</span>is_trivial<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&amp;&amp;</span> std<span style="color:#f92672">::</span>is_standard_layout<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span> std<span style="color:#f92672">::</span>is_trivially_default_constructible<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test1</span>() {
</span></span><span style="display:flex;"><span> Print(is_pod<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>value);                           <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Print(is_pod<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;::</span>value);                   <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Print(is_pod<span style="color:#f92672">&lt;</span>Trivial<span style="color:#f92672">&gt;::</span>value);                       <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Print(is_pod<span style="color:#f92672">&lt;</span>StandardLayout<span style="color:#f92672">&gt;::</span>value);             <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Print(std<span style="color:#f92672">::</span>is_trivial<span style="color:#f92672">&lt;</span>Trivial<span style="color:#f92672">&gt;::</span>value);              <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Print(std<span style="color:#f92672">::</span>is_trivial<span style="color:#f92672">&lt;</span>StandardLayout<span style="color:#f92672">&gt;::</span>value);    <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Print(std<span style="color:#f92672">::</span>is_standard_layout_v<span style="color:#f92672">&lt;</span>StandardLayout<span style="color:#f92672">&gt;</span>); <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>这里的标准布局的判定反而没有这么严格</p>
<p>我说的严格指的是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> a;  <span style="color:#75715e">// 1 byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> b;   <span style="color:#75715e">// 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">和</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span>{ 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> b;   <span style="color:#75715e">// 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> a;  <span style="color:#75715e">// 1 byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>这种</p>
<p><code>struct A</code> 会在 <code>char</code> 后插入填充字节，以满足 <code>int</code> 的对齐要求。
<code>struct B</code> 的内存布局使得结构体末尾需要填充字节，确保结构体的总大小满足 4 字节对齐要求。</p>
<h3 id="小结">小结</h3>
<p>也就是说填充不影响POD的判定 而是成员变量顺序发生了改变才不算POD。</p>
<p>POD 类型的定义主要关注<strong>是否有特殊的构造、析构或拷贝操作</strong>，以及<strong>成员变量的顺序是否保持一致</strong>。</p>
<p><strong>如何判断是否POD</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 用于检查是否为 POD 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用例is_pod&lt;int&gt;::value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">is_pod</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> value <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span> std<span style="color:#f92672">::</span>is_trivial<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&amp;&amp;</span> std<span style="color:#f92672">::</span>is_standard_layout<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span> std<span style="color:#f92672">::</span>is_trivially_default_constructible<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="拓展">拓展</h3>
<p>对于平凡类型的 <code>class</code> 和 <code>struct</code>，它们在内存布局、对象拷贝、传递给 C 函数等操作中，几乎没有区别。因此，可以像使用 C 语言中的结构体一样使用它们。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x, y;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Point p <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用 reinterpret_cast 强制转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>p;  <span style="color:#75715e">// void* 指针指向结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 使用 reinterpret_cast 强制转换为 Point* 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Point<span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">*&gt;</span>(ptr);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 访问成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;x: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p2<span style="color:#f92672">-&gt;</span>x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, y: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p2<span style="color:#f92672">-&gt;</span>y <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>从场景解析 C++ shared_from_this</title><link>https://jekyulll.github.io/posts/cpp-%E4%BB%8E%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90-c++-shared_from_this/</link><pubDate>Thu, 09 Jan 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E4%BB%8E%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90-c++-shared_from_this/</guid><description>&lt;hr>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_44517656/article/details/114208041">智能指针之shared_ptr易错点05&lt;/a>。&lt;br>
&lt;a href="https://zhuanlan.zhihu.com/p/701343248">掌握C++ 智能指针的自我引用：深入解析 &lt;code>shared_from_this&lt;/code> 和 &lt;code>weak_from_this&lt;/code>&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/weixin_44834554/article/details/131589849">C++之shared_from_this用法以及类自引用this指针陷阱&lt;/a>。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>思考&lt;/strong>：&lt;/p>
&lt;blockquote>
&lt;p>设计一个树的节点的时候，如果使用智能指针：用一个&lt;code>std::vector&amp;lt;shared_ptr&amp;lt;TreeNode&amp;gt;&amp;gt;&lt;/code>来存储子节点，为避免循环引用，用&lt;code>weak_ptr&amp;lt;TreeNode&amp;gt;&lt;/code>来存储自身的父节点指针。&lt;br>
那添加子节点的时候，怎么把自身的&lt;code>shared_ptr&lt;/code>赋值给子节点存储的父节点指针呢？&lt;/p>
&lt;/blockquote>
&lt;h3 id="两个错误做法">两个错误做法：&lt;/h3>
&lt;ol>
&lt;li>使用&lt;code>std::make_shared&amp;lt;TreeNode&amp;lt;T&amp;gt;&amp;gt;(*this)&lt;/code>来创建一个新的&lt;code>shared_ptr&lt;/code>，然后赋值给子节点存储的父节点指针。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addChild&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TreeNode&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> child) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 make_shared 来创建子节点并设置父节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> child&lt;span style="color:#f92672">-&amp;gt;&lt;/span>setParent(std&lt;span style="color:#f92672">::&lt;/span>make_shared&lt;span style="color:#f92672">&amp;lt;&lt;/span>TreeNode&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>)); &lt;span style="color:#75715e">// 错误的做法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> children.push_back(child);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>std::make_shared&amp;lt;TreeNode&amp;lt;T&amp;gt;&amp;gt;(*this)&lt;/code> 时，实际上是对当前对象的 拷贝构造（调用拷贝构造函数）来创建一个新的 &lt;code>TreeNode&amp;lt;T&amp;gt;&lt;/code> 对象。这意味着你将当前节点的状态（但不是智能指针）拷贝到一个新的对象中，而新对象的生命周期由 &lt;code>std::shared_ptr&lt;/code> 管理。&lt;/p>
&lt;ol start="2">
&lt;li>使用 &lt;code>std::shared_ptr&amp;lt;TreeNode&amp;lt;T&amp;gt;&amp;gt; ptr(this)&lt;/code> 把裸指针 &lt;code>this&lt;/code> 包装为 &lt;code>shared_ptr&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>将 &lt;code>this&lt;/code> 传递给 &lt;code>std::shared_ptr&amp;lt;TreeNode&amp;lt;T&amp;gt;&amp;gt;&lt;/code> 会导致新创建的 &lt;code>shared_ptr&lt;/code> 管理一个裸指针，而裸指针的生命周期没有由智能指针控制。&lt;/p>
&lt;p>引出一个常规问题，从裸指针创建 &lt;code>shared_ptr&lt;/code> 的隐患：&lt;/p>
&lt;ul>
&lt;li>当 &lt;code>shared_ptr&lt;/code> 的引用计数归零时，它会释放它所管理的对象。如果裸指针在此时继续存在，它仍然会指向原来的内存地址。但这时该内存已被释放，裸指针成为了&lt;em>悬空指针&lt;/em>，也就是所谓的&lt;em>野指针&lt;/em>。&lt;/li>
&lt;li>如果裸指针指向的内存已经被释放（例如，该指针原本由 &lt;code>delete&lt;/code> 或 &lt;code>delete[]&lt;/code> 释放），然后你用这个裸指针创建 &lt;code>shared_ptr&lt;/code>，那么 &lt;code>shared_ptr&lt;/code> 仍然会管理这个已经释放的内存区域。这会导致访问已释放内存（悬空指针）或&lt;em>双重释放内存&lt;/em>的问题（如果 &lt;code>shared_ptr&lt;/code> 销毁时再次释放内存）。&lt;/li>
&lt;li>裸指针可能指向一个栈上的对象：如果裸指针指向一个栈上分配的对象，并且你用它创建 &lt;code>shared_ptr&lt;/code>，那么 &lt;code>shared_ptr&lt;/code> 会试图在引用计数归零时释放这个栈上对象的内存。然而，栈上对象的生命周期由栈帧的销毁来管理，而 &lt;code>shared_ptr&lt;/code> 并不清楚这一点。这将导致程序的未定义行为。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>案例&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TestB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TestB(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TestB create&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>TestB(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TestB destory&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TestB&lt;span style="color:#f92672">&amp;gt;&lt;/span> getSharedFromThis() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TestB&lt;span style="color:#f92672">&amp;gt;&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TestB&lt;span style="color:#f92672">&amp;gt;&lt;/span> ptr3(&lt;span style="color:#66d9ef">new&lt;/span> TestB());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TestB&lt;span style="color:#f92672">&amp;gt;&lt;/span> ptr4 &lt;span style="color:#f92672">=&lt;/span> ptr3&lt;span style="color:#f92672">-&amp;gt;&lt;/span>getSharedFromThis();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ptr2 count: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> ptr3.use_count() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; ptr4 count: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> ptr4.use_count() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//输出：ptr2 count: 1 ptr4 count: 1 然后会崩溃因为重复释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cin.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如何会导致&lt;code>shared_ptr&lt;/code>指向同一个对象，但是不共享引用计数器？&lt;br>
是因为裸指针与&lt;code>shared_ptr&lt;/code>混用，如果我们用一个裸指针初始化或者赋值给&lt;code>shared_ptr&lt;/code>指针时，在&lt;code>shared_ptr&lt;/code>内部生成一个计数器，当另外一个&lt;code>shared_ptr&lt;/code>不用&lt;code>share_ptr&lt;/code>赋值或者初始化的话，再次将一个裸指针赋值给另外一个&lt;code>shared_ptr&lt;/code>时，又一次生成一个计数器，两个计数器不共享。&lt;/p></description><content type="html"><![CDATA[<hr>
<p><a href="https://blog.csdn.net/weixin_44517656/article/details/114208041">智能指针之shared_ptr易错点05</a>。<br>
<a href="https://zhuanlan.zhihu.com/p/701343248">掌握C++ 智能指针的自我引用：深入解析 <code>shared_from_this</code> 和 <code>weak_from_this</code></a>。<br>
<a href="https://blog.csdn.net/weixin_44834554/article/details/131589849">C++之shared_from_this用法以及类自引用this指针陷阱</a>。</p>
<hr>
<p><strong>思考</strong>：</p>
<blockquote>
<p>设计一个树的节点的时候，如果使用智能指针：用一个<code>std::vector&lt;shared_ptr&lt;TreeNode&gt;&gt;</code>来存储子节点，为避免循环引用，用<code>weak_ptr&lt;TreeNode&gt;</code>来存储自身的父节点指针。<br>
那添加子节点的时候，怎么把自身的<code>shared_ptr</code>赋值给子节点存储的父节点指针呢？</p>
</blockquote>
<h3 id="两个错误做法">两个错误做法：</h3>
<ol>
<li>使用<code>std::make_shared&lt;TreeNode&lt;T&gt;&gt;(*this)</code>来创建一个新的<code>shared_ptr</code>，然后赋值给子节点存储的父节点指针。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addChild</span>(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> child) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用 make_shared 来创建子节点并设置父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    child<span style="color:#f92672">-&gt;</span>setParent(std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>));  <span style="color:#75715e">// 错误的做法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    children.push_back(child);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用 <code>std::make_shared&lt;TreeNode&lt;T&gt;&gt;(*this)</code> 时，实际上是对当前对象的 拷贝构造（调用拷贝构造函数）来创建一个新的 <code>TreeNode&lt;T&gt;</code> 对象。这意味着你将当前节点的状态（但不是智能指针）拷贝到一个新的对象中，而新对象的生命周期由 <code>std::shared_ptr</code> 管理。</p>
<ol start="2">
<li>使用 <code>std::shared_ptr&lt;TreeNode&lt;T&gt;&gt; ptr(this)</code> 把裸指针 <code>this</code> 包装为 <code>shared_ptr</code>。</li>
</ol>
<p>将 <code>this</code> 传递给 <code>std::shared_ptr&lt;TreeNode&lt;T&gt;&gt;</code> 会导致新创建的 <code>shared_ptr</code> 管理一个裸指针，而裸指针的生命周期没有由智能指针控制。</p>
<p>引出一个常规问题，从裸指针创建 <code>shared_ptr</code> 的隐患：</p>
<ul>
<li>当 <code>shared_ptr</code> 的引用计数归零时，它会释放它所管理的对象。如果裸指针在此时继续存在，它仍然会指向原来的内存地址。但这时该内存已被释放，裸指针成为了<em>悬空指针</em>，也就是所谓的<em>野指针</em>。</li>
<li>如果裸指针指向的内存已经被释放（例如，该指针原本由 <code>delete</code> 或 <code>delete[]</code> 释放），然后你用这个裸指针创建 <code>shared_ptr</code>，那么 <code>shared_ptr</code> 仍然会管理这个已经释放的内存区域。这会导致访问已释放内存（悬空指针）或<em>双重释放内存</em>的问题（如果 <code>shared_ptr</code> 销毁时再次释放内存）。</li>
<li>裸指针可能指向一个栈上的对象：如果裸指针指向一个栈上分配的对象，并且你用它创建 <code>shared_ptr</code>，那么 <code>shared_ptr</code> 会试图在引用计数归零时释放这个栈上对象的内存。然而，栈上对象的生命周期由栈帧的销毁来管理，而 <code>shared_ptr</code> 并不清楚这一点。这将导致程序的未定义行为。</li>
</ul>
<p><strong>案例</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestB</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	TestB(){
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;TestB create&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">~</span>TestB(){
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;TestB destory&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	shared_ptr<span style="color:#f92672">&lt;</span>TestB<span style="color:#f92672">&gt;</span> getSharedFromThis() { 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>  shared_ptr<span style="color:#f92672">&lt;</span>TestB<span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">this</span>); 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		shared_ptr<span style="color:#f92672">&lt;</span>TestB<span style="color:#f92672">&gt;</span> ptr3(<span style="color:#66d9ef">new</span> TestB());
</span></span><span style="display:flex;"><span>		shared_ptr<span style="color:#f92672">&lt;</span>TestB<span style="color:#f92672">&gt;</span> ptr4 <span style="color:#f92672">=</span> ptr3<span style="color:#f92672">-&gt;</span>getSharedFromThis();
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ptr2 count: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ptr3.use_count() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; ptr4 count: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ptr4.use_count() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//输出：ptr2 count: 1 ptr4 count: 1 然后会崩溃因为重复释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	cin.get();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如何会导致<code>shared_ptr</code>指向同一个对象，但是不共享引用计数器？<br>
是因为裸指针与<code>shared_ptr</code>混用，如果我们用一个裸指针初始化或者赋值给<code>shared_ptr</code>指针时，在<code>shared_ptr</code>内部生成一个计数器，当另外一个<code>shared_ptr</code>不用<code>share_ptr</code>赋值或者初始化的话，再次将一个裸指针赋值给另外一个<code>shared_ptr</code>时，又一次生成一个计数器，两个计数器不共享。</p>
<hr>
<h3 id="shared_ptr实现原理"><code>shared_ptr</code>实现原理：</h3>
<p><code>shared_ptr</code> 从 <code>_Ptr_base</code> 继承了 <code>element_type</code> 和 <code>_Ref_count_base</code> 类型的两个成员变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Ty</span><span style="color:#f92672">&gt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Ptr_base</span>
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span> 
</span></span><span style="display:flex;"><span>        element_type <span style="color:#f92672">*</span> _Ptr{
</span></span><span style="display:flex;"><span>            ptr
</span></span><span style="display:flex;"><span>        }; <span style="color:#75715e">// 指向资源的指针 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        _Ref_count_base <span style="color:#f92672">*</span> _Rep{
</span></span><span style="display:flex;"><span>            ptr
</span></span><span style="display:flex;"><span>        }; <span style="color:#75715e">// 指向资源引用计数的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p><code>_Ref_count_base</code> 中定义了原子类型的变量 <code>_Uses</code> 和 <code>_Weaks</code>，它们分别记录资源的引用个数和资源观察者的个数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">__declspec</span>(novtable) _Ref_count_base
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>         _Atomic_counter_t _Uses;<span style="color:#75715e">//记录资源引用个数 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         _Atomic_counter_t _Weaks;<span style="color:#75715e">//记录观察者个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><hr>
<h3 id="从-this-构造智能指针的正确做法">从 <code>this</code> 构造智能指针的正确做法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span><span style="color:#f92672">:</span> enable_shared_from_this<span style="color:#f92672">&lt;</span>MyClass<span style="color:#f92672">&gt;</span><span style="color:#75715e">//必须继承enable_shared_from_this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    shared_ptr<span style="color:#f92672">&lt;</span>MyClass<span style="color:#f92672">&gt;</span> getself()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">shared_from_this</span>();
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>shared_from_this</code> 是 C++11 中引入的功能，允许对象在继承了 <code>std::enable_shared_from_this</code> 的情况下，安全地生成自身的 <code>std::shared_ptr</code> 实例，而不会创建新的控制块（reference counting block）。这样可以避免悬垂指针的问题，特别是在对象的成员函数中使用时，可以确保对象在使用期间不被销毁。</p>
<p><code>std::enable_shared_from_this&lt;T&gt;</code> 内部维护了一个 <code>std::weak_ptr&lt;T&gt;</code>。当第一个 <code>std::shared_ptr&lt;T&gt;</code> 开始管理该对象时，这个 <code>weak_ptr</code> 被初始化。之后，当 <code>shared_from_this()</code> 被调用时，它将基于这个已经存在的 <code>weak_ptr</code> 返回一个新的 <code>std::shared_ptr&lt;T&gt;</code>，这个新的 <code>shared_ptr</code> 与原有的 <code>shared_ptr</code> 共享对对象的所有权。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    shared_ptr<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      shared_from_this()
</span></span><span style="display:flex;"><span>      { <span style="color:#66d9ef">return</span> shared_ptr<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_weak_this); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> _Tp<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      shared_from_this() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>      { <span style="color:#66d9ef">return</span> shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> _Tp<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_weak_this); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">mutable</span> weak_ptr<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span>  _M_weak_this;
</span></span></code></pre></div><hr>
<p><strong>实践</strong>：</p>
<p>实现这个 <code>TreeNode</code> 类的时候，<code>shared_from_this</code> 解析不出来(似乎是因为模板导致的 clangd 语法解析失败)。</p>
<p><img src="/images/ERRORshared_from_this.png" alt="语法"></p>
<p>改为 <code>this-&gt;shared_from_this()</code> 后报错消失，因为 <code>shared_from_this</code> 实际上是当前父类 <code>enable_shared_from_this</code> 的成员函数。</p>
<p>最终实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TreeNode</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> std<span style="color:#f92672">::</span>enable_shared_from_this<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode(T value) <span style="color:#f92672">:</span> value(value) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setParent</span>(std<span style="color:#f92672">::</span>weak_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> parent) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addChild</span>(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> child) {
</span></span><span style="display:flex;"><span>        child<span style="color:#f92672">-&gt;</span>setParent(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>shared_from_this());
</span></span><span style="display:flex;"><span>        children.push_back(child);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    T <span style="color:#a6e22e">getValue</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> getParent() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> parent.lock();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;&gt;&amp;</span> getChildren() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> children;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    T value;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;&gt;</span> children;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>weak_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> parent;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>]]></content></item><item><title>Redis 数据结构之超日志 HyperLogLog</title><link>https://jekyulll.github.io/posts/redis-redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B6%85%E6%97%A5%E5%BF%97-hyperloglog/</link><pubDate>Wed, 08 Jan 2025 10:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/redis-redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B6%85%E6%97%A5%E5%BF%97-hyperloglog/</guid><description>&lt;p>Redis 在 2.8.9 版本添加了 HyperLogLog （HLL）。&lt;br>
HyperLogLog 是一种高效的基数估算工具，通过概率算法和哈希化技术，在常数空间内提供了基数的估算。&lt;/p>
&lt;p>&lt;em>eg&lt;/em>.&lt;/p>
&lt;ul>
&lt;li>统计一个网站的独立用户数。&lt;/li>
&lt;li>统计一个日志中的独立 IP 数量。&lt;/li>
&lt;li>计算一个流中的独立事件数。&lt;/li>
&lt;/ul>
&lt;p>传统的做法是将所有元素存储在集合中，然后进行去重、计数。但当集合的元素数量非常大时，这种方法会占用大量内存，甚至无法存储所有数据。&lt;br>
HyperLogLog 有一定误差，但对于海量数据来说，它的内存开销极低且精度足够高，非常适合用于大数据处理、流量统计、去重计数等场景。&lt;/p>
&lt;p>Redis 中的 HyperLogLog 支持以下操作：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>PFADD&lt;/code>&lt;/strong>：将元素添加到 HyperLogLog 中，Redis 会对元素进行哈希处理，并更新相应的桶。&lt;/li>
&lt;li>&lt;strong>&lt;code>PFCOUNT&lt;/code>&lt;/strong>：返回一个或多个 HyperLogLog 键的基数估算。&lt;/li>
&lt;li>&lt;strong>&lt;code>PFMERGE&lt;/code>&lt;/strong>：合并多个 HyperLogLog 键的基数估算。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="核心思想">核心思想&lt;/h3>
&lt;p>HyperLogLog 使用概率算法，通过哈希化数据并记录哈希值的前导零数量来估算基数。&lt;/p>
&lt;h5 id="1-哈希函数与二进制表示">&lt;strong>1. 哈希函数与二进制表示&lt;/strong>&lt;/h5>
&lt;p>为了将集合中的元素映射为哈希值，HyperLogLog 使用了 &lt;strong>哈希函数&lt;/strong>。假设我们使用一个 &lt;strong>m-bit&lt;/strong> 的哈希函数，它会把输入数据映射到一个包含 m 位二进制数字的哈希值。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;ul>
&lt;li>假设我们将一个元素哈希成 &lt;code>10111001101100010101010101101010&lt;/code> 这样的 32 位二进制数字。&lt;/li>
&lt;li>这个哈希值的前导零数量就是我们关心的指标。对于这个例子，假设前导零的数量为 3。&lt;/li>
&lt;/ul>
&lt;h5 id="2-关键点记录前导零的数量">&lt;strong>2. 关键点：记录前导零的数量&lt;/strong>&lt;/h5>
&lt;p>HyperLogLog 并不直接存储每个哈希值，而是计算每个哈希值的前导零的数量，把这个值保存在一个桶（通过哈希值的某些位进行映射）中。&lt;/p>
&lt;h5 id="3-桶与桶编号">&lt;strong>3. 桶与桶编号&lt;/strong>&lt;/h5>
&lt;p>为了优化空间，HyperLogLog 使用多个桶来存储不同的哈希值。每个桶的索引是由哈希值的某些位生成的。假设我们有一个桶数量为 &lt;code>b&lt;/code> 的 HyperLogLog。我们将哈希值的前 &lt;code>log2(b)&lt;/code> 位作为桶的索引，其余的位用于计算前导零数量。&lt;/p>
&lt;ul>
&lt;li>例如，如果我们有 16 个桶（&lt;code>b = 16&lt;/code>），则桶的索引由哈希值的前 4 位决定（因为 &lt;code>log2(16) = 4&lt;/code>）。如果哈希值的前 4 位为 &lt;code>1100&lt;/code>，那么该哈希值将被映射到第 12 号桶（因为 &lt;code>1100&lt;/code> 二进制对应 12）。&lt;/li>
&lt;/ul>
&lt;h5 id="4-计算基数估算">&lt;strong>4. 计算基数估算&lt;/strong>&lt;/h5>
&lt;p>HyperLogLog 会计算所有桶中记录的前导零最大值的平均值。然后根据这个平均值来估算整个数据集的基数。&lt;br>
其数学公式如下：&lt;/p></description><content type="html"><![CDATA[<p>Redis 在 2.8.9 版本添加了 HyperLogLog （HLL）。<br>
HyperLogLog 是一种高效的基数估算工具，通过概率算法和哈希化技术，在常数空间内提供了基数的估算。</p>
<p><em>eg</em>.</p>
<ul>
<li>统计一个网站的独立用户数。</li>
<li>统计一个日志中的独立 IP 数量。</li>
<li>计算一个流中的独立事件数。</li>
</ul>
<p>传统的做法是将所有元素存储在集合中，然后进行去重、计数。但当集合的元素数量非常大时，这种方法会占用大量内存，甚至无法存储所有数据。<br>
HyperLogLog 有一定误差，但对于海量数据来说，它的内存开销极低且精度足够高，非常适合用于大数据处理、流量统计、去重计数等场景。</p>
<p>Redis 中的 HyperLogLog 支持以下操作：</p>
<ul>
<li><strong><code>PFADD</code></strong>：将元素添加到 HyperLogLog 中，Redis 会对元素进行哈希处理，并更新相应的桶。</li>
<li><strong><code>PFCOUNT</code></strong>：返回一个或多个 HyperLogLog 键的基数估算。</li>
<li><strong><code>PFMERGE</code></strong>：合并多个 HyperLogLog 键的基数估算。</li>
</ul>
<hr>
<h3 id="核心思想">核心思想</h3>
<p>HyperLogLog 使用概率算法，通过哈希化数据并记录哈希值的前导零数量来估算基数。</p>
<h5 id="1-哈希函数与二进制表示"><strong>1. 哈希函数与二进制表示</strong></h5>
<p>为了将集合中的元素映射为哈希值，HyperLogLog 使用了 <strong>哈希函数</strong>。假设我们使用一个 <strong>m-bit</strong> 的哈希函数，它会把输入数据映射到一个包含 m 位二进制数字的哈希值。</p>
<p>例如：</p>
<ul>
<li>假设我们将一个元素哈希成 <code>10111001101100010101010101101010</code> 这样的 32 位二进制数字。</li>
<li>这个哈希值的前导零数量就是我们关心的指标。对于这个例子，假设前导零的数量为 3。</li>
</ul>
<h5 id="2-关键点记录前导零的数量"><strong>2. 关键点：记录前导零的数量</strong></h5>
<p>HyperLogLog 并不直接存储每个哈希值，而是计算每个哈希值的前导零的数量，把这个值保存在一个桶（通过哈希值的某些位进行映射）中。</p>
<h5 id="3-桶与桶编号"><strong>3. 桶与桶编号</strong></h5>
<p>为了优化空间，HyperLogLog 使用多个桶来存储不同的哈希值。每个桶的索引是由哈希值的某些位生成的。假设我们有一个桶数量为 <code>b</code> 的 HyperLogLog。我们将哈希值的前 <code>log2(b)</code> 位作为桶的索引，其余的位用于计算前导零数量。</p>
<ul>
<li>例如，如果我们有 16 个桶（<code>b = 16</code>），则桶的索引由哈希值的前 4 位决定（因为 <code>log2(16) = 4</code>）。如果哈希值的前 4 位为 <code>1100</code>，那么该哈希值将被映射到第 12 号桶（因为 <code>1100</code> 二进制对应 12）。</li>
</ul>
<h5 id="4-计算基数估算"><strong>4. 计算基数估算</strong></h5>
<p>HyperLogLog 会计算所有桶中记录的前导零最大值的平均值。然后根据这个平均值来估算整个数据集的基数。<br>
其数学公式如下：</p>
<p>[ \text{Estimate} = \alpha \times m^2 \times 2^{\bar{R}} ]</p>
<p>其中：</p>
<ul>
<li>( \alpha ) 是一个常数，通常为 0.7213 / (1 + 1.079 / m)，用来调整估算的误差。</li>
<li>( m ) 是桶的数量。</li>
<li>( \bar{R} ) 是所有桶中的前导零数量的平均值。</li>
</ul>
<h5 id="5-桶的数量和误差"><strong>5. 桶的数量和误差</strong></h5>
<p>桶的数量 ( m ) 直接影响 HyperLogLog 的估算精度。通常，桶的数量越多精度越高，但内存消耗也会相应增加。Redis 默认使用 14 个字节来存储 HyperLogLog，这大约可以提供 0.81% 的误差。</p>
<hr>
<p>详细讲解：<a href="https://blog.csdn.net/qq_42581682/article/details/136756947">Redis中的HyperLogLog以及HyperLogLog原理</a>。</p>
]]></content></item><item><title>Linux 大文件传输场景题</title><link>https://jekyulll.github.io/posts/linux-linux-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%9C%BA%E6%99%AF%E9%A2%98/</link><pubDate>Tue, 07 Jan 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-linux-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%9C%BA%E6%99%AF%E9%A2%98/</guid><description>&lt;p>(考察linux网络编程、系统编程、网络协议、网络传输协议等知识)&lt;/p>
&lt;blockquote>
&lt;p>问：局域网内有A、B、C三台主机，A与B不知道相互之间的IP。A要向B传输一个1G的文件，怎么做？&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;ol>
&lt;li>大文件传输的优化：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>分块传输：将大文件分成多个小块（如4KB、8KB等），每次传输一块，避免占用过多内存。&lt;/li>
&lt;li>校验和（Checksum）：在每一块传输后进行数据校验，确保数据的完整性。&lt;/li>
&lt;li>带宽控制：通过控制每次发送的数据量来避免一次性传输过多数据，控制网络负载。&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>断点续传的实现：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>记录传输进度：客户端和服务器都需要记录已经成功传输的数据块或字节的位置。&lt;/li>
&lt;li>支持断点请求：客户端在恢复传输时，应该告知服务器从哪个位置开始传输。&lt;/li>
&lt;li>校验和和确认机制：每次传输数据块后，都应该进行确认，确保数据正确传送。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>步骤&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>使用局域网广播发现B的IP地址
由于A和B的IP地址不直接已知，A可以通过&lt;strong>局域网广播&lt;/strong>来找到B的IP地址。A可以向网络中的所有主机发送一个&lt;em>UDP广播消息&lt;/em>，所有主机都会接收到这个消息，B在接收到这个广播后，可以回复A，告知自己的IP地址。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>UDP广播&lt;/strong>：A可以通过发送一个UDP广播包到特定的端口，让局域网中的所有主机收到该消息。B可以通过监听这个端口，收到消息后回应自己的IP地址。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>使用TCP协议进行文件传输
一旦A得到了B的IP地址，就可以使用TCP协议进行文件传输。A通过TCP连接到B，建立数据通道，开始发送1GB的文件。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="1-udp广播发现b的ip地址">1. UDP广播发现B的IP地址&lt;/h3>
&lt;p>A使用UDP广播向局域网中的所有主机发送请求，B收到请求后会通过UDP回应自己的IP地址。&lt;/p>
&lt;h4 id="a端发送udp广播请求">A端：发送UDP广播请求&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;arpa/inet.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define BROADCAST_PORT 12345
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">send_broadcast_message&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sockfd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in&lt;/span> broadcast_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> broadcast_enable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Are you there, B? Please reply with your IP address.&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建UDP套接字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> sockfd &lt;span style="color:#f92672">=&lt;/span> socket(AF_INET, SOCK_DGRAM, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (sockfd &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Socket creation failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 允许广播
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &lt;span style="color:#f92672">&amp;amp;&lt;/span>broadcast_enable, &lt;span style="color:#66d9ef">sizeof&lt;/span>(broadcast_enable)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Setting broadcast option failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>broadcast_addr, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(broadcast_addr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> broadcast_addr.sin_family &lt;span style="color:#f92672">=&lt;/span> AF_INET;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> broadcast_addr.sin_port &lt;span style="color:#f92672">=&lt;/span> htons(BROADCAST_PORT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> broadcast_addr.sin_addr.s_addr &lt;span style="color:#f92672">=&lt;/span> htonl(INADDR_BROADCAST);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 发送广播消息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (sendto(sockfd, message, strlen(message), &lt;span style="color:#ae81ff">0&lt;/span>, (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>broadcast_addr, &lt;span style="color:#66d9ef">sizeof&lt;/span>(broadcast_addr)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Broadcast failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Broadcast message sent!&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> send_broadcast_message();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="b端接收udp广播并回应自己的ip">B端：接收UDP广播并回应自己的IP&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;arpa/inet.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define BROADCAST_PORT 12345
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define RESPONSE_PORT 12346
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">listen_for_broadcasts&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sockfd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in&lt;/span> server_addr, client_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> socklen_t client_len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(client_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> buffer[&lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建UDP套接字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> sockfd &lt;span style="color:#f92672">=&lt;/span> socket(AF_INET, SOCK_DGRAM, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (sockfd &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Socket creation failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>server_addr, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(server_addr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server_addr.sin_family &lt;span style="color:#f92672">=&lt;/span> AF_INET;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server_addr.sin_port &lt;span style="color:#f92672">=&lt;/span> htons(BROADCAST_PORT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server_addr.sin_addr.s_addr &lt;span style="color:#f92672">=&lt;/span> htonl(INADDR_ANY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 绑定UDP套接字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (bind(sockfd, (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>server_addr, &lt;span style="color:#66d9ef">sizeof&lt;/span>(server_addr)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Bind failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 接收广播消息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (true) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> recv_len &lt;span style="color:#f92672">=&lt;/span> recvfrom(sockfd, buffer, &lt;span style="color:#66d9ef">sizeof&lt;/span>(buffer), &lt;span style="color:#ae81ff">0&lt;/span>, (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>client_addr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>client_len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (recv_len &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Failed to receive message&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer[recv_len] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Received message: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> buffer &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果消息包含特定请求，可以回复自己的IP地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string response &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;IP Address of B: &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response &lt;span style="color:#f92672">+=&lt;/span> inet_ntoa(client_addr.sin_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sendto(sockfd, response.c_str(), response.length(), &lt;span style="color:#ae81ff">0&lt;/span>, (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>client_addr, client_len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sent response with IP address: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> inet_ntoa(client_addr.sin_addr) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listen_for_broadcasts();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-使用tcp协议传输文件">2. 使用TCP协议传输文件&lt;/h3>
&lt;p>一旦A得到了B的IP地址，A就可以通过TCP连接与B进行文件传输。&lt;/p></description><content type="html"><![CDATA[<p>(考察linux网络编程、系统编程、网络协议、网络传输协议等知识)</p>
<blockquote>
<p>问：局域网内有A、B、C三台主机，A与B不知道相互之间的IP。A要向B传输一个1G的文件，怎么做？</p>
</blockquote>
<hr>
<ol>
<li>大文件传输的优化：</li>
</ol>
<ul>
<li>分块传输：将大文件分成多个小块（如4KB、8KB等），每次传输一块，避免占用过多内存。</li>
<li>校验和（Checksum）：在每一块传输后进行数据校验，确保数据的完整性。</li>
<li>带宽控制：通过控制每次发送的数据量来避免一次性传输过多数据，控制网络负载。</li>
</ul>
<ol start="2">
<li>断点续传的实现：</li>
</ol>
<ul>
<li>记录传输进度：客户端和服务器都需要记录已经成功传输的数据块或字节的位置。</li>
<li>支持断点请求：客户端在恢复传输时，应该告知服务器从哪个位置开始传输。</li>
<li>校验和和确认机制：每次传输数据块后，都应该进行确认，确保数据正确传送。</li>
</ul>
<hr>
<p><strong>步骤</strong>：</p>
<ol>
<li>使用局域网广播发现B的IP地址
由于A和B的IP地址不直接已知，A可以通过<strong>局域网广播</strong>来找到B的IP地址。A可以向网络中的所有主机发送一个<em>UDP广播消息</em>，所有主机都会接收到这个消息，B在接收到这个广播后，可以回复A，告知自己的IP地址。</li>
</ol>
<ul>
<li><strong>UDP广播</strong>：A可以通过发送一个UDP广播包到特定的端口，让局域网中的所有主机收到该消息。B可以通过监听这个端口，收到消息后回应自己的IP地址。</li>
</ul>
<ol>
<li>使用TCP协议进行文件传输
一旦A得到了B的IP地址，就可以使用TCP协议进行文件传输。A通过TCP连接到B，建立数据通道，开始发送1GB的文件。</li>
</ol>
<hr>
<h3 id="1-udp广播发现b的ip地址">1. UDP广播发现B的IP地址</h3>
<p>A使用UDP广播向局域网中的所有主机发送请求，B收到请求后会通过UDP回应自己的IP地址。</p>
<h4 id="a端发送udp广播请求">A端：发送UDP广播请求</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BROADCAST_PORT 12345
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">send_broadcast_message</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sockfd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> broadcast_addr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> broadcast_enable <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Are you there, B? Please reply with your IP address.&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建UDP套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sockfd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_DGRAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sockfd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Socket creation failed&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 允许广播
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, <span style="color:#f92672">&amp;</span>broadcast_enable, <span style="color:#66d9ef">sizeof</span>(broadcast_enable)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Setting broadcast option failed&#34;</span>);
</span></span><span style="display:flex;"><span>        close(sockfd);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>broadcast_addr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(broadcast_addr));
</span></span><span style="display:flex;"><span>    broadcast_addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    broadcast_addr.sin_port <span style="color:#f92672">=</span> htons(BROADCAST_PORT);
</span></span><span style="display:flex;"><span>    broadcast_addr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_BROADCAST);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 发送广播消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (sendto(sockfd, message, strlen(message), <span style="color:#ae81ff">0</span>, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>broadcast_addr, <span style="color:#66d9ef">sizeof</span>(broadcast_addr)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Broadcast failed&#34;</span>);
</span></span><span style="display:flex;"><span>        close(sockfd);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Broadcast message sent!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    close(sockfd);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    send_broadcast_message();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="b端接收udp广播并回应自己的ip">B端：接收UDP广播并回应自己的IP</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BROADCAST_PORT 12345
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define RESPONSE_PORT 12346
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listen_for_broadcasts</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sockfd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> server_addr, client_addr;
</span></span><span style="display:flex;"><span>    socklen_t client_len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(client_addr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">1024</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建UDP套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sockfd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_DGRAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sockfd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Socket creation failed&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(server_addr));
</span></span><span style="display:flex;"><span>    server_addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    server_addr.sin_port <span style="color:#f92672">=</span> htons(BROADCAST_PORT);
</span></span><span style="display:flex;"><span>    server_addr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 绑定UDP套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (bind(sockfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#66d9ef">sizeof</span>(server_addr)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Bind failed&#34;</span>);
</span></span><span style="display:flex;"><span>        close(sockfd);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 接收广播消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> recv_len <span style="color:#f92672">=</span> recvfrom(sockfd, buffer, <span style="color:#66d9ef">sizeof</span>(buffer), <span style="color:#ae81ff">0</span>, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>client_addr, <span style="color:#f92672">&amp;</span>client_len);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (recv_len <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            perror(<span style="color:#e6db74">&#34;Failed to receive message&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        buffer[recv_len] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Received message: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buffer <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果消息包含特定请求，可以回复自己的IP地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>string response <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;IP Address of B: &#34;</span>;
</span></span><span style="display:flex;"><span>        response <span style="color:#f92672">+=</span> inet_ntoa(client_addr.sin_addr);
</span></span><span style="display:flex;"><span>        sendto(sockfd, response.c_str(), response.length(), <span style="color:#ae81ff">0</span>, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>client_addr, client_len);
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Sent response with IP address: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> inet_ntoa(client_addr.sin_addr) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    close(sockfd);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    listen_for_broadcasts();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2-使用tcp协议传输文件">2. 使用TCP协议传输文件</h3>
<p>一旦A得到了B的IP地址，A就可以通过TCP连接与B进行文件传输。</p>
<h4 id="a端通过tcp向b发送文件">A端：通过TCP向B发送文件</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define SERVER_PORT 8080
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define CHUNK_SIZE 4096 </span><span style="color:#75715e">// 4KB per chunk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">send_file</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>filename, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>ip_address) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sockfd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> server_addr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buffer[CHUNK_SIZE];
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ifstream file(filename, std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>binary);
</span></span><span style="display:flex;"><span>    off_t offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 记录已经发送的文件偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建TCP套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sockfd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sockfd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Socket creation failed&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(server_addr));
</span></span><span style="display:flex;"><span>    server_addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    server_addr.sin_port <span style="color:#f92672">=</span> htons(SERVER_PORT);
</span></span><span style="display:flex;"><span>    server_addr.sin_addr.s_addr <span style="color:#f92672">=</span> inet_addr(ip_address.c_str());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 连接到B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (connect(sockfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#66d9ef">sizeof</span>(server_addr)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Connection failed&#34;</span>);
</span></span><span style="display:flex;"><span>        close(sockfd);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 发送文件的分块数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (file.read(buffer, CHUNK_SIZE)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 发送文件块数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ssize_t bytes_sent <span style="color:#f92672">=</span> send(sockfd, buffer, file.gcount(), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (bytes_sent <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            perror(<span style="color:#e6db74">&#34;Send failed&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">+=</span> bytes_sent;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 发送每个块后，需要确认接收进度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 可以通过协议的方式要求B确认
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Sent chunk, current offset: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> offset <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 发送文件剩余的数据（如果有）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (file.gcount() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        send(sockfd, buffer, file.gcount(), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">+=</span> file.gcount();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;File sent successfully! Total bytes sent: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> offset <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    close(sockfd);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    send_file(<span style="color:#e6db74">&#34;large_file.bin&#34;</span>, <span style="color:#e6db74">&#34;192.168.1.2&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="b端接收文件并保存">B端：接收文件并保存</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define SERVER_PORT 8080
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define CHUNK_SIZE 4096 </span><span style="color:#75715e">// 4KB per chunk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">receive_file</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>filename) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sockfd, newsockfd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> server_addr, client_addr;
</span></span><span style="display:flex;"><span>    socklen_t client_len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(client_addr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buffer[CHUNK_SIZE];
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ofstream file(filename, std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>binary <span style="color:#f92672">|</span> std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>app);  <span style="color:#75715e">// 以追加方式打开文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    off_t offset <span style="color:#f92672">=</span> file.tellp();  <span style="color:#75715e">// 获取文件当前的偏移量（即已经接收的字节数）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建TCP套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sockfd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sockfd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Socket creation failed&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(server_addr));
</span></span><span style="display:flex;"><span>    server_addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    server_addr.sin_port <span style="color:#f92672">=</span> htons(SERVER_PORT);
</span></span><span style="display:flex;"><span>    server_addr.sin_addr.s_addr <span style="color:#f92672">=</span> INADDR_ANY;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 绑定套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (bind(sockfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#66d9ef">sizeof</span>(server_addr)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Bind failed&#34;</span>);
</span></span><span style="display:flex;"><span>        close(sockfd);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 监听
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    listen(sockfd, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Waiting for connection...&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 接受连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    newsockfd <span style="color:#f92672">=</span> accept(sockfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>client_addr, <span style="color:#f92672">&amp;</span>client_len);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (newsockfd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        perror(<span style="color:#e6db74">&#34;Accept failed&#34;</span>);
</span></span><span style="display:flex;"><span>        close(sockfd);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 接收文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> recv_len <span style="color:#f92672">=</span> recv(newsockfd, buffer, CHUNK_SIZE, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (recv_len <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 写入文件（追加模式）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        file.write(buffer, recv_len);
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">+=</span> recv_len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Received chunk, current offset: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> offset <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;File received successfully! Total bytes received: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> offset <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    close(newsockfd);
</span></span><span style="display:flex;"><span>    close(sockfd);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    receive_file(<span style="color:#e6db74">&#34;received_large_file.bin&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>断点续传实现说明：</p>
<ul>
<li>A端：每发送完一个块，A会更新文件的偏移量（即<code>offset</code>），并传递该偏移量的信息。如果传输过程中发生中断，A可以记录上次发送的偏移量，从该位置开始重新传输。</li>
<li>B端：B端会在接收每个块时，记录接收到的字节数（即<code>offset</code>）。B端可以通过检查文件的大小来判断是否需要继续接收文件。如果B端关闭了连接，下次启动时会从文件尾部继续接收。</li>
</ul>
<h3 id="拓展">拓展：</h3>
<p><strong>MD5</strong>（Message Digest Algorithm 5）是一种广泛使用的加密哈希函数，它产生一个128位（16字节）的哈希值，通常用32个十六进制字符表示。MD5被设计用来接收任意长度的数据（通常是文件或消息）并生成一个固定长度的“摘要”或“指纹”，这个摘要用于验证数据的完整性。</p>
]]></content></item><item><title>分段锁技术详解及 C++ 实现</title><link>https://jekyulll.github.io/posts/cpp-%E5%88%86%E6%AE%B5%E9%94%81%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%E5%8F%8A-c++-%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 01 Jan 2025 14:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E5%88%86%E6%AE%B5%E9%94%81%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%E5%8F%8A-c++-%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>分段锁（Segmented Locking）是一种用于优化多线程访问共享资源时锁粒度的技术。它通过将资源分成多个小段，并为每段分配独立的锁，来减少锁的争用，从而提升并发性能。&lt;/p>
&lt;p>分段锁通过减少锁粒度，让多个线程可以同时访问不同的段，从而显著提高性能。这种方法常见于 &lt;strong>哈希表&lt;/strong>、&lt;strong>数据库索引&lt;/strong> 和其他高并发系统中。&lt;/p>
&lt;hr>
&lt;h4 id="基本原理">&lt;strong>基本原理&lt;/strong>&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>划分资源&lt;/strong>：
将容器划分为多个独立的段（&lt;code>segment&lt;/code>），每段可以包含一部分数据。例如，一个哈希表可以按哈希值将数据分配到多个桶（&lt;code>bucket&lt;/code>），每个桶代表一个段。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>独立加锁&lt;/strong>：
每个段都有一个独立的锁（如 &lt;code>std::mutex&lt;/code> 或 &lt;code>std::shared_mutex&lt;/code>），对该段的数据操作时，只需要锁定对应的段即可，其他段不受影响。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>映射规则&lt;/strong>：
通过某种映射规则（如哈希函数）将操作定位到特定的段。这种映射规则应尽可能均匀，以避免&lt;em>热点问题&lt;/em>（即某些段过于频繁被访问，导致锁竞争）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="适用场景">&lt;strong>适用场景&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>高并发读写&lt;/strong>：如多线程访问的大型哈希表、数据库索引。&lt;/li>
&lt;li>&lt;strong>热点数据分散&lt;/strong>：通过分段减少单点锁的争用，提升性能。&lt;/li>
&lt;li>&lt;strong>读多写少&lt;/strong>：可以结合 &lt;code>std::shared_mutex&lt;/code> 提供共享锁和独占锁，进一步优化读性能。&lt;/li>
&lt;/ul>
&lt;p>注：&lt;strong>负载不均风险&lt;/strong>：如果映射规则不合理，可能导致某些段成为热点(eg. 热点桶)，影响性能。&lt;/p>
&lt;hr>
&lt;p>下面通过一个线程安全的哈希表（&lt;code>ThreadSafeHashMap&lt;/code>）来展示分段锁的实现(用&lt;code>std::vector&lt;/code>简单模拟)。&lt;/p>
&lt;ol>
&lt;li>将哈希表分为多个桶（&lt;code>bucket&lt;/code>），每个桶独立管理其数据。&lt;/li>
&lt;li>使用哈希函数将键映射到对应的桶。&lt;/li>
&lt;li>为每个桶分配一个 &lt;code>std::mutex&lt;/code> 来保护数据。&lt;/li>
&lt;li>对于读操作，只锁定对应的桶，支持并行读取。&lt;/li>
&lt;li>对于写操作，也只锁定对应的桶，减少锁的范围。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;shared_mutex&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;thread&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> Key, &lt;span style="color:#66d9ef">typename&lt;/span> Value&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadSafeHashMap&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Bucket&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shared_mutex mtx; &lt;span style="color:#75715e">// 每个桶的独立锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>Key, Value&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Bucket&lt;span style="color:#f92672">&amp;gt;&lt;/span> buckets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t num_buckets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 哈希函数，将键映射到对应的桶
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> size_t &lt;span style="color:#a6e22e">hash&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Key&lt;span style="color:#f92672">&amp;amp;&lt;/span> key) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>hash&lt;span style="color:#f92672">&amp;lt;&lt;/span>Key&lt;span style="color:#f92672">&amp;gt;&lt;/span>{}(key) &lt;span style="color:#f92672">%&lt;/span> num_buckets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadSafeHashMap(size_t num_buckets &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> num_buckets(num_buckets) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buckets.resize(num_buckets);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 插入操作，按桶分段加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">insert&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Key&lt;span style="color:#f92672">&amp;amp;&lt;/span> key, &lt;span style="color:#66d9ef">const&lt;/span> Value&lt;span style="color:#f92672">&amp;amp;&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t index &lt;span style="color:#f92672">=&lt;/span> hash(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(buckets[index].mtx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buckets[index].data.push_back({key, value});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 查找操作，按桶分段加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Key&lt;span style="color:#f92672">&amp;amp;&lt;/span> key, Value&lt;span style="color:#f92672">&amp;amp;&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t index &lt;span style="color:#f92672">=&lt;/span> hash(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shared_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(buckets[index].mtx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair : buckets[index].data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pair.first &lt;span style="color:#f92672">==&lt;/span> key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#f92672">=&lt;/span> pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 删除操作，按桶分段加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Key&lt;span style="color:#f92672">&amp;amp;&lt;/span> key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t index &lt;span style="color:#f92672">=&lt;/span> hash(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(buckets[index].mtx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> bucket &lt;span style="color:#f92672">=&lt;/span> buckets[index].data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> bucket.begin(); it &lt;span style="color:#f92672">!=&lt;/span> bucket.end(); &lt;span style="color:#f92672">++&lt;/span>it) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first &lt;span style="color:#f92672">==&lt;/span> key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bucket.erase(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadSafeHashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 多线程插入数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t1([&lt;span style="color:#f92672">&amp;amp;&lt;/span>]() { map.insert(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;one&amp;#34;&lt;/span>); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t2([&lt;span style="color:#f92672">&amp;amp;&lt;/span>]() { map.insert(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;two&amp;#34;&lt;/span>); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t3([&lt;span style="color:#f92672">&amp;amp;&lt;/span>]() { map.insert(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;three&amp;#34;&lt;/span>); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t1.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t2.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t3.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 查找数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map.find(&lt;span style="color:#ae81ff">2&lt;/span>, value)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Found: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> value &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 删除数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> map.erase(&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>像 &lt;a href="https://github.com/uxlfoundation/oneTBB">Intel TBB&lt;/a> 等并发库提供了更加高效的线程安全容器。&lt;/p></description><content type="html"><![CDATA[<p>分段锁（Segmented Locking）是一种用于优化多线程访问共享资源时锁粒度的技术。它通过将资源分成多个小段，并为每段分配独立的锁，来减少锁的争用，从而提升并发性能。</p>
<p>分段锁通过减少锁粒度，让多个线程可以同时访问不同的段，从而显著提高性能。这种方法常见于 <strong>哈希表</strong>、<strong>数据库索引</strong> 和其他高并发系统中。</p>
<hr>
<h4 id="基本原理"><strong>基本原理</strong></h4>
<ol>
<li>
<p><strong>划分资源</strong>：
将容器划分为多个独立的段（<code>segment</code>），每段可以包含一部分数据。例如，一个哈希表可以按哈希值将数据分配到多个桶（<code>bucket</code>），每个桶代表一个段。</p>
</li>
<li>
<p><strong>独立加锁</strong>：
每个段都有一个独立的锁（如 <code>std::mutex</code> 或 <code>std::shared_mutex</code>），对该段的数据操作时，只需要锁定对应的段即可，其他段不受影响。</p>
</li>
<li>
<p><strong>映射规则</strong>：
通过某种映射规则（如哈希函数）将操作定位到特定的段。这种映射规则应尽可能均匀，以避免<em>热点问题</em>（即某些段过于频繁被访问，导致锁竞争）。</p>
</li>
</ol>
<hr>
<h4 id="适用场景"><strong>适用场景</strong></h4>
<ul>
<li><strong>高并发读写</strong>：如多线程访问的大型哈希表、数据库索引。</li>
<li><strong>热点数据分散</strong>：通过分段减少单点锁的争用，提升性能。</li>
<li><strong>读多写少</strong>：可以结合 <code>std::shared_mutex</code> 提供共享锁和独占锁，进一步优化读性能。</li>
</ul>
<p>注：<strong>负载不均风险</strong>：如果映射规则不合理，可能导致某些段成为热点(eg. 热点桶)，影响性能。</p>
<hr>
<p>下面通过一个线程安全的哈希表（<code>ThreadSafeHashMap</code>）来展示分段锁的实现(用<code>std::vector</code>简单模拟)。</p>
<ol>
<li>将哈希表分为多个桶（<code>bucket</code>），每个桶独立管理其数据。</li>
<li>使用哈希函数将键映射到对应的桶。</li>
<li>为每个桶分配一个 <code>std::mutex</code> 来保护数据。</li>
<li>对于读操作，只锁定对应的桶，支持并行读取。</li>
<li>对于写操作，也只锁定对应的桶，减少锁的范围。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;shared_mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Key, <span style="color:#66d9ef">typename</span> Value<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadSafeHashMap</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Bucket</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>shared_mutex mtx; <span style="color:#75715e">// 每个桶的独立锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;&gt;</span> data;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Bucket<span style="color:#f92672">&gt;</span> buckets;
</span></span><span style="display:flex;"><span>    size_t num_buckets;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 哈希函数，将键映射到对应的桶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t <span style="color:#a6e22e">hash</span>(<span style="color:#66d9ef">const</span> Key<span style="color:#f92672">&amp;</span> key) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>hash<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span>{}(key) <span style="color:#f92672">%</span> num_buckets;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ThreadSafeHashMap(size_t num_buckets <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>) <span style="color:#f92672">:</span> num_buckets(num_buckets) {
</span></span><span style="display:flex;"><span>        buckets.resize(num_buckets);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 插入操作，按桶分段加锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">const</span> Key<span style="color:#f92672">&amp;</span> key, <span style="color:#66d9ef">const</span> Value<span style="color:#f92672">&amp;</span> value) {
</span></span><span style="display:flex;"><span>        size_t index <span style="color:#f92672">=</span> hash(key);
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_mutex<span style="color:#f92672">&gt;</span> lock(buckets[index].mtx);
</span></span><span style="display:flex;"><span>        buckets[index].data.push_back({key, value});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 查找操作，按桶分段加锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">const</span> Key<span style="color:#f92672">&amp;</span> key, Value<span style="color:#f92672">&amp;</span> value) {
</span></span><span style="display:flex;"><span>        size_t index <span style="color:#f92672">=</span> hash(key);
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>shared_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_mutex<span style="color:#f92672">&gt;</span> lock(buckets[index].mtx);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> pair : buckets[index].data) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pair.first <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>                value <span style="color:#f92672">=</span> pair.second;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 删除操作，按桶分段加锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">erase</span>(<span style="color:#66d9ef">const</span> Key<span style="color:#f92672">&amp;</span> key) {
</span></span><span style="display:flex;"><span>        size_t index <span style="color:#f92672">=</span> hash(key);
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_mutex<span style="color:#f92672">&gt;</span> lock(buckets[index].mtx);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> bucket <span style="color:#f92672">=</span> buckets[index].data;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> bucket.begin(); it <span style="color:#f92672">!=</span> bucket.end(); <span style="color:#f92672">++</span>it) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (it<span style="color:#f92672">-&gt;</span>first <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>                bucket.erase(it);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    ThreadSafeHashMap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 多线程插入数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1([<span style="color:#f92672">&amp;</span>]() { map.insert(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;one&#34;</span>); });
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2([<span style="color:#f92672">&amp;</span>]() { map.insert(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;two&#34;</span>); });
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t3([<span style="color:#f92672">&amp;</span>]() { map.insert(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;three&#34;</span>); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    t1.join();
</span></span><span style="display:flex;"><span>    t2.join();
</span></span><span style="display:flex;"><span>    t3.join();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 查找数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>string value;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (map.find(<span style="color:#ae81ff">2</span>, value)) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Found: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 删除数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    map.erase(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>像 <a href="https://github.com/uxlfoundation/oneTBB">Intel TBB</a> 等并发库提供了更加高效的线程安全容器。</p>
<blockquote>
<p>TBB(Thread Building Blocks)是英特尔发布的一个库，全称为 Threading Building Blocks。TBB 获得过 17 届 Jolt Productivity Awards，是一套 C++ 模板库。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get install libtbb-dev  <span style="color:#75715e"># Ubuntu/Debian</span>
</span></span><span style="display:flex;"><span>sudo yum install tbb-devel       <span style="color:#75715e"># CentOS/Red Hat</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>./vcpkg install tbb
</span></span><span style="display:flex;"><span>conan install tbb
</span></span><span style="display:flex;"><span>brew install tbb
</span></span></code></pre></div>]]></content></item><item><title>简述如何解决哈希冲突？</title><link>https://jekyulll.github.io/posts/cpp-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</link><pubDate>Wed, 01 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</guid><description>&lt;blockquote>
&lt;p>哈希冲突是指 &lt;strong>不同的输入&lt;/strong>（通常是不同的键）通过哈希函数计算后，得到相同的哈希值并被映射到相同的桶或位置。这是哈希算法的一个固有问题，通常发生在哈希表中。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h4 id="为什么会有哈希冲突">&lt;strong>为什么会有哈希冲突？&lt;/strong>&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>有限的哈希空间&lt;/strong>：&lt;br>
假设哈希函数将键映射到一个固定大小的数组中，哈希表的桶数有限，而键的数量可能很大（例如百万个不同的键），那么无论哈希函数设计得多么巧妙，都可能有多个键映射到同一个桶。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>哈希函数的碰撞&lt;/strong>：&lt;br>
哈希函数的设计决定了如何将键映射到哈希表的桶中。如果哈希函数不足够“分散”键值，导致多个键的哈希值相同，就会产生冲突。即使两个键的实际值不同，它们也可能因为哈希函数的限制而得到相同的哈希值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>键的分布不均匀&lt;/strong>：&lt;br>
如果数据（即键）在哈希表中的分布不均匀，某些桶可能会有大量的键，而其他桶则几乎没有。这通常是由于选择的哈希函数无法均匀地分布键值，导致哈希冲突在某些桶中更加集中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>哈希冲突的发生是不可避免的，因为：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>有限的输出空间&lt;/strong>：
哈希函数的输出通常是固定长度的（比如 32 位、64 位或更高），而实际的输入数据可以非常庞大。例如，输入可能是所有的整数、字符串或者更复杂的数据结构，数量远远超过了哈希值的种类。因此，总会有两个不同的输入数据被映射到相同的哈希值（即哈希冲突）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>抽象数据类型&lt;/strong>：
对于复杂的数据类型（如对象、结构体、字符串等），设计一个完美的哈希函数是非常困难的。在某些情况下，即使设计了高效的哈希算法，也很难保证哈希值的完全均匀分布，因此冲突不可避免。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="如何处理哈希冲突">&lt;strong>如何处理哈希冲突？&lt;/strong>&lt;/h3>
&lt;p>尽管哈希冲突不可避免，但我们可以采用多种方法来解决或减少冲突的影响：&lt;/p>
&lt;h4 id="1-链表法separate-chaining">1. &lt;strong>链表法（Separate Chaining）&lt;/strong>&lt;/h4>
&lt;p>每个桶（哈希表的一个位置）存储一个链表，所有映射到相同哈希值的元素都放在这个链表中。虽然哈希冲突发生，但可以通过遍历链表来解决。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>优点&lt;/strong>：简单易懂，适用于动态扩容。&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：性能取决于链表的长度，如果链表较长，查找、插入、删除的时间复杂度会退化为 &lt;code>O(n)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h4 id="2-开放地址法open-addressing">2. &lt;strong>开放地址法（Open Addressing）&lt;/strong>&lt;/h4>
&lt;p>在这种方法中，当哈希冲突发生时，程序会尝试在表中寻找另一个空的位置来存储数据。常见的解决方式包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>线性探测&lt;/strong>：检查当前位置之后的下一个位置，直到找到空位。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>二次探测&lt;/strong>：尝试检查当前位置之后的平方距离的其他位置，避免线性探测中可能出现的聚集问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>双重哈希&lt;/strong>：使用第二个哈希函数来决定探测的步长。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>优点&lt;/strong>：避免了链表法的额外内存开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缺点&lt;/strong>：当哈希表装载过高时，查找效率会下降。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="3-再哈希rehashing">3. &lt;strong>再哈希（Rehashing）&lt;/strong>&lt;/h4>
&lt;p>再哈希是通过扩展哈希表的大小并重新计算每个元素的哈希值来解决冲突。当哈希表装载因子过高时（即元素数量接近桶的数量），会触发再哈希过程。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>优点&lt;/strong>：能够有效减少冲突，提高性能。&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：再哈希时会涉及到大量的重新计算和内存分配，可能导致性能下降。&lt;/li>
&lt;/ul>
&lt;h4 id="4-使用平衡树如红黑树">4. &lt;strong>使用平衡树（如红黑树）&lt;/strong>&lt;/h4>
&lt;p>在哈希表中，如果某个桶的冲突过多，可以使用红黑树（或者其他平衡二叉树）来存储冲突的元素，这样可以在每个桶内保持较好的查找、插入性能。红黑树的查找、插入、删除时间复杂度为 &lt;code>O(log N)&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>优点&lt;/strong>：比链表法更高效，能够提供对数时间的操作。&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：相比链表法，维护平衡树需要更多的时间和内存。&lt;/li>
&lt;/ul></description><content type="html"><![CDATA[<blockquote>
<p>哈希冲突是指 <strong>不同的输入</strong>（通常是不同的键）通过哈希函数计算后，得到相同的哈希值并被映射到相同的桶或位置。这是哈希算法的一个固有问题，通常发生在哈希表中。</p>
</blockquote>
<hr>
<h4 id="为什么会有哈希冲突"><strong>为什么会有哈希冲突？</strong></h4>
<ol>
<li>
<p><strong>有限的哈希空间</strong>：<br>
假设哈希函数将键映射到一个固定大小的数组中，哈希表的桶数有限，而键的数量可能很大（例如百万个不同的键），那么无论哈希函数设计得多么巧妙，都可能有多个键映射到同一个桶。</p>
</li>
<li>
<p><strong>哈希函数的碰撞</strong>：<br>
哈希函数的设计决定了如何将键映射到哈希表的桶中。如果哈希函数不足够“分散”键值，导致多个键的哈希值相同，就会产生冲突。即使两个键的实际值不同，它们也可能因为哈希函数的限制而得到相同的哈希值。</p>
</li>
<li>
<p><strong>键的分布不均匀</strong>：<br>
如果数据（即键）在哈希表中的分布不均匀，某些桶可能会有大量的键，而其他桶则几乎没有。这通常是由于选择的哈希函数无法均匀地分布键值，导致哈希冲突在某些桶中更加集中。</p>
</li>
</ol>
<p>哈希冲突的发生是不可避免的，因为：</p>
<ul>
<li>
<p><strong>有限的输出空间</strong>：
哈希函数的输出通常是固定长度的（比如 32 位、64 位或更高），而实际的输入数据可以非常庞大。例如，输入可能是所有的整数、字符串或者更复杂的数据结构，数量远远超过了哈希值的种类。因此，总会有两个不同的输入数据被映射到相同的哈希值（即哈希冲突）。</p>
</li>
<li>
<p><strong>抽象数据类型</strong>：
对于复杂的数据类型（如对象、结构体、字符串等），设计一个完美的哈希函数是非常困难的。在某些情况下，即使设计了高效的哈希算法，也很难保证哈希值的完全均匀分布，因此冲突不可避免。</p>
</li>
</ul>
<hr>
<h3 id="如何处理哈希冲突"><strong>如何处理哈希冲突？</strong></h3>
<p>尽管哈希冲突不可避免，但我们可以采用多种方法来解决或减少冲突的影响：</p>
<h4 id="1-链表法separate-chaining">1. <strong>链表法（Separate Chaining）</strong></h4>
<p>每个桶（哈希表的一个位置）存储一个链表，所有映射到相同哈希值的元素都放在这个链表中。虽然哈希冲突发生，但可以通过遍历链表来解决。</p>
<ul>
<li><strong>优点</strong>：简单易懂，适用于动态扩容。</li>
<li><strong>缺点</strong>：性能取决于链表的长度，如果链表较长，查找、插入、删除的时间复杂度会退化为 <code>O(n)</code>。</li>
</ul>
<h4 id="2-开放地址法open-addressing">2. <strong>开放地址法（Open Addressing）</strong></h4>
<p>在这种方法中，当哈希冲突发生时，程序会尝试在表中寻找另一个空的位置来存储数据。常见的解决方式包括：</p>
<ul>
<li>
<p><strong>线性探测</strong>：检查当前位置之后的下一个位置，直到找到空位。</p>
</li>
<li>
<p><strong>二次探测</strong>：尝试检查当前位置之后的平方距离的其他位置，避免线性探测中可能出现的聚集问题。</p>
</li>
<li>
<p><strong>双重哈希</strong>：使用第二个哈希函数来决定探测的步长。</p>
</li>
<li>
<p><strong>优点</strong>：避免了链表法的额外内存开销。</p>
</li>
<li>
<p><strong>缺点</strong>：当哈希表装载过高时，查找效率会下降。</p>
</li>
</ul>
<h4 id="3-再哈希rehashing">3. <strong>再哈希（Rehashing）</strong></h4>
<p>再哈希是通过扩展哈希表的大小并重新计算每个元素的哈希值来解决冲突。当哈希表装载因子过高时（即元素数量接近桶的数量），会触发再哈希过程。</p>
<ul>
<li><strong>优点</strong>：能够有效减少冲突，提高性能。</li>
<li><strong>缺点</strong>：再哈希时会涉及到大量的重新计算和内存分配，可能导致性能下降。</li>
</ul>
<h4 id="4-使用平衡树如红黑树">4. <strong>使用平衡树（如红黑树）</strong></h4>
<p>在哈希表中，如果某个桶的冲突过多，可以使用红黑树（或者其他平衡二叉树）来存储冲突的元素，这样可以在每个桶内保持较好的查找、插入性能。红黑树的查找、插入、删除时间复杂度为 <code>O(log N)</code>。</p>
<ul>
<li><strong>优点</strong>：比链表法更高效，能够提供对数时间的操作。</li>
<li><strong>缺点</strong>：相比链表法，维护平衡树需要更多的时间和内存。</li>
</ul>
]]></content></item><item><title>C++ 编译器返回值优化</title><link>https://jekyulll.github.io/posts/cpp-c++-%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 23 Dec 2024 08:42:29 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</guid><description>&lt;p>在 C++ 中，当函数返回一个对象时，编译器通常需要进行对象的拷贝或移动操作。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>SomeClass &lt;span style="color:#a6e22e">createObject&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeClass obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置 obj 的一些成员
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> obj; &lt;span style="color:#75715e">// 返回一个对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在没有优化的情况下，&lt;code>obj&lt;/code> 被返回时，编译器可能会执行一次拷贝构造或移动构造操作，甚至可能是两次（先拷贝到临时对象，再从临时对象拷贝到目标变量）。这些额外的拷贝或移动操作会导致性能下降。&lt;/p>
&lt;p>为了减少这种不必要的开销，现代 C++ 编译器通常会进行优化，减少返回值时的拷贝或移动，使用如 &lt;strong>RVO&lt;/strong> 和 &lt;strong>NRVO&lt;/strong> 的优化策略。&lt;/p>
&lt;h3 id="1-rvoreturn-value-optimization返回值优化">1. RVO（Return Value Optimization，返回值优化）&lt;/h3>
&lt;p>RVO（Return Value Optimization，返回值优化），编译器可以直接在目标变量的位置构造返回值，减少不必要的对象拷贝和内存开销。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>SomeClass &lt;span style="color:#a6e22e">createObject&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeClass obj; &lt;span style="color:#75715e">// 局部对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> obj; &lt;span style="color:#75715e">// 返回该对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在没有优化的情况下，&lt;code>obj&lt;/code> 被返回时，编译器可能会做两次操作：&lt;/p>
&lt;ol>
&lt;li>将 &lt;code>obj&lt;/code> 拷贝或移动到一个临时对象中。&lt;/li>
&lt;li>将临时对象拷贝或移动到调用者的目标变量。&lt;/li>
&lt;/ol>
&lt;p>RVO 的核心思想是，在函数返回临时对象时，编译器可以&lt;u>直接将返回值构造到调用者的接收变量中&lt;/u>，而无需通过中间的临时对象进行拷贝或移动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeClass obj &lt;span style="color:#f92672">=&lt;/span> createObject(); &lt;span style="color:#75715e">// RVO 优化将直接构造在 obj 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RVO 只适用于临时对象返回的场景，对于具名对象（有名称的局部对象），编译器一般不能直接应用 RVO。返回具名对象时，编译器会尝试应用 NRVO（Named Return Value Optimization，命名返回值优化），以减少不必要的拷贝或移动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>SomeClass &lt;span style="color:#a6e22e">createObject&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeClass obj; &lt;span style="color:#75715e">// 具名局部变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> obj; &lt;span style="color:#75715e">// 这里不能使用 RVO
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译器行为：&lt;/p></description><content type="html"><![CDATA[<p>在 C++ 中，当函数返回一个对象时，编译器通常需要进行对象的拷贝或移动操作。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>SomeClass <span style="color:#a6e22e">createObject</span>() {
</span></span><span style="display:flex;"><span>    SomeClass obj;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置 obj 的一些成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> obj;  <span style="color:#75715e">// 返回一个对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在没有优化的情况下，<code>obj</code> 被返回时，编译器可能会执行一次拷贝构造或移动构造操作，甚至可能是两次（先拷贝到临时对象，再从临时对象拷贝到目标变量）。这些额外的拷贝或移动操作会导致性能下降。</p>
<p>为了减少这种不必要的开销，现代 C++ 编译器通常会进行优化，减少返回值时的拷贝或移动，使用如 <strong>RVO</strong> 和 <strong>NRVO</strong> 的优化策略。</p>
<h3 id="1-rvoreturn-value-optimization返回值优化">1. RVO（Return Value Optimization，返回值优化）</h3>
<p>RVO（Return Value Optimization，返回值优化），编译器可以直接在目标变量的位置构造返回值，减少不必要的对象拷贝和内存开销。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>SomeClass <span style="color:#a6e22e">createObject</span>() {
</span></span><span style="display:flex;"><span>    SomeClass obj;   <span style="color:#75715e">// 局部对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> obj;      <span style="color:#75715e">// 返回该对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在没有优化的情况下，<code>obj</code> 被返回时，编译器可能会做两次操作：</p>
<ol>
<li>将 <code>obj</code> 拷贝或移动到一个临时对象中。</li>
<li>将临时对象拷贝或移动到调用者的目标变量。</li>
</ol>
<p>RVO 的核心思想是，在函数返回临时对象时，编译器可以<u>直接将返回值构造到调用者的接收变量中</u>，而无需通过中间的临时对象进行拷贝或移动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    SomeClass obj <span style="color:#f92672">=</span> createObject();  <span style="color:#75715e">// RVO 优化将直接构造在 obj 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>RVO 只适用于临时对象返回的场景，对于具名对象（有名称的局部对象），编译器一般不能直接应用 RVO。返回具名对象时，编译器会尝试应用 NRVO（Named Return Value Optimization，命名返回值优化），以减少不必要的拷贝或移动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>SomeClass <span style="color:#a6e22e">createObject</span>() {
</span></span><span style="display:flex;"><span>    SomeClass obj;   <span style="color:#75715e">// 具名局部变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> obj;      <span style="color:#75715e">// 这里不能使用 RVO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>编译器行为：</p>
<ul>
<li><strong>GCC/Clang</strong>：启用优化选项（如 <code>-O2</code> 或 <code>-O3</code>）时，编译器会自动应用 RVO 来优化返回临时对象的代码。</li>
<li><strong>MSVC</strong>：在 Visual Studio 中，编译器会自动应用 RVO，并且它通常比 GCC 和 Clang 更早地进行这种优化。</li>
</ul>
<h3 id="2-nrvonamed-return-value-optimization命名返回值优化">2. NRVO（Named Return Value Optimization，命名返回值优化）</h3>
<p>NRVO 可以看作是 RVO 的一种扩展。<br>
它仅在返回的是具名对象时有效。具体来说，当函数返回一个具名的局部变量时，NRVO 允许编译器直接将该局部变量的位置“转移”到调用者的接收变量中，而不需要进行拷贝或移动。</p>
<hr>
<h1 id="拓展">拓展</h1>
<p><a href="https://zhuanlan.zhihu.com/p/656372497">从函数中返回stl容器开销很大吗？</a></p>
<p>禁用 NRVO 优化的情况下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">X</span> {
</span></span><span style="display:flex;"><span>    X() { puts(<span style="color:#e6db74">&#34;X()&#34;</span>); }
</span></span><span style="display:flex;"><span>    X(<span style="color:#66d9ef">const</span> X<span style="color:#f92672">&amp;</span>) { puts(<span style="color:#e6db74">&#34;X(const X&amp;)&#34;</span>); }
</span></span><span style="display:flex;"><span>    X(X<span style="color:#f92672">&amp;&amp;</span>)<span style="color:#66d9ef">noexcept</span> { puts(<span style="color:#e6db74">&#34;X(X&amp;&amp;)&#34;</span>); }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>X() {puts(<span style="color:#e6db74">&#34;~X()&#34;</span>);}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>X <span style="color:#a6e22e">func</span>() {
</span></span><span style="display:flex;"><span>    X x;
</span></span><span style="display:flex;"><span>    puts(<span style="color:#e6db74">&#34;-----------&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> result <span style="color:#f92672">=</span> func();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>X()
-----------
X(X&amp;&amp;)
~X()
X(X&amp;&amp;)
~X()
~X()
</code></pre><p>如果启用了 命名返回值优化（NRVO），编译器可以直接将 <code>x</code> 移动到返回值位置，而无需额外的构造操作。<br>
由于 <code>x</code> 是一个左值，标准情况下会调用拷贝构造函数，但在返回时，由于是函数返回值（即返回局部变量），且需要将返回值传递给 <code>result</code>（通过移动语义优化），C++ 编译器通常会选择移动构造。</p>
]]></content></item><item><title>缓存的设计</title><link>https://jekyulll.github.io/posts/cpp-%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1/</link><pubDate>Sat, 21 Dec 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid><description>&lt;ol>
&lt;li>数据结构&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>std::unordered_map&lt;/code>：用于快速查找键值对。&lt;/li>
&lt;li>双向链表：与哈希表结合实现 LRU 缓存。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>淘汰策略&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>LRU&lt;/strong> (Least Recently Used)：删除最近最少使用的元素。&lt;/li>
&lt;li>&lt;strong>LFU&lt;/strong> (Least Frequently Used)：删除使用频率最低的元素。&lt;/li>
&lt;li>&lt;strong>FIFO&lt;/strong> (First In First Out)：删除最早进入缓存的元素。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>并发处理&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>读写锁&lt;/strong>（如std::shared_mutex）：允许多个读者或一个写者。&lt;/li>
&lt;li>&lt;strong>线程安全容器&lt;/strong>：可以使用库（如 TBB 或 Folly）提供的线程安全容器。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>高级优化&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>分片缓存&lt;/strong>：使用分片（sharding）将缓存划分成多个独立的部分，以减少锁争用。例如，使用键的哈希值对分片数量取模。&lt;/li>
&lt;li>&lt;strong>持久化&lt;/strong>：将缓存数据保存到磁盘（如使用 RocksDB 或 Redis），以便服务重启后恢复。&lt;/li>
&lt;li>&lt;strong>预加载&lt;/strong>：在服务启动时，预加载常用的数据到缓存中，减少冷启动时间。&lt;/li>
&lt;li>&lt;strong>分布式缓存&lt;/strong>：如果单机缓存不足，可以使用分布式缓存（如 Memcached 或 Redis）来扩展容量。&lt;/li>
&lt;li>&lt;strong>监控和调试&lt;/strong>：添加缓存命中率统计、日志记录和监控接口，以便分析性能和优化缓存策略。&lt;/li>
&lt;/ul></description><content type="html"><![CDATA[<ol>
<li>数据结构</li>
</ol>
<ul>
<li><code>std::unordered_map</code>：用于快速查找键值对。</li>
<li>双向链表：与哈希表结合实现 LRU 缓存。</li>
</ul>
<ol>
<li>淘汰策略</li>
</ol>
<ul>
<li><strong>LRU</strong> (Least Recently Used)：删除最近最少使用的元素。</li>
<li><strong>LFU</strong> (Least Frequently Used)：删除使用频率最低的元素。</li>
<li><strong>FIFO</strong> (First In First Out)：删除最早进入缓存的元素。</li>
</ul>
<ol>
<li>并发处理</li>
</ol>
<ul>
<li><strong>读写锁</strong>（如std::shared_mutex）：允许多个读者或一个写者。</li>
<li><strong>线程安全容器</strong>：可以使用库（如 TBB 或 Folly）提供的线程安全容器。</li>
</ul>
<ol>
<li>高级优化</li>
</ol>
<ul>
<li><strong>分片缓存</strong>：使用分片（sharding）将缓存划分成多个独立的部分，以减少锁争用。例如，使用键的哈希值对分片数量取模。</li>
<li><strong>持久化</strong>：将缓存数据保存到磁盘（如使用 RocksDB 或 Redis），以便服务重启后恢复。</li>
<li><strong>预加载</strong>：在服务启动时，预加载常用的数据到缓存中，减少冷启动时间。</li>
<li><strong>分布式缓存</strong>：如果单机缓存不足，可以使用分布式缓存（如 Memcached 或 Redis）来扩展容量。</li>
<li><strong>监控和调试</strong>：添加缓存命中率统计、日志记录和监控接口，以便分析性能和优化缓存策略。</li>
</ul>
]]></content></item><item><title>表格展示 MySQL 基础数据类型</title><link>https://jekyulll.github.io/posts/database-%E8%A1%A8%E6%A0%BC%E5%B1%95%E7%A4%BA-mysql-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Thu, 21 Nov 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/database-%E8%A1%A8%E6%A0%BC%E5%B1%95%E7%A4%BA-mysql-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数据类型&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>存储范围/格式&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>INT（整数型）&lt;/td>
&lt;td>存储整数，有不同的字节大小来适应不同范围的整数&lt;/td>
&lt;td>有TINYINT（1字节，范围 - 128到127）、SMALLINT（2字节，范围 - 32768到32767）、MEDIUMINT（3字节）、INT（4字节，范围 - 2147483648到2147483647）、BIGINT（8字节）&lt;/td>
&lt;td>&lt;code>age INT;&lt;/code>，可以存储像25这样的年龄值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FLOAT和DOUBLE（浮点型）&lt;/td>
&lt;td>用于存储带有小数部分的数值，FLOAT精度较低，DOUBLE精度较高&lt;/td>
&lt;td>FLOAT单精度浮点数，大约7位有效数字；DOUBLE双精度浮点数，大约15位有效数字&lt;/td>
&lt;td>&lt;code>price FLOAT;&lt;/code>可以存储像9.99这样的价格值，对于更高精度的科学计算可能使用&lt;code>measurement DOUBLE;&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DECIMAL&lt;/td>
&lt;td>精确的小数值存储，常用于金融等对精度要求极高的领域&lt;/td>
&lt;td>格式为DECIMAL(M,D)，M是数字总位数，D是小数点后的位数&lt;/td>
&lt;td>&lt;code>amount DECIMAL(10,2);&lt;/code>可以精确存储像12345.67这样的金额，其中总共可以存储10位数字，小数点后2位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CHAR&lt;/td>
&lt;td>定长字符串，存储固定长度的字符序列&lt;/td>
&lt;td>定义时指定长度，如CHAR(10)，最多存储10个字符，不足部分用空格填充&lt;/td>
&lt;td>&lt;code>code CHAR(5);&lt;/code>可以存储像&amp;rsquo;ABCD &amp;lsquo;（注意后面有空格）这样的字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VARCHAR&lt;/td>
&lt;td>可变长字符串，根据实际存储的字符长度占用空间&lt;/td>
&lt;td>定义最大长度，如VARCHAR(255)，实际存储多长就占用多少空间加上1 - 2字节用于记录长度&lt;/td>
&lt;td>&lt;code>name VARCHAR(50);&lt;/code>可以存储像&amp;rsquo;John Doe&amp;rsquo;这样的名字，长度小于等于50个字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TEXT&lt;/td>
&lt;td>用于存储大量文本内容&lt;/td>
&lt;td>有TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT，存储大小逐渐增大&lt;/td>
&lt;td>&lt;code>description TEXT;&lt;/code>可以存储一篇短文或者产品描述&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BLOB&lt;/td>
&lt;td>存储二进制大型对象，如图像、音频等&lt;/td>
&lt;td>有TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB，存储大小逐渐增大&lt;/td>
&lt;td>&lt;code>image BLOB;&lt;/code>可以存储一张照片的二进制数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DATE&lt;/td>
&lt;td>存储日期，格式为YYYY - MM - DD&lt;/td>
&lt;td>从1000 - 01 - 01到9999 - 12 - 31&lt;/td>
&lt;td>&lt;code>birth_date DATE;&lt;/code>可以存储像'2000 - 01 - 01&amp;rsquo;这样的出生日期&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TIME&lt;/td>
&lt;td>存储时间，格式为HH:MM:SS&lt;/td>
&lt;td>-&lt;/td>
&lt;td>&lt;code>start_time TIME;&lt;/code>可以存储像'09:00:00&amp;rsquo;这样的开始时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DATETIME&lt;/td>
&lt;td>存储日期和时间，格式为YYYY - MM - DD HH:MM:SS&lt;/td>
&lt;td>从1000 - 01 - 01 00:00:00到9999 - 12 - 31 23:59:59&lt;/td>
&lt;td>&lt;code>order_time DATETIME;&lt;/code>可以存储像'2024 - 01 - 01 10:30:00&amp;rsquo;这样的订单时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TIMESTAMP&lt;/td>
&lt;td>存储日期和时间戳，会受到时区影响&lt;/td>
&lt;td>从1970 - 01 - 01 00:00:00 UTC到2038 - 01 - 19 03:14:07 UTC&lt;/td>
&lt;td>&lt;code>update_time TIMESTAMP;&lt;/code>用于记录更新时间，在不同时区设置下可能会有变化&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description><content type="html"><![CDATA[<table>
  <thead>
      <tr>
          <th>数据类型</th>
          <th>描述</th>
          <th>存储范围/格式</th>
          <th>示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>INT（整数型）</td>
          <td>存储整数，有不同的字节大小来适应不同范围的整数</td>
          <td>有TINYINT（1字节，范围 - 128到127）、SMALLINT（2字节，范围 - 32768到32767）、MEDIUMINT（3字节）、INT（4字节，范围 - 2147483648到2147483647）、BIGINT（8字节）</td>
          <td><code>age INT;</code>，可以存储像25这样的年龄值</td>
      </tr>
      <tr>
          <td>FLOAT和DOUBLE（浮点型）</td>
          <td>用于存储带有小数部分的数值，FLOAT精度较低，DOUBLE精度较高</td>
          <td>FLOAT单精度浮点数，大约7位有效数字；DOUBLE双精度浮点数，大约15位有效数字</td>
          <td><code>price FLOAT;</code>可以存储像9.99这样的价格值，对于更高精度的科学计算可能使用<code>measurement DOUBLE;</code></td>
      </tr>
      <tr>
          <td>DECIMAL</td>
          <td>精确的小数值存储，常用于金融等对精度要求极高的领域</td>
          <td>格式为DECIMAL(M,D)，M是数字总位数，D是小数点后的位数</td>
          <td><code>amount DECIMAL(10,2);</code>可以精确存储像12345.67这样的金额，其中总共可以存储10位数字，小数点后2位</td>
      </tr>
      <tr>
          <td>CHAR</td>
          <td>定长字符串，存储固定长度的字符序列</td>
          <td>定义时指定长度，如CHAR(10)，最多存储10个字符，不足部分用空格填充</td>
          <td><code>code CHAR(5);</code>可以存储像&rsquo;ABCD &lsquo;（注意后面有空格）这样的字符串</td>
      </tr>
      <tr>
          <td>VARCHAR</td>
          <td>可变长字符串，根据实际存储的字符长度占用空间</td>
          <td>定义最大长度，如VARCHAR(255)，实际存储多长就占用多少空间加上1 - 2字节用于记录长度</td>
          <td><code>name VARCHAR(50);</code>可以存储像&rsquo;John Doe&rsquo;这样的名字，长度小于等于50个字符</td>
      </tr>
      <tr>
          <td>TEXT</td>
          <td>用于存储大量文本内容</td>
          <td>有TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT，存储大小逐渐增大</td>
          <td><code>description TEXT;</code>可以存储一篇短文或者产品描述</td>
      </tr>
      <tr>
          <td>BLOB</td>
          <td>存储二进制大型对象，如图像、音频等</td>
          <td>有TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB，存储大小逐渐增大</td>
          <td><code>image BLOB;</code>可以存储一张照片的二进制数据</td>
      </tr>
      <tr>
          <td>DATE</td>
          <td>存储日期，格式为YYYY - MM - DD</td>
          <td>从1000 - 01 - 01到9999 - 12 - 31</td>
          <td><code>birth_date DATE;</code>可以存储像'2000 - 01 - 01&rsquo;这样的出生日期</td>
      </tr>
      <tr>
          <td>TIME</td>
          <td>存储时间，格式为HH:MM:SS</td>
          <td>-</td>
          <td><code>start_time TIME;</code>可以存储像'09:00:00&rsquo;这样的开始时间</td>
      </tr>
      <tr>
          <td>DATETIME</td>
          <td>存储日期和时间，格式为YYYY - MM - DD HH:MM:SS</td>
          <td>从1000 - 01 - 01 00:00:00到9999 - 12 - 31 23:59:59</td>
          <td><code>order_time DATETIME;</code>可以存储像'2024 - 01 - 01 10:30:00&rsquo;这样的订单时间</td>
      </tr>
      <tr>
          <td>TIMESTAMP</td>
          <td>存储日期和时间戳，会受到时区影响</td>
          <td>从1970 - 01 - 01 00:00:00 UTC到2038 - 01 - 19 03:14:07 UTC</td>
          <td><code>update_time TIMESTAMP;</code>用于记录更新时间，在不同时区设置下可能会有变化</td>
      </tr>
  </tbody>
</table>
]]></content></item><item><title>Linux 进程优先级</title><link>https://jekyulll.github.io/posts/linux-linux-%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</link><pubDate>Mon, 04 Nov 2024 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-linux-%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</guid><description>&lt;h5 id="图解linux进程优先级httpsmpweixinqqcoms__bizmzkyndiynzu4mgmid2247484435idx1snb6f30489cf388f1024d6883abb8237c8chksmc1d84682f6afcf94c1af14678d5401d558d2b728f0e6c853dbe4efe02c12dfa147369ceee13frd">&lt;a href="https://mp.weixin.qq.com/s?__biz=MzkyNDIyNzU4Mg==&amp;amp;mid=2247484435&amp;amp;idx=1&amp;amp;sn=b6f30489cf388f1024d6883abb8237c8&amp;amp;chksm=c1d84682f6afcf94c1af14678d5401d558d2b728f0e6c853dbe4efe02c12dfa147369ceee13f#rd">图解Linux进程优先级&lt;/a>&lt;/h5>
&lt;p>&lt;em>实时优先级&lt;/em>用于实时应用程序，如硬实时任务和实时控制系统，而&lt;em>普通优先级&lt;/em>用于非实时应用程序。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>实时进程&lt;/strong>：动态优先级为0-99的进程，采用&lt;em>实时调度算法&lt;/em>调度。&lt;/li>
&lt;li>&lt;strong>普通进程&lt;/strong>：动态优先级为100-139的进程，采用&lt;em>完全公平调度算法&lt;/em>调度。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzkyNDIyNzU4Mg==&amp;amp;mid=2247484458&amp;amp;idx=1&amp;amp;sn=e4e64c006d4d822c6e7c184ab50540c1&amp;amp;chksm=c1d846bbf6afcfad20af0a7132eca1e3fd3c765ea5d4ee4134985b2b03f2461c207239fcc208#rd">Linux进程调度之完全公平调度（压箱底的干货分享）&lt;/a>。完全公平调度，CFS (Completely Fair Scheduler) 。&lt;/p>
&lt;p>&lt;strong>nice值&lt;/strong>：是用于调整普通进程优先级的参数。范围：&lt;code>-20&lt;/code>-&lt;code>19&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>task_struct {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> prio; &lt;span style="color:#75715e">// prio（动态优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> static_prio; &lt;span style="color:#75715e">// static_prio（静态优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> normal_prio; &lt;span style="color:#75715e">// normal_prio（归一化优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> rt_priority; &lt;span style="color:#75715e">// rt_priority（实时优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>&lt;code>prio&lt;/code>（动态优先级）&lt;br>
动态优先级，有效优先级，调度器最终使用的优先级数值，范围0-139，值越小，优先级越高。&lt;/li>
&lt;li>&lt;code>static_prio&lt;/code>（静态优先级）&lt;br>
静态优先级，采用&lt;code>SCHED_NORMAL&lt;/code>和&lt;code>SCHED_BATCH&lt;/code>调度策略的进程（即普通进程）用于计算动态优先级的，范围100-139。
prio = static_prio = nice + DEFAULT_PRIO = nice + 120&lt;/li>
&lt;li>&lt;code>normal_prio&lt;/code>（归一化优先级）&lt;br>
用于计算&lt;code>prio&lt;/code>的中间变量，不需要太关心。&lt;/li>
&lt;li>&lt;code>rt_priority&lt;/code>（实时优先级）&lt;br>
实时优先级，采用&lt;code>SCHED_FIFO&lt;/code>和&lt;code>SCHED_RR&lt;/code>调度策略进程（即实时进程）用于计算动态优先级，范围0-99。
prio = MAX_RT_PRIO - 1 - rt_prio = 100 - 1 - rt_priority;&lt;/li>
&lt;/ol>
&lt;p>实时优先级数值越大，得到的动态优先级数值越小，优先级越高。&lt;/p>
&lt;p>&lt;code>ps -elf&lt;/code>命令查看进程优先级。&lt;code>PRI&lt;/code>：进程优先级，数值越小，优先级越高。（并非动态优先级）&lt;code>NI&lt;/code>：nice值。&lt;/p>
&lt;p>&lt;code>SCHED_FIFO&lt;/code>（先进先出调度）和&lt;code>SCHED_RR&lt;/code>（时间片轮转调度），这些策略可以通过&lt;code>sched_setscheduler()&lt;/code>系统调用（头文件&lt;code>&amp;lt;sched.h&amp;gt;&lt;/code>）来设置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sched_param&lt;/span> param;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置优先级为最高优先级
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> param.sched_priority &lt;span style="color:#f92672">=&lt;/span> sched_get_priority_max(SCHED_FIFO);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置调度策略为SCHED_FIFO
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (sched_setscheduler(getpid(), SCHED_FIFO, &lt;span style="color:#f92672">&amp;amp;&lt;/span>param) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cerr &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;无法设置实时调度策略&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description><content type="html"><![CDATA[<h5 id="图解linux进程优先级httpsmpweixinqqcoms__bizmzkyndiynzu4mgmid2247484435idx1snb6f30489cf388f1024d6883abb8237c8chksmc1d84682f6afcf94c1af14678d5401d558d2b728f0e6c853dbe4efe02c12dfa147369ceee13frd"><a href="https://mp.weixin.qq.com/s?__biz=MzkyNDIyNzU4Mg==&amp;mid=2247484435&amp;idx=1&amp;sn=b6f30489cf388f1024d6883abb8237c8&amp;chksm=c1d84682f6afcf94c1af14678d5401d558d2b728f0e6c853dbe4efe02c12dfa147369ceee13f#rd">图解Linux进程优先级</a></h5>
<p><em>实时优先级</em>用于实时应用程序，如硬实时任务和实时控制系统，而<em>普通优先级</em>用于非实时应用程序。</p>
<ul>
<li><strong>实时进程</strong>：动态优先级为0-99的进程，采用<em>实时调度算法</em>调度。</li>
<li><strong>普通进程</strong>：动态优先级为100-139的进程，采用<em>完全公平调度算法</em>调度。</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzkyNDIyNzU4Mg==&amp;mid=2247484458&amp;idx=1&amp;sn=e4e64c006d4d822c6e7c184ab50540c1&amp;chksm=c1d846bbf6afcfad20af0a7132eca1e3fd3c765ea5d4ee4134985b2b03f2461c207239fcc208#rd">Linux进程调度之完全公平调度（压箱底的干货分享）</a>。完全公平调度，CFS (Completely Fair Scheduler) 。</p>
<p><strong>nice值</strong>：是用于调整普通进程优先级的参数。范围：<code>-20</code>-<code>19</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>task_struct {
</span></span><span style="display:flex;"><span>......
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span>             prio; 			<span style="color:#75715e">// prio（动态优先级）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>             static_prio;	<span style="color:#75715e">// static_prio（静态优先级）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>             normal_prio;	<span style="color:#75715e">// normal_prio（归一化优先级）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>    rt_priority; 	<span style="color:#75715e">// rt_priority（实时优先级）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><ol>
<li><code>prio</code>（动态优先级）<br>
动态优先级，有效优先级，调度器最终使用的优先级数值，范围0-139，值越小，优先级越高。</li>
<li><code>static_prio</code>（静态优先级）<br>
静态优先级，采用<code>SCHED_NORMAL</code>和<code>SCHED_BATCH</code>调度策略的进程（即普通进程）用于计算动态优先级的，范围100-139。
prio = static_prio = nice + DEFAULT_PRIO = nice + 120</li>
<li><code>normal_prio</code>（归一化优先级）<br>
用于计算<code>prio</code>的中间变量，不需要太关心。</li>
<li><code>rt_priority</code>（实时优先级）<br>
实时优先级，采用<code>SCHED_FIFO</code>和<code>SCHED_RR</code>调度策略进程（即实时进程）用于计算动态优先级，范围0-99。
prio = MAX_RT_PRIO - 1 - rt_prio = 100 - 1 - rt_priority;</li>
</ol>
<p>实时优先级数值越大，得到的动态优先级数值越小，优先级越高。</p>
<p><code>ps -elf</code>命令查看进程优先级。<code>PRI</code>：进程优先级，数值越小，优先级越高。（并非动态优先级）<code>NI</code>：nice值。</p>
<p><code>SCHED_FIFO</code>（先进先出调度）和<code>SCHED_RR</code>（时间片轮转调度），这些策略可以通过<code>sched_setscheduler()</code>系统调用（头文件<code>&lt;sched.h&gt;</code>）来设置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sched_param</span> param;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置优先级为最高优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    param.sched_priority <span style="color:#f92672">=</span> sched_get_priority_max(SCHED_FIFO);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置调度策略为SCHED_FIFO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (sched_setscheduler(getpid(), SCHED_FIFO, <span style="color:#f92672">&amp;</span>param) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;无法设置实时调度策略&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div>]]></content></item><item><title>Linux 文件系统与虚拟文件系统</title><link>https://jekyulll.github.io/posts/linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 04 Nov 2024 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h1 id="linux-文件系统">Linux 文件系统&lt;/h1>
&lt;p>&lt;strong>文件描述符&lt;/strong>(File Descriptor，FD)(win里一般称为文件句柄)是操作系统中用于标识和管理已打开文件或I/O资源的整数值。&lt;br>
当进程请求打开一个文件或资源时，操作系统为该资源分配一个文件描述符，并将其返回给进程。进程随后使用该文件描述符来进行读写操作。
是一个进程级别的概念。&lt;/p>
&lt;ul>
&lt;li>继承：在创建子进程时，文件描述符可以在父子进程之间共享（例如通过 fork()）。&lt;/li>
&lt;li>复制：通过系统调用 dup() 或 dup2() 可以复制文件描述符，使它们引用同一个文件或资源。&lt;/li>
&lt;/ul>
&lt;p>文件描述符不仅用于操作文件，还可以指向：&lt;/p>
&lt;ul>
&lt;li>管道（Pipes）：用于进程间通信。&lt;/li>
&lt;li>套接字（Sockets）：用于网络通信。&lt;/li>
&lt;li>设备文件：例如硬盘、串口等设备。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>文件分配表&lt;/strong>(File Allocation Table, FAT)。&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1jy4y1K73r/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">何为文件索引节点?文件与磁盘的爱恨情仇。&lt;/a>。&lt;br>
&lt;a href="https://ruanyifeng.com/blog/2011/12/inode.html">阮一峰的个人网站&lt;/a>。&lt;br>
&lt;strong>inode&lt;/strong>（索引节点）。&lt;a href="https://ruanyifeng.com/blog/2011/12/inode.html">理解inode&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>文件储存在硬盘上，硬盘的最小存储单位叫做&amp;quot;扇区&amp;quot;（Sector）。每个扇区储存512字节（相当于0.5KB）。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个&amp;quot;块&amp;quot;（block）。这种由多个扇区组成的&amp;quot;块&amp;quot;，是文件存取的最小单位。&amp;ldquo;块&amp;quot;的大小，最常见的是4KB，即连续八个 sector组成一个 block。
文件数据都储存在&amp;quot;块&amp;quot;中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为&amp;quot;索引节点&amp;rdquo;。&lt;br>
可以用&lt;code>stat&lt;/code>命令，查看某个文件的inode信息。
inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是&lt;strong>inode区&lt;/strong>（inode table），存放inode所包含的信息。
Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>超级块&lt;/strong>（Superblock）位于每个文件系统的开头，提供了操作系统如何解释和管理该文件系统的元数据。(记录各个inode?)&lt;/p>
&lt;p>&lt;strong>软链接和硬链接：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>软链接是一个独立的文件，它包含了另一个文件或目录的路径。它类似于 Windows 系统中的快捷方式。&lt;/li>
&lt;li>硬链接是文件的一个直接引用（或者说是指针），它与原文件共享相同的inode。删除原文件后，硬链接仍然有效，因为它直接引用了文件的数据；文件只有当所有硬链接都被删除后，数据才会被清除。inode信息中有一项叫做&amp;quot;链接数&amp;quot;，记录指向该inode的文件名总数。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>linux软件更新过程：软件更新变得简单：系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h1 id="linux-虚拟文件系统">Linux 虚拟文件系统&lt;/h1>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/3815712411">linux I/O原理、监控、和调优思路&lt;/a>。&lt;br>
&lt;a href="https://zhuanlan.zhihu.com/p/681048030">图解Linux虚拟文件系统(VFS)之关系篇&lt;/a>。&lt;/p>
&lt;p>&lt;strong>虚拟文件系统&lt;/strong>（Virtual File System，VFS）：它提供了一个统一的接口，使得用户和应用程序可以通过相同的方式访问不同类型的文件系统。&lt;/p>
&lt;blockquote>
&lt;p>通过VFS用户可以使用相同的系统调用（如&lt;code>open&lt;/code>、&lt;code>read&lt;/code>、&lt;code>write&lt;/code>等）来访问不同类型的文件系统，包括本地文件系统（如ext4、XFS等）、网络文件系统（如NFS、CIFS等）以及虚拟文件系统（如procfs、sysfs等）。&lt;/p>
&lt;/blockquote>
&lt;p>VFS由以下几个主要组件组成：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>虚拟文件系统接口&lt;/strong>：VFS定义了一组通用的文件系统操作接口。&lt;/li>
&lt;li>&lt;strong>超级块(super_block)&lt;/strong>：每个文件系统都有一个超级块，它包含了文件系统的元数据信息，如文件系统类型、块大小、inode表等，超级块提供了对文件系统的整体描述和管理。&lt;/li>
&lt;li>&lt;strong>目录项(dentry)&lt;/strong>：Directory Entry，用于表示文件系统中的目录和文件，dentry包含了目录和文件对应的inode指针、层级关系(parent)等。
&lt;blockquote>
&lt;p>dentry结构体的主要作用是提供文件系统层次结构的表示，它们通过形成一个树状结构来组织目录和文件，每个dentry都有一个唯一的路径名，可以通过遍历dentry树来找到特定文件或目录。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> dentry {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> dentry &lt;span style="color:#f92672">*&lt;/span>d_parent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> qstr d_name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>d_inode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> dentry_operations &lt;span style="color:#f92672">*&lt;/span>d_op;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> super_block &lt;span style="color:#f92672">*&lt;/span>d_sb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> list_head d_child;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> list_head d_subdirs;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>&lt;strong>文件节点(inode)&lt;/strong>：inode是文件系统中的一个数据结构，用于存储文件或目录的元数据信息，如文件大小、权限、所有者等，每个文件或目录都对应一个唯一的inode。&lt;/li>
&lt;li>&lt;strong>文件对象(file)&lt;/strong>：file是表示打开文件的数据结构，它包含了对应的inode指针、当前读写位置等信息，通过file可以进行文件的读写操作。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>索引节点&lt;/strong>(index node, inode)，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。&lt;/li>
&lt;li>&lt;strong>目录项&lt;/strong>(directory entry, dentry)，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>ramfs&lt;/strong>是一种基于内存的文件系统。它将所有的文件数据存储在内存（RAM）中，而不是像传统的文件系统那样存储在磁盘等外部存储设备上。&lt;/p></description><content type="html"><![CDATA[<h1 id="linux-文件系统">Linux 文件系统</h1>
<p><strong>文件描述符</strong>(File Descriptor，FD)(win里一般称为文件句柄)是操作系统中用于标识和管理已打开文件或I/O资源的整数值。<br>
当进程请求打开一个文件或资源时，操作系统为该资源分配一个文件描述符，并将其返回给进程。进程随后使用该文件描述符来进行读写操作。
是一个进程级别的概念。</p>
<ul>
<li>继承：在创建子进程时，文件描述符可以在父子进程之间共享（例如通过 fork()）。</li>
<li>复制：通过系统调用 dup() 或 dup2() 可以复制文件描述符，使它们引用同一个文件或资源。</li>
</ul>
<p>文件描述符不仅用于操作文件，还可以指向：</p>
<ul>
<li>管道（Pipes）：用于进程间通信。</li>
<li>套接字（Sockets）：用于网络通信。</li>
<li>设备文件：例如硬盘、串口等设备。</li>
</ul>
<p><strong>文件分配表</strong>(File Allocation Table, FAT)。</p>
<p><a href="https://www.bilibili.com/video/BV1jy4y1K73r/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">何为文件索引节点?文件与磁盘的爱恨情仇。</a>。<br>
<a href="https://ruanyifeng.com/blog/2011/12/inode.html">阮一峰的个人网站</a>。<br>
<strong>inode</strong>（索引节点）。<a href="https://ruanyifeng.com/blog/2011/12/inode.html">理解inode</a>。</p>
<blockquote>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做&quot;扇区&quot;（Sector）。每个扇区储存512字节（相当于0.5KB）。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个&quot;块&quot;（block）。这种由多个扇区组成的&quot;块&quot;，是文件存取的最小单位。&ldquo;块&quot;的大小，最常见的是4KB，即连续八个 sector组成一个 block。
文件数据都储存在&quot;块&quot;中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为&quot;索引节点&rdquo;。<br>
可以用<code>stat</code>命令，查看某个文件的inode信息。
inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是<strong>inode区</strong>（inode table），存放inode所包含的信息。
Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。</p>
</blockquote>
<p><strong>超级块</strong>（Superblock）位于每个文件系统的开头，提供了操作系统如何解释和管理该文件系统的元数据。(记录各个inode?)</p>
<p><strong>软链接和硬链接：</strong></p>
<ul>
<li>软链接是一个独立的文件，它包含了另一个文件或目录的路径。它类似于 Windows 系统中的快捷方式。</li>
<li>硬链接是文件的一个直接引用（或者说是指针），它与原文件共享相同的inode。删除原文件后，硬链接仍然有效，因为它直接引用了文件的数据；文件只有当所有硬链接都被删除后，数据才会被清除。inode信息中有一项叫做&quot;链接数&quot;，记录指向该inode的文件名总数。</li>
</ul>
<blockquote>
<p>linux软件更新过程：软件更新变得简单：系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p>
</blockquote>
<hr>
<h1 id="linux-虚拟文件系统">Linux 虚拟文件系统</h1>
<p><a href="https://zhuanlan.zhihu.com/p/3815712411">linux I/O原理、监控、和调优思路</a>。<br>
<a href="https://zhuanlan.zhihu.com/p/681048030">图解Linux虚拟文件系统(VFS)之关系篇</a>。</p>
<p><strong>虚拟文件系统</strong>（Virtual File System，VFS）：它提供了一个统一的接口，使得用户和应用程序可以通过相同的方式访问不同类型的文件系统。</p>
<blockquote>
<p>通过VFS用户可以使用相同的系统调用（如<code>open</code>、<code>read</code>、<code>write</code>等）来访问不同类型的文件系统，包括本地文件系统（如ext4、XFS等）、网络文件系统（如NFS、CIFS等）以及虚拟文件系统（如procfs、sysfs等）。</p>
</blockquote>
<p>VFS由以下几个主要组件组成：</p>
<ol>
<li><strong>虚拟文件系统接口</strong>：VFS定义了一组通用的文件系统操作接口。</li>
<li><strong>超级块(super_block)</strong>：每个文件系统都有一个超级块，它包含了文件系统的元数据信息，如文件系统类型、块大小、inode表等，超级块提供了对文件系统的整体描述和管理。</li>
<li><strong>目录项(dentry)</strong>：Directory Entry，用于表示文件系统中的目录和文件，dentry包含了目录和文件对应的inode指针、层级关系(parent)等。
<blockquote>
<p>dentry结构体的主要作用是提供文件系统层次结构的表示，它们通过形成一个树状结构来组织目录和文件，每个dentry都有一个唯一的路径名，可以通过遍历dentry树来找到特定文件或目录。</p>
</blockquote>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> dentry {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> dentry <span style="color:#f92672">*</span>d_parent;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> qstr d_name;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>d_inode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> dentry_operations <span style="color:#f92672">*</span>d_op;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> super_block <span style="color:#f92672">*</span>d_sb;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> list_head d_child;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> list_head d_subdirs;
</span></span><span style="display:flex;"><span>    ....
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ol start="4">
<li><strong>文件节点(inode)</strong>：inode是文件系统中的一个数据结构，用于存储文件或目录的元数据信息，如文件大小、权限、所有者等，每个文件或目录都对应一个唯一的inode。</li>
<li><strong>文件对象(file)</strong>：file是表示打开文件的数据结构，它包含了对应的inode指针、当前读写位置等信息，通过file可以进行文件的读写操作。</li>
</ol>
<ul>
<li><strong>索引节点</strong>(index node, inode)，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。</li>
<li><strong>目录项</strong>(directory entry, dentry)，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。</li>
</ul>
<blockquote>
<p><strong>ramfs</strong>是一种基于内存的文件系统。它将所有的文件数据存储在内存（RAM）中，而不是像传统的文件系统那样存储在磁盘等外部存储设备上。</p>
</blockquote>
<blockquote>
<p>定义好文件系统后，通过register_filesystem函数将文件系统注册至Linux系统，注册成功的文件系统会插入全局文件系统链表，已注册的文件系统能够用来创建超级块（super block）。</p>
</blockquote>
<p><strong>文件系统挂载</strong>：新文件系统生成一个挂载实例（struct mount），让新挂载实例和父文件系统的挂载实例建立父子关系。每个文件系统都有一个根目录，当索引一个文件路径进入到一个新的文件系统后，会从新的文件系统根目录开始索引。</p>
<hr>
<h6 id="memory-cgroup内存控制组">Memory Cgroup（内存控制组）</h6>
<p>Memory Cgroup 是 cgroup（控制组）的一个子系统，用于控制和限制进程组或任务组的内存使用。它是 Linux 内核提供的一种资源管理机制，主要目的是隔离和限制内存资源的使用，确保系统的稳定性和公平性。</p>
<ul>
<li>可以通过配置参数来设置内存使用的硬限制（<code>memory.limit_in_bytes</code>）。当进程组使用的内存达到这个硬限制时，会触发内存回收机制，如通过<code>OOM - Killer</code>（内存不足杀手）选择并终止进程组中的某些进程来释放内存。</li>
<li>会收集进程组的各种内存使用统计信息，包括<code>rss</code>（ Resident Set Size，实际驻留在内存中的内存大小）、<code>cache</code>（缓存内存大小）等。</li>
</ul>
]]></content></item><item><title>事务 Transaction 的基础特性</title><link>https://jekyulll.github.io/posts/database-%E4%BA%8B%E5%8A%A1transaction%E7%9A%84%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 04 Nov 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/database-%E4%BA%8B%E5%8A%A1transaction%E7%9A%84%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/</guid><description>&lt;p>&lt;strong>事务&lt;/strong>（Transaction）是数据库管理系统执行过程中的一个逻辑单位，它由一个或多个数据库操作组成，这些操作要么全部执行成功，要么全部不执行，以保证数据的一致性和完整性。&lt;br>
&lt;strong>ACID&lt;/strong> 是事务的四个重要特性：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>原子性&lt;/strong>（Atomicity）;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>一致性&lt;/strong>（Consistency）;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>隔离性&lt;/strong>（Isolation）；不同的隔离级别：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>读未提交&lt;/strong>（Read Uncommitted）：最低的隔离级别。一个事务可以读取另一个未提交事务的数据。
&lt;ul>
&lt;li>可能会出现&lt;strong>脏读&lt;/strong>（Dirty Read）的情况。
&lt;blockquote>
&lt;p>脏读是指一个事务读取了另一个尚未提交的事务修改的数据。eg.事务 T1 修改了一条记录但尚未提交，事务 T2 在这个时候读取了这条被修改的记录。如果 T1 后来回滚了，那么 T2 读取的数据就是无效的、“脏” 的数据。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>读已提交&lt;/strong>（Read Committed）：
&lt;ul>
&lt;li>可能会出现&lt;strong>不可重复读&lt;/strong>（Non - Repeatable Read）的问题。
&lt;blockquote>
&lt;p>不可重复读是指在一个事务内，多次读取同一数据，由于其他事务的修改操作，导致每次读取的结果不同。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>可重复读&lt;/strong>（Repeatable Read）：
&lt;ul>
&lt;li>可能会出现幻读（Phantom Read）的情况。
&lt;blockquote>
&lt;p>当一个事务（T1）按照一定的条件进行数据读取操作时，第一次读取没有发现满足条件的某些行（记录）。但是在这个事务还没有结束的时候，另一个事务（T2）插入（或删除）了一些满足（或原本满足）T1 查询条件的行。当 T1 再次按照相同的条件进行读取时，就会发现比第一次读取时更多（或更少）的符合条件的行，这些 “凭空出现” 或 “突然消失” 的行就像 “幻觉” 一样，所以被称为幻读。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>串行化&lt;/strong>（Serializable）：最高的隔离级别。牺牲了数据库的并发性能。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>持久性&lt;/strong>（Durability）。&lt;/p>
&lt;/li>
&lt;/ol></description><content type="html"><![CDATA[<p><strong>事务</strong>（Transaction）是数据库管理系统执行过程中的一个逻辑单位，它由一个或多个数据库操作组成，这些操作要么全部执行成功，要么全部不执行，以保证数据的一致性和完整性。<br>
<strong>ACID</strong> 是事务的四个重要特性：</p>
<ol>
<li>
<p><strong>原子性</strong>（Atomicity）;</p>
</li>
<li>
<p><strong>一致性</strong>（Consistency）;</p>
</li>
<li>
<p><strong>隔离性</strong>（Isolation）；不同的隔离级别：</p>
<ol>
<li><strong>读未提交</strong>（Read Uncommitted）：最低的隔离级别。一个事务可以读取另一个未提交事务的数据。
<ul>
<li>可能会出现<strong>脏读</strong>（Dirty Read）的情况。
<blockquote>
<p>脏读是指一个事务读取了另一个尚未提交的事务修改的数据。eg.事务 T1 修改了一条记录但尚未提交，事务 T2 在这个时候读取了这条被修改的记录。如果 T1 后来回滚了，那么 T2 读取的数据就是无效的、“脏” 的数据。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>读已提交</strong>（Read Committed）：
<ul>
<li>可能会出现<strong>不可重复读</strong>（Non - Repeatable Read）的问题。
<blockquote>
<p>不可重复读是指在一个事务内，多次读取同一数据，由于其他事务的修改操作，导致每次读取的结果不同。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>可重复读</strong>（Repeatable Read）：
<ul>
<li>可能会出现幻读（Phantom Read）的情况。
<blockquote>
<p>当一个事务（T1）按照一定的条件进行数据读取操作时，第一次读取没有发现满足条件的某些行（记录）。但是在这个事务还没有结束的时候，另一个事务（T2）插入（或删除）了一些满足（或原本满足）T1 查询条件的行。当 T1 再次按照相同的条件进行读取时，就会发现比第一次读取时更多（或更少）的符合条件的行，这些 “凭空出现” 或 “突然消失” 的行就像 “幻觉” 一样，所以被称为幻读。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>串行化</strong>（Serializable）：最高的隔离级别。牺牲了数据库的并发性能。</li>
</ol>
</li>
<li>
<p><strong>持久性</strong>（Durability）。</p>
</li>
</ol>
]]></content></item><item><title>CPU 的五级流水线</title><link>https://jekyulll.github.io/posts/system-cpu-%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/</link><pubDate>Wed, 09 Oct 2024 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/system-cpu-%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/</guid><description>&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/382372072">现代C++的内存模型&lt;/a>。&amp;ndash;神文&lt;br>
&lt;a href="https://zhuanlan.zhihu.com/p/682286231">自底向上理解memory_order&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/sinat_38293503/article/details/134612152">大白话C++之：一文搞懂C++多线程内存模型(Memory Order)&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>时钟周期&lt;/em>也称为&lt;em>振荡周期&lt;/em>，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。时钟周期表示了&lt;em>SDRAM&lt;/em>所能运行的最高频率。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>如果没有Cache，CPU每执行一条指令，都要去内存取下一条，而执行一条指令也就几个时钟周期（几ns），而取指令却要上百个时钟周期，这将导致CPU大部分时间都在等待状态，进而导致执行效率低下。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>C++ 内存模型（Memory Model）定义了程序在多线程环境中如何访问和共享内存，它为程序的正确性、并发性和可移植性提供了保证。C++ 内存模型主要通过原子操作、内存序列（Memory Ordering）、同步和锁等机制来规范线程之间的内存访问行为。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h1 id="cpu-的五级流水线">CPU 的五级流水线&lt;/h1>
&lt;blockquote>
&lt;p>CPU 将指令执行分解成5个部分，分别是：IF 取指令，ID 译码，EX 执行，MEM 访问内存，WB 写回。&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>内存顺序模型&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>memory_order_seq_cst&lt;/td>
&lt;td>顺序一致(sequentially consistent ordering)，只有该值满足sC顺序一致性，原子操作默认使用该值。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory_order_relaxed&lt;/td>
&lt;td>松散(relaxed ordering)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory_order_consume&lt;/td>
&lt;td>获取发布(acquire-release ordering)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory_order_acquire&lt;/td>
&lt;td>获取发布(acquire-release ordering)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory_order_release&lt;/td>
&lt;td>获取发布(acquire-release ordering)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory_order_acq_rel&lt;/td>
&lt;td>获取发布(acquire-release ordering)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>与编译器优化有关：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//reordering 重排示例代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> A &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, B &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A &lt;span style="color:#f92672">=&lt;/span> B &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//(1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> B &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//(2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// g++ -std=c++11 -O2 -S test.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 编译器重排后的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 注意第一句汇编，已经将B最初的值存到了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 寄存器eax，而后将该eax的值加1，再赋给A
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">movl&lt;/span> &lt;span style="color:#66d9ef">B&lt;/span>(%rip), %eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">movl&lt;/span> &lt;span style="color:#66d9ef">$1&lt;/span>, &lt;span style="color:#66d9ef">B&lt;/span>(%rip) &lt;span style="color:#75715e">// B = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">addl&lt;/span> &lt;span style="color:#66d9ef">$1&lt;/span>, %eax &lt;span style="color:#75715e">// A = B + 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">movl&lt;/span> %eax, &lt;span style="color:#66d9ef">A&lt;/span>(%rip)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Invention示例代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 原始代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span>( cond ) x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 优化后代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>r1 &lt;span style="color:#f92672">=&lt;/span> x;&lt;span style="color:#75715e">// read what&amp;#39;s there
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>;&lt;span style="color:#75715e">// oops: optimistic write is not conditional
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span>( &lt;span style="color:#f92672">!&lt;/span>cond)&lt;span style="color:#75715e">// check if we guessed wrong
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> r1;&lt;span style="color:#75715e">// oops: back-out write is not SC
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于内存读写来说，读写顺序需要严格按照代码顺序，即要求如下（符号&lt;code>&amp;lt;p&lt;/code>表示程序代码顺序，符号&lt;code>&amp;lt;m&lt;/code>表示内存的读写顺序）：&lt;/p></description><content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/382372072">现代C++的内存模型</a>。&ndash;神文<br>
<a href="https://zhuanlan.zhihu.com/p/682286231">自底向上理解memory_order</a>。<br>
<a href="https://blog.csdn.net/sinat_38293503/article/details/134612152">大白话C++之：一文搞懂C++多线程内存模型(Memory Order)</a>。</p>
<blockquote>
<p><em>时钟周期</em>也称为<em>振荡周期</em>，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。时钟周期表示了<em>SDRAM</em>所能运行的最高频率。</p>
</blockquote>
<blockquote>
<p>如果没有Cache，CPU每执行一条指令，都要去内存取下一条，而执行一条指令也就几个时钟周期（几ns），而取指令却要上百个时钟周期，这将导致CPU大部分时间都在等待状态，进而导致执行效率低下。</p>
</blockquote>
<blockquote>
<p>C++ 内存模型（Memory Model）定义了程序在多线程环境中如何访问和共享内存，它为程序的正确性、并发性和可移植性提供了保证。C++ 内存模型主要通过原子操作、内存序列（Memory Ordering）、同步和锁等机制来规范线程之间的内存访问行为。</p>
</blockquote>
<hr>
<h1 id="cpu-的五级流水线">CPU 的五级流水线</h1>
<blockquote>
<p>CPU 将指令执行分解成5个部分，分别是：IF 取指令，ID 译码，EX 执行，MEM 访问内存，WB 写回。</p>
</blockquote>
<table>
  <thead>
      <tr>
          <th>内存顺序模型</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>memory_order_seq_cst</td>
          <td>顺序一致(sequentially consistent ordering)，只有该值满足sC顺序一致性，原子操作默认使用该值。</td>
      </tr>
      <tr>
          <td>memory_order_relaxed</td>
          <td>松散(relaxed ordering)</td>
      </tr>
      <tr>
          <td>memory_order_consume</td>
          <td>获取发布(acquire-release ordering)</td>
      </tr>
      <tr>
          <td>memory_order_acquire</td>
          <td>获取发布(acquire-release ordering)</td>
      </tr>
      <tr>
          <td>memory_order_release</td>
          <td>获取发布(acquire-release ordering)</td>
      </tr>
      <tr>
          <td>memory_order_acq_rel</td>
          <td>获取发布(acquire-release ordering)</td>
      </tr>
  </tbody>
</table>
<p>与编译器优化有关：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//reordering 重排示例代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> A <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, B <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    A <span style="color:#f92672">=</span> B <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    B <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;      <span style="color:#75715e">//(2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">// g++ -std=c++11 -O2 -S test.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译器重排后的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 注意第一句汇编，已经将B最初的值存到了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 寄存器eax，而后将该eax的值加1，再赋给A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movl</span>  <span style="color:#66d9ef">B</span>(%rip), %eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">movl</span>  <span style="color:#66d9ef">$1</span>, <span style="color:#66d9ef">B</span>(%rip)          <span style="color:#75715e">// B = 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addl</span>  <span style="color:#66d9ef">$1</span>, %eax             <span style="color:#75715e">// A = B + 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movl</span>  %eax, <span style="color:#66d9ef">A</span>(%rip)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Invention示例代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 原始代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span>( cond ) x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 优化后代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>r1 <span style="color:#f92672">=</span> x;<span style="color:#75715e">// read what&#39;s there
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;<span style="color:#75715e">// oops: optimistic write is not conditional
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span>( <span style="color:#f92672">!</span>cond)<span style="color:#75715e">// check if we guessed wrong
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    x <span style="color:#f92672">=</span> r1;<span style="color:#75715e">// oops: back-out write is not SC
</span></span></span></code></pre></div><p>对于内存读写来说，读写顺序需要严格按照代码顺序，即要求如下（符号<code>&lt;p</code>表示程序代码顺序，符号<code>&lt;m</code>表示内存的读写顺序）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 顺序一致的要求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/* Load→Load */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*若按代码顺序，a变量的读取先于b变量，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">则内存顺序也需要先读a再读b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">后面的规则同理。*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> L(a) <span style="color:#f92672">&lt;</span>p L(b) <span style="color:#960050;background-color:#1e0010">⇒</span> L(a) <span style="color:#f92672">&lt;</span>m L(b)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Load→Store */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> L(a) <span style="color:#f92672">&lt;</span>p S(b) <span style="color:#960050;background-color:#1e0010">⇒</span> L(a) <span style="color:#f92672">&lt;</span>m S(b)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Store→Store */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> S(a) <span style="color:#f92672">&lt;</span>p S(b) <span style="color:#960050;background-color:#1e0010">⇒</span> S(a) <span style="color:#f92672">&lt;</span>m S(b)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/* Store→Load */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> S(a) <span style="color:#f92672">&lt;</span>p L(b) <span style="color:#960050;background-color:#1e0010">⇒</span> S(a) <span style="color:#f92672">&lt;</span>m L(b)
</span></span></code></pre></div><p>顺序一致这么严格，其显然会限制编译器和CPU的优化，所以业界提出了很多宽松的模型，例如在X86中使用的TSO（Total Store Order）便允许某些条件下的重排。</p>
<p><code>memory_order_acquire</code>：对于使用该枚举值的load操作，不允许该load之后的操作重排到load之前。<br>
<code>memory_order_release</code>：使用该枚举值的store操作，不允许store之前的操作重排到store之后。</p>
<blockquote>
<p>现代C++（包括Java）都是使用了SC-DRF(Sequential consistency for data race free)。在SC-DRF模型下，程序员只要不写出Race Condition的代码，编译器和CPU便能保证程序的执行结果与顺序一致相同。因而，内存模型就如同程序员与编译器/CPU之间的契约，需要彼此遵守承诺。C++的内存模型默认为SC-DRF，此外还支持更宽松的非SC-DRF的模型。</p>
</blockquote>
<blockquote>
<p>C++内存模型借鉴lock/unlock，引入了两个等效的概念，Acquire（类似lock）和Release（类似unlock），这两个都是单方向的屏障（One-way Barriers: acquire barrier, release barrier）。</p>
</blockquote>
]]></content></item><item><title>C++ 中 tuple 是如何实现的？</title><link>https://jekyulll.github.io/posts/cpp-c++-%E4%B8%AD-tuple-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</link><pubDate>Sat, 28 Sep 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E4%B8%AD-tuple-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</guid><description>&lt;p>&lt;code>tuple&lt;/code>本身就是一种结构体，但是是一个模板类。利用&lt;code>形参包&lt;/code>(Parameter pack)。&lt;a href="https://zhuanlan.zhihu.com/p/715025973">C++ std::tuple的原理及简易实现&lt;/a>，靠着模板元的递归实现的，相当抽象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span>...Args&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 当元组中没有元素时，递归结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>() &lt;span style="color:#66d9ef">noexcept&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> tuple &lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#66d9ef">noexcept&lt;/span> {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> tuple &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> tuple &lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 当元组中有一个或多个元素时，将第一个元素的类型分离出来，并通过继承，将剩下的元素作为另一个元组处理。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> head, &lt;span style="color:#66d9ef">typename&lt;/span>...Args&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>head, Args...&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> tuple&lt;span style="color:#f92672">&amp;lt;&lt;/span>Args...&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> base_ &lt;span style="color:#f92672">=&lt;/span> tuple&lt;span style="color:#f92672">&amp;lt;&lt;/span>Args...&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> head_, &lt;span style="color:#66d9ef">typename&lt;/span>...Args_&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> tuple(head_ &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>val, Args_ &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>...args) &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head_val_(std&lt;span style="color:#f92672">::&lt;/span>forward&lt;span style="color:#f92672">&amp;lt;&lt;/span>head_&lt;span style="color:#f92672">&amp;gt;&lt;/span>(val)), base_(std&lt;span style="color:#f92672">::&lt;/span>forward&lt;span style="color:#f92672">&amp;lt;&lt;/span>Args_&lt;span style="color:#f92672">&amp;gt;&lt;/span>(args)...) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tuple_val_&lt;span style="color:#f92672">&amp;lt;&lt;/span>head&lt;span style="color:#f92672">&amp;gt;&lt;/span> head_val_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://zh.cppreference.com/w/cpp/language/class_template_argument_deduction">类模板实参推导（CTAD）(C++17 起)&lt;/a>。&lt;/p></description><content type="html"><![CDATA[<p><code>tuple</code>本身就是一种结构体，但是是一个模板类。利用<code>形参包</code>(Parameter pack)。<a href="https://zhuanlan.zhihu.com/p/715025973">C++ std::tuple的原理及简易实现</a>，靠着模板元的递归实现的，相当抽象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>...Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">tuple</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 当元组中没有元素时，递归结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">tuple</span><span style="color:#f92672">&lt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constexpr</span> <span style="color:#a6e22e">tuple</span>() <span style="color:#66d9ef">noexcept</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constexpr</span> <span style="color:#a6e22e">tuple</span>(<span style="color:#66d9ef">const</span> tuple <span style="color:#f92672">&amp;</span>) <span style="color:#66d9ef">noexcept</span> {};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constexpr</span> tuple <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> tuple <span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 当元组中有一个或多个元素时，将第一个元素的类型分离出来，并通过继承，将剩下的元素作为另一个元组处理。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> head, <span style="color:#66d9ef">typename</span>...Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">tuple</span><span style="color:#f92672">&lt;</span>head, Args...<span style="color:#f92672">&gt;</span> <span style="color:#f92672">:</span> tuple<span style="color:#f92672">&lt;</span>Args...<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> base_ <span style="color:#f92672">=</span> tuple<span style="color:#f92672">&lt;</span>Args...<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> head_, <span style="color:#66d9ef">typename</span>...Args_<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constexpr</span> tuple(head_ <span style="color:#f92672">&amp;&amp;</span>val, Args_ <span style="color:#f92672">&amp;&amp;</span>...args) <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        head_val_(std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>head_<span style="color:#f92672">&gt;</span>(val)), base_(std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>Args_<span style="color:#f92672">&gt;</span>(args)...) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tuple_val_<span style="color:#f92672">&lt;</span>head<span style="color:#f92672">&gt;</span> head_val_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://zh.cppreference.com/w/cpp/language/class_template_argument_deduction">类模板实参推导（CTAD）(C++17 起)</a>。</p>
]]></content></item><item><title>C++ 的四种类型转换</title><link>https://jekyulll.github.io/posts/cpp-c++-%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><pubDate>Sat, 28 Sep 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>&lt;p>思考了一下&lt;code>reinterpret_cast&lt;/code>和强转的区别？这段非常易懂：&lt;br>
C 语言的类型转换实际上包含各种转换方式，是 &lt;code>static_cast&lt;/code> 跟 &lt;code>reinterpret_cast&lt;/code> 等的父操作。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一类是从逻辑意义上读取原有的值，然后到新的变量类型生成一个新值。（可以称为&lt;strong>显式类型转换&lt;/strong>，简称显转）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一类是完全保持原有值的内存表达方式，用新的变量类型来解读这段内存区域。（可以称为&lt;strong>强制类型转换&lt;/strong>，简称强转）&lt;br>
这两个用法实际的动作完全不同，但在 C 语言中是同一种写法。所以到了C++，就把前一种写法写成 &lt;code>static_cast&lt;/code>，后一种写法写成 &lt;code>reinterpret_cast&lt;/code>。&lt;br>
&lt;code>reinterpret_cast&lt;/code> 仅作用于编译时，可以保证不改变内存区域的内容。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dynamic_cast：这是 C 里面不存在的转型方式，用来在带有虚函数的“动态对象”继承树里进行指针或引用的类型转换。比如，假设我们有对象基类 &lt;code>Shape&lt;/code> 和派生类 &lt;code>Circle&lt;/code> 和 &lt;code>Rectangle&lt;/code>：如果有 &lt;code>Shape&lt;/code> 指针 &lt;code>ptr&lt;/code>，我们可以使用 &lt;code>dynamic_cast&amp;lt;Circle*&amp;gt;(ptr)&lt;/code> 尝试把它转型成 &lt;code>Circle*&lt;/code>。系统会进行需要的类型检查，并在转型成功时返回一个非空指针，返回空指针则表示失败（如当 &lt;code>ptr&lt;/code> 实际指向的不是 &lt;code>Circle&lt;/code>，而是 &lt;code>Rectangle&lt;/code>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>static_cast：这是一种在很多认为较安全的场景下的“静态”转型方式。你可以使用它在不同的数值类型之间进行转换，如从 &lt;code>long&lt;/code> 到 &lt;code>int&lt;/code>，或者从 &lt;code>long long&lt;/code> 到 &lt;code>double&lt;/code>——当转换有可能有精度损失时，就不能使用隐式类型转换，而得明确使用转型了。你也可以使用它把一个 &lt;code>void*&lt;/code> 转成一个实际类型的指针（如 &lt;code>int*&lt;/code>）。你还可以用它把基类的指针转成派生类的指针，前提条件是你能确认这个基类的指针确实指向一个派生类的对象。显然，对于这最后一种场景 static_cast 不如 dynamic_cast 安全，但由于不需要进行运行期的检查，它的性能比 &lt;code>dynamic_cast&lt;/code> 要高，在很多情况下是个空操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>const_cast：这种转型方式潜在就不那么安全了。它的目的是去掉一个指针或引用类型的 &lt;code>const&lt;/code> 或 &lt;code>volatile&lt;/code> 修饰，如从 &lt;code>const char*&lt;/code> 转换到 &lt;code>char*&lt;/code>。这种转型的一种常见用途是把一个 C++ 的指针传递到一个 &lt;code>const&lt;/code> 不正确的 C 接口里去，比如 C 接口在该用 &lt;code>const char*&lt;/code> 时使用了 &lt;code>char*&lt;/code>。注意这种转型只是为了“欺骗”类型系统，让代码能通过编译。如果你通过 &lt;code>const_cast&lt;/code> 操作指针或引用去修改一个 &lt;code>const&lt;/code> 对象，这仍然是错误的，是未定义行为，可能会导致奇怪的意外结果。&lt;/p></description><content type="html"><![CDATA[<p>思考了一下<code>reinterpret_cast</code>和强转的区别？这段非常易懂：<br>
C 语言的类型转换实际上包含各种转换方式，是 <code>static_cast</code> 跟 <code>reinterpret_cast</code> 等的父操作。</p>
<ul>
<li>
<p>一类是从逻辑意义上读取原有的值，然后到新的变量类型生成一个新值。（可以称为<strong>显式类型转换</strong>，简称显转）</p>
</li>
<li>
<p>一类是完全保持原有值的内存表达方式，用新的变量类型来解读这段内存区域。（可以称为<strong>强制类型转换</strong>，简称强转）<br>
这两个用法实际的动作完全不同，但在 C 语言中是同一种写法。所以到了C++，就把前一种写法写成 <code>static_cast</code>，后一种写法写成 <code>reinterpret_cast</code>。<br>
<code>reinterpret_cast</code> 仅作用于编译时，可以保证不改变内存区域的内容。</p>
</li>
<li>
<p>dynamic_cast：这是 C 里面不存在的转型方式，用来在带有虚函数的“动态对象”继承树里进行指针或引用的类型转换。比如，假设我们有对象基类 <code>Shape</code> 和派生类 <code>Circle</code> 和 <code>Rectangle</code>：如果有 <code>Shape</code> 指针 <code>ptr</code>，我们可以使用 <code>dynamic_cast&lt;Circle*&gt;(ptr)</code> 尝试把它转型成 <code>Circle*</code>。系统会进行需要的类型检查，并在转型成功时返回一个非空指针，返回空指针则表示失败（如当 <code>ptr</code> 实际指向的不是 <code>Circle</code>，而是 <code>Rectangle</code>）。</p>
</li>
<li>
<p>static_cast：这是一种在很多认为较安全的场景下的“静态”转型方式。你可以使用它在不同的数值类型之间进行转换，如从 <code>long</code> 到 <code>int</code>，或者从 <code>long long</code> 到 <code>double</code>——当转换有可能有精度损失时，就不能使用隐式类型转换，而得明确使用转型了。你也可以使用它把一个 <code>void*</code> 转成一个实际类型的指针（如 <code>int*</code>）。你还可以用它把基类的指针转成派生类的指针，前提条件是你能确认这个基类的指针确实指向一个派生类的对象。显然，对于这最后一种场景 static_cast 不如 dynamic_cast 安全，但由于不需要进行运行期的检查，它的性能比 <code>dynamic_cast</code> 要高，在很多情况下是个空操作。</p>
</li>
<li>
<p>const_cast：这种转型方式潜在就不那么安全了。它的目的是去掉一个指针或引用类型的 <code>const</code> 或 <code>volatile</code> 修饰，如从 <code>const char*</code> 转换到 <code>char*</code>。这种转型的一种常见用途是把一个 C++ 的指针传递到一个 <code>const</code> 不正确的 C 接口里去，比如 C 接口在该用 <code>const char*</code> 时使用了 <code>char*</code>。注意这种转型只是为了“欺骗”类型系统，让代码能通过编译。如果你通过 <code>const_cast</code> 操作指针或引用去修改一个 <code>const</code> 对象，这仍然是错误的，是未定义行为，可能会导致奇怪的意外结果。</p>
</li>
<li>
<p>reinterpret_cast：这是最不安全的对数据进行“重新解释”的转型方式，用来在不相关的类型之间进行类型转换，如把指针转换成 <code>uintptr_t</code>。这种转换有可能得到错误的结果，比如，在存在多继承的情况下，如要把基类指针转成派生类指针，使用 <code>static_cast</code> 和使用 <code>reinterpret_cast</code> 可能会得到不同的结果：前者会进行偏移量的调整，而后者真的只是简单粗暴的硬转而已，因此结果通常是错的。又如，根据 C++ 的严格别名规则，<strong>如果你用 <code>char</code> 或 <code>byte</code> 之外类型的指针访问并非该类型的对象（如通过 <code>int*</code> 访问 <code>double</code> 对象），会导致未定义行为</strong>。</p>
</li>
</ul>
<p><code>dynamic_cast</code> 和 <code>static_cast</code> 都能用于继承的情况下，比较容易混淆：</p>
<h3 id="dynamic_cast"><strong><code>dynamic_cast</code></strong></h3>
<p>仅适用于多态类型（即具有虚函数的类）的转换。</p>
<p><strong>用途</strong></p>
<ul>
<li>用于类继承层次间的<strong>安全向下转型</strong>（从基类指针/引用转换为派生类指针/引用）。</li>
<li>支持<strong>交叉转换</strong>（同一继承体系中不同分支的类之间的转换，如兄弟类转换）。</li>
<li>运行时检查类型安全性，若转换失败：
<ul>
<li>对指针返回<code>nullptr</code>；</li>
<li>对引用抛出<code>std::bad_cast</code>异常。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> { <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() {} };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Base<span style="color:#f92672">*</span> pb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived;
</span></span><span style="display:flex;"><span>Derived<span style="color:#f92672">*</span> pd <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">*&gt;</span>(pb); <span style="color:#75715e">// 安全转换，返回有效指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Base<span style="color:#f92672">*</span> pb2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Base;
</span></span><span style="display:flex;"><span>Derived<span style="color:#f92672">*</span> pd2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">*&gt;</span>(pb2); <span style="color:#75715e">// 失败，返回nullptr
</span></span></span></code></pre></div><hr>
<h3 id="static_cast"><strong><code>static_cast</code></strong></h3>
<p><strong>用途</strong></p>
<ul>
<li>
<p><strong>非多态类型转换</strong>：如基本数据类型转换（<code>int</code>→<code>double</code>）。</p>
</li>
<li>
<p><strong>上行转换</strong>（派生类→基类），效果与隐式转换相同。</p>
</li>
<li>
<p>显式强制转换（如<code>void*</code>→具体类型指针）。</p>
</li>
<li>
<p>不进行运行时检查。</p>
</li>
<li>
<p>向下转型时若实际对象类型不匹配，可能导致未定义行为（如访问非法内存）。</p>
</li>
<li>
<p>不支持交叉转换（编译报错）。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>(a); <span style="color:#75715e">// 基本类型转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Base<span style="color:#f92672">*</span> base_ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived;
</span></span><span style="display:flex;"><span>Derived<span style="color:#f92672">*</span> derived_ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">*&gt;</span>(base_ptr); <span style="color:#75715e">// 不安全，假设base_ptr实际指向Derived对象
</span></span></span></code></pre></div><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong><code>dynamic_cast</code></strong></th>
          <th><strong><code>static_cast</code></strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>安全性</strong></td>
          <td>运行时类型检查，失败返回<code>nullptr</code>或异常</td>
          <td>无运行时检查，依赖程序员判断</td>
      </tr>
      <tr>
          <td><strong>适用场景</strong></td>
          <td>多态类的向下转型、交叉转换</td>
          <td>非多态转换、上行转换、基本类型转换</td>
      </tr>
      <tr>
          <td><strong>虚函数要求</strong></td>
          <td>必须存在虚函数（RTTI依赖）</td>
          <td>无要求</td>
      </tr>
      <tr>
          <td><strong>性能开销</strong></td>
          <td>较高（运行时类型查询）</td>
          <td>无额外开销（编译时完成）</td>
      </tr>
      <tr>
          <td><strong>转换失败处理</strong></td>
          <td>指针返回<code>nullptr</code>，引用抛出异常</td>
          <td>未定义行为（可能崩溃或数据损坏）</td>
      </tr>
  </tbody>
</table>
<ol>
<li>
<p><strong>优先使用<code>static_cast</code>的场景</strong></p>
<ul>
<li>类型转换明确安全（如上行转换或数值类型转换）。</li>
<li>需要高性能且能确保转换正确性时（如游戏开发中的内联优化）。</li>
</ul>
</li>
<li>
<p><strong>必须使用<code>dynamic_cast</code>的场景</strong></p>
<ul>
<li>多态类的向下转型，尤其是无法确定基类指针实际指向的对象类型时。</li>
<li>需要避免因类型错误导致程序崩溃（如框架中动态加载插件）。</li>
</ul>
</li>
</ol>
<ul>
<li><strong><code>const_cast</code>与<code>reinterpret_cast</code></strong>：
<ul>
<li><code>const_cast</code>用于移除或添加<code>const</code>限定符。</li>
<li><code>reinterpret_cast</code>用于无关类型之间的危险转换（如指针→整数），慎用。</li>
</ul>
</li>
</ul>
]]></content></item><item><title>对 C++ 左值、右值、智能指针的思考</title><link>https://jekyulll.github.io/posts/cpp-%E5%AF%B9-c++-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%80%9D%E8%80%83/</link><pubDate>Thu, 19 Sep 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E5%AF%B9-c++-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%80%9D%E8%80%83/</guid><description>&lt;h5 id="左值右值函数传参">左值右值、函数传参：&lt;/h5>
&lt;ol>
&lt;li>&lt;strong>传值（按值传递）&lt;/strong>
如果函数的参数是通过按值传递的，传入一个右值时，编译器会生成一个临时对象，并将该临时对象复制或移动到函数内部的局部变量中。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>复制：对于不可移动的类型（例如基础类型 int），右值会被复制。&lt;/li>
&lt;li>移动：对于可以移动的类型（例如拥有移动构造函数的类），右值将会被移动，从而避免复制的开销。移动操作是一个高效的浅拷贝操作，将资源的所有权从右值转移到函数内部的局部变量中。&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>&lt;strong>传引用（按引用传递）&lt;/strong>&lt;br>
2.1 传左值引用
&lt;code>void foo(const std::string&amp;amp; s);&lt;/code> 当函数接受一个const 左值引用时，如果传入一个右值，编译器会生成一个临时对象并将它绑定到左值引用上。这时不会发生复制或移动，函数内部会直接使用右值的临时对象。这个临时对象的生命周期会被延长到函数结束。
2.2 传右值引用
&lt;code>void foo(std::string&amp;amp;&amp;amp; s);&lt;/code> 当函数接受一个右值引用时，右值引用参数可以直接绑定到右值，因此不会发生复制。通常情况下，右值引用用于转移资源的所有权，函数内部可以自由地操作该右值引用的内存内容。&lt;/li>
&lt;/ol>
&lt;h6 id="stdmove-与-智能指针">std::move 与 智能指针&lt;/h6>
&lt;p>&lt;code>std::move()&lt;/code> 本身并不会移动数据，它只是将对象的左值强制转换为右值引用，从而允许对象使用移动构造函数或移动赋值运算符。实际的“移动”行为是在这些函数中实现的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>std::move() 可以传入普通指针（如 int*）。传入指针时并不会产生任何有实际意义的“移动”行为，由于指针只是指向某个内存地址的变量(而不负责管理资源)，所以“移动”一个指针只是简单地转移其地址值，并没有实际涉及资源的所有权转移。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当 &lt;code>std::move&lt;/code> 传入智能指针（如 &lt;code>std::unique_ptr&lt;/code> 或 &lt;code>std::shared_ptr&lt;/code>）时，与传入普通指针相比，它会产生实际的资源转移，这是智能指针的移动语义带来的结果。&lt;/p>
&lt;ul>
&lt;li>&lt;code>std::unique_ptr&lt;/code> 是独占所有权的智能指针，意味着它独自管理动态分配的对象。不能复制 &lt;code>std::unique_ptr&lt;/code>，但可以通过移动将所有权转移给另一个 &lt;code>std::unique_ptr&lt;/code>。被移动的 &lt;code>std::unique_ptr&lt;/code> 会变为 &lt;code>nullptr&lt;/code>。&lt;/li>
&lt;li>&lt;code>std::move&lt;/code> + &lt;code>std::shared_ptr&lt;/code>：将 &lt;code>std::shared_ptr&lt;/code> 的引用计数和所有权从一个对象转移到另一个。被移动的 &lt;code>shared_ptr&lt;/code> 变为 &lt;code>nullptr&lt;/code>，但原来共享的资源只会在最后一个 &lt;code>shared_ptr&lt;/code> 销毁时释放。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>void process(std::unique_ptr&amp;lt;int&amp;gt;&amp;amp;&amp;amp; ptr) {
std::cout &amp;lt;&amp;lt; &amp;#34;Value: &amp;#34; &amp;lt;&amp;lt; *ptr &amp;lt;&amp;lt; std::endl;
}
std::unique_ptr&amp;lt;int&amp;gt; p1 = std::make_unique&amp;lt;int&amp;gt;(42);
process(std::move(p1)); // 使用 std::move 将所有权转移给 process 函数
&lt;/code>&lt;/pre>&lt;p>&lt;strong>当 &lt;code>std::unique_ptr&lt;/code> 作为参数传入函数时：&lt;/strong>&lt;/p></description><content type="html"><![CDATA[<h5 id="左值右值函数传参">左值右值、函数传参：</h5>
<ol>
<li><strong>传值（按值传递）</strong>
如果函数的参数是通过按值传递的，传入一个右值时，编译器会生成一个临时对象，并将该临时对象复制或移动到函数内部的局部变量中。</li>
</ol>
<ul>
<li>复制：对于不可移动的类型（例如基础类型 int），右值会被复制。</li>
<li>移动：对于可以移动的类型（例如拥有移动构造函数的类），右值将会被移动，从而避免复制的开销。移动操作是一个高效的浅拷贝操作，将资源的所有权从右值转移到函数内部的局部变量中。</li>
</ul>
<ol start="2">
<li><strong>传引用（按引用传递）</strong><br>
2.1 传左值引用
<code>void foo(const std::string&amp; s);</code> 当函数接受一个const 左值引用时，如果传入一个右值，编译器会生成一个临时对象并将它绑定到左值引用上。这时不会发生复制或移动，函数内部会直接使用右值的临时对象。这个临时对象的生命周期会被延长到函数结束。
2.2 传右值引用
<code>void foo(std::string&amp;&amp; s);</code> 当函数接受一个右值引用时，右值引用参数可以直接绑定到右值，因此不会发生复制。通常情况下，右值引用用于转移资源的所有权，函数内部可以自由地操作该右值引用的内存内容。</li>
</ol>
<h6 id="stdmove-与-智能指针">std::move 与 智能指针</h6>
<p><code>std::move()</code> 本身并不会移动数据，它只是将对象的左值强制转换为右值引用，从而允许对象使用移动构造函数或移动赋值运算符。实际的“移动”行为是在这些函数中实现的。</p>
<ul>
<li>
<p>std::move() 可以传入普通指针（如 int*）。传入指针时并不会产生任何有实际意义的“移动”行为，由于指针只是指向某个内存地址的变量(而不负责管理资源)，所以“移动”一个指针只是简单地转移其地址值，并没有实际涉及资源的所有权转移。</p>
</li>
<li>
<p>当 <code>std::move</code> 传入智能指针（如 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code>）时，与传入普通指针相比，它会产生实际的资源转移，这是智能指针的移动语义带来的结果。</p>
<ul>
<li><code>std::unique_ptr</code> 是独占所有权的智能指针，意味着它独自管理动态分配的对象。不能复制 <code>std::unique_ptr</code>，但可以通过移动将所有权转移给另一个 <code>std::unique_ptr</code>。被移动的 <code>std::unique_ptr</code> 会变为 <code>nullptr</code>。</li>
<li><code>std::move</code> + <code>std::shared_ptr</code>：将 <code>std::shared_ptr</code> 的引用计数和所有权从一个对象转移到另一个。被移动的 <code>shared_ptr</code> 变为 <code>nullptr</code>，但原来共享的资源只会在最后一个 <code>shared_ptr</code> 销毁时释放。</li>
</ul>
</li>
</ul>
<pre tabindex="0"><code>void process(std::unique_ptr&lt;int&gt;&amp;&amp; ptr) {
    std::cout &lt;&lt; &#34;Value: &#34; &lt;&lt; *ptr &lt;&lt; std::endl;
}
std::unique_ptr&lt;int&gt; p1 = std::make_unique&lt;int&gt;(42);
process(std::move(p1));  // 使用 std::move 将所有权转移给 process 函数
</code></pre><p><strong>当 <code>std::unique_ptr</code> 作为参数传入函数时：</strong></p>
<ul>
<li>如果 <code>unique_ptr</code> 是左值并传递到需要按值接收 unique_ptr 的函数，会导致编译错误，因为 <code>unique_ptr</code> 不支持拷贝。</li>
<li>按左值引用传递不会转移所有权，传入的 <code>unique_ptr</code> 仍保持有效。</li>
<li>如果需要转移所有权，通常使用右值引用或者 <code>std::move</code> 将其显式地转换为右值。</li>
</ul>
<p>之前把函数对象/仿函数当做是麻烦版本的lamada，看书里的用法才知道其灵活性。相当于一个方便管理变量的函数。</p>
]]></content></item><item><title>C++ 模板类型推导</title><link>https://jekyulll.github.io/posts/cpp-morden-c++-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</link><pubDate>Sun, 01 Sep 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-morden-c++-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</guid><description>&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/649667647">一篇文章学完 Effective Modern C++：条款 &amp;amp; 实践&lt;/a>：&lt;/p>
&lt;h2 id="条款1-模板参数类型推导引用折叠">条款1： 模板参数类型推导，引用折叠&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> f(T&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> param);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">27&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> cx &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> rx &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 左值的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>f(x); &lt;span style="color:#75715e">// T 的类型为 int&amp;amp;, paramType 为 int&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>f(cx); &lt;span style="color:#75715e">// T 的类型为 const int&amp;amp;, paramType 为 const int&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>f(rx); &lt;span style="color:#75715e">// T 的类型为 const int&amp;amp;, paramType 为 const int&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 右值的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>f(&lt;span style="color:#ae81ff">27&lt;/span>) &lt;span style="color:#75715e">// T 的类型为 int, paramType 为 int&amp;amp;&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于指向 &lt;code>const&lt;/code> 对象的 &lt;code>const&lt;/code> 指针的传递，仅有指针本身的常量性会被忽略：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> f(T param);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> ptr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Fun with pointers&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>f(ptr); &lt;span style="color:#75715e">// T 和 param 的类型均为 const char*
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：&lt;/p></description><content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/649667647">一篇文章学完 Effective Modern C++：条款 &amp; 实践</a>：</p>
<h2 id="条款1-模板参数类型推导引用折叠">条款1： 模板参数类型推导，引用折叠</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f(T<span style="color:#f92672">&amp;&amp;</span> param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">27</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> cx <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> rx <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 左值的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>f(x);    <span style="color:#75715e">// T 的类型为 int&amp;, paramType 为 int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>f(cx);   <span style="color:#75715e">// T 的类型为 const int&amp;, paramType 为 const int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>f(rx);   <span style="color:#75715e">// T 的类型为 const int&amp;, paramType 为 const int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 右值的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>f(<span style="color:#ae81ff">27</span>)    <span style="color:#75715e">// T 的类型为 int, paramType 为 int&amp;&amp;
</span></span></span></code></pre></div><p>对于指向 <code>const</code> 对象的 <code>const</code> 指针的传递，仅有指针本身的常量性会被忽略：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f(T param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> ptr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Fun with pointers&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f(ptr);    <span style="color:#75715e">// T 和 param 的类型均为 const char*
</span></span></span></code></pre></div><p>按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f(T<span style="color:#f92672">&amp;</span> param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> name[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;J. P. Briggs&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f(name);   <span style="color:#75715e">// T 的类型为 const char[13], paramType 为 const char (&amp;)[13]
</span></span></span></code></pre></div><p>利用声明数组引用这一能力可以创造出一个模板，用来推导出数组含有的元素个数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, std<span style="color:#f92672">::</span>size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">constexpr</span> std<span style="color:#f92672">::</span>size_t arraySize(T (<span style="color:#f92672">&amp;</span>)[N]) <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> N;
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// constexpr 函数，表示这个函数可以在编译时计算结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>size_t size <span style="color:#f92672">=</span> arraySize(arr); <span style="color:#75715e">// size 的值是 10
</span></span></span></code></pre></div><p>函数类型同样也会退化成函数指针，并且和数组类型的规则类似：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">someFunc</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">double</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f1(T param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f2(T<span style="color:#f92672">&amp;</span> param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f1(someFunc);   <span style="color:#75715e">// param 被推导为函数指针，具体类型为 void (*)(int, double)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>f2(someFunc);   <span style="color:#75715e">// param 被推导为函数引用，具体类型为 void (&amp;)(int, double)
</span></span></span></code></pre></div><h2 id="条款2-auto类型推导">条款2： auto类型推导</h2>
<h2 id="条款3理解-decltype">条款3：理解 decltype</h2>
<p>在 C++11 中，<code>decltype</code>的主要用途是声明返回值类型依赖于形参类型的函数模板，这需要用到返回值类型尾置语法(trailing return type syntax)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Container, <span style="color:#66d9ef">typename</span> Index<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> authAndAccess(Container<span style="color:#f92672">&amp;</span> c, Index i) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(c[i]) {
</span></span><span style="display:flex;"><span>    authenticateUser();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> c[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>C++11 允许对单表达式的 lambda 的返回值实施类型推导，而 C++14 将这个允许范围扩张到了一切函数和一切 lambda，包括那些多表达式的。这就意味着在 C++14 中可以去掉返回值类型尾置语法，仅保留前导<code>auto</code>。<br>
但编译器会为<code>auto</code>指定为返回值类型的函数实施模板类型推导，这样就会留下隐患（例如忽略初始化表达的引用性），使用<code>decltype(auto)</code>来说明我们采用的是<code>decltype</code>的规则，就可以解决这个问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Container, <span style="color:#66d9ef">typename</span> Index<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) authAndAccess(Container<span style="color:#f92672">&amp;</span> c, Index i) {
</span></span><span style="display:flex;"><span>    authenticateUser();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> c[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在初始化表达式处也可以应用<code>decltype</code>类型推导规则：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Widget w;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;</span> cw <span style="color:#f92672">=</span> w;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> myWidget1 <span style="color:#f92672">=</span> cw;            <span style="color:#75715e">// auto 推导出类型为 Widget
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) myWidget2 <span style="color:#f92672">=</span> cw;  <span style="color:#75715e">// decltype 推导出类型为 const Widget&amp;
</span></span></span></code></pre></div><p>在上述情形中，我们无法向函数传递右值容器，若想要采用一种既能绑定到左值也能绑定到右值的引用形参，就需要借助万能引用，并应用<code>std::forward</code>（参考条款 25）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Container, <span style="color:#66d9ef">typename</span> Index<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) authAndAccess(Container<span style="color:#f92672">&amp;&amp;</span> c, Index i) {
</span></span><span style="display:flex;"><span>    authenticateUser();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>Container<span style="color:#f92672">&gt;</span>(c)[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>C++ 的三五法则是什么？</title><link>https://jekyulll.github.io/posts/cpp-c++-%E7%9A%84%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 26 Aug 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E7%9A%84%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88/</guid><description>&lt;p>三五法则（Rule of Three/Five/Zero）。&lt;/p>
&lt;p>“三法则”主要适用于 C++98/03 标准下的资源管理。在使用动态内存或其他资源时，如果类需要显式地管理资源，通常需要实现以下三个特殊成员函数：&lt;/p>
&lt;ol>
&lt;li>拷贝构造函数（Copy Constructor）：用于复制对象时分配新资源。&lt;/li>
&lt;li>拷贝赋值运算符（Copy Assignment Operator）：用于对象赋值时释放旧资源并分配新资源。&lt;/li>
&lt;li>析构函数（Destructor）：用于对象销毁时释放资源。&lt;/li>
&lt;li>&lt;/li>
&lt;/ol>
&lt;p>随着 C++11 引入了移动语义和右值引用，&amp;ldquo;五法则&amp;quot;扩展了“三法则”，增加了两个新的特殊成员函数：&lt;/p>
&lt;ol>
&lt;li>移动构造函数（Move Constructor）：用于移动对象时“窃取”资源，而不是复制。&lt;/li>
&lt;li>移动赋值运算符（Move Assignment Operator）：用于对象赋值时“窃取”资源，而不是复制。&lt;/li>
&lt;/ol></description><content type="html"><![CDATA[<p>三五法则（Rule of Three/Five/Zero）。</p>
<p>“三法则”主要适用于 C++98/03 标准下的资源管理。在使用动态内存或其他资源时，如果类需要显式地管理资源，通常需要实现以下三个特殊成员函数：</p>
<ol>
<li>拷贝构造函数（Copy Constructor）：用于复制对象时分配新资源。</li>
<li>拷贝赋值运算符（Copy Assignment Operator）：用于对象赋值时释放旧资源并分配新资源。</li>
<li>析构函数（Destructor）：用于对象销毁时释放资源。</li>
<li></li>
</ol>
<p>随着 C++11 引入了移动语义和右值引用，&ldquo;五法则&quot;扩展了“三法则”，增加了两个新的特殊成员函数：</p>
<ol>
<li>移动构造函数（Move Constructor）：用于移动对象时“窃取”资源，而不是复制。</li>
<li>移动赋值运算符（Move Assignment Operator）：用于对象赋值时“窃取”资源，而不是复制。</li>
</ol>
]]></content></item><item><title>C++ 17 编译期 if</title><link>https://jekyulll.github.io/posts/cpp-c++-17-%E7%BC%96%E8%AF%91%E6%9C%9F-if/</link><pubDate>Sat, 10 Aug 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-17-%E7%BC%96%E8%AF%91%E6%9C%9F-if/</guid><description>&lt;p>&lt;a href="https://www.bilibili.com/video/BV1Eb42177a8/?spm_id_from=333.1007.tianma.1-1-1.click&amp;amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">C++17编译期if&lt;/a>：&lt;code>constexpr&lt;/code>。&lt;/p>
&lt;p>用例：不加&lt;code>constexpr&lt;/code>会编译出错，因为必有一种情况是语法错误的。如果&lt;code>T&lt;/code>为&lt;code>X&lt;/code>类型，则内部没有&lt;code>y_func()&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> f(T t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 判断类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_same_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, X&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t.x_func();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#75715e">// 此处若为 &amp;#34;舍弃语句&amp;#34;，不会参加编译。但会检查语法错误(但不会检查模板的实例化)。而预处理器if(#if)如果舍弃，完全不检查。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> t.y_func();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回类型推导：C++14后可以用&lt;code>auto&lt;/code>作为函数返回值，但所有表达式必须推导出相同的返回类型(不能在不同情况下返回不同的类型，例如&lt;code>int&lt;/code>和&lt;code>float&lt;/code>)。但如果在判断的地方使用&lt;code>constexpr&lt;/code>，能通过编译(因为是在编译期判断的)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> (...) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1.0f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description><content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Eb42177a8/?spm_id_from=333.1007.tianma.1-1-1.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">C++17编译期if</a>：<code>constexpr</code>。</p>
<p>用例：不加<code>constexpr</code>会编译出错，因为必有一种情况是语法错误的。如果<code>T</code>为<code>X</code>类型，则内部没有<code>y_func()</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f(T t) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span>T, X<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>		t.x_func();
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 此处若为 &#34;舍弃语句&#34;，不会参加编译。但会检查语法错误(但不会检查模板的实例化)。而预处理器if(#if)如果舍弃，完全不检查。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		t.y_func();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>返回类型推导：C++14后可以用<code>auto</code>作为函数返回值，但所有表达式必须推导出相同的返回类型(不能在不同情况下返回不同的类型，例如<code>int</code>和<code>float</code>)。但如果在判断的地方使用<code>constexpr</code>，能通过编译(因为是在编译期判断的)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">func</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">constexpr</span> (...) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1.0f</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content></item><item><title>OpenGL 初学笔记 -- Cherno + LearnOpenGL</title><link>https://jekyulll.github.io/posts/opengl-%E8%8F%9C--opengl-%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0----cherno-+-learnopengl/</link><pubDate>Mon, 29 Jul 2024 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/opengl-%E8%8F%9C--opengl-%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0----cherno-+-learnopengl/</guid><description>&lt;p>&lt;img src="https://jekyulll.github.io/images/ayanami_header.jpg" alt="hearder">&lt;/p>
&lt;p>这两个月学习了一下OpenGL。从Cherno的教学视频开始学习，看完后开始看LearnOpenGL，应该是很常见的学习路径。&lt;br>
在此以新手视角，记录一下学习中在工程方面遇到的一些坑（数学和底层方面就不打算开口丢人了）。&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/@TheCherno">Cherno主页&lt;/a> | &lt;a href="https://learnopengl.com/">LearnOpenGL&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="1-直接选择-64-位">&lt;strong>1.&lt;/strong> 直接选择 64 位&lt;/h2>
&lt;p>Cherno视频是2017及之前的，为了兼容性，教程里32位。而LearnOpenGL写到后面是64位，还要用Assimp库，默认是编译成64位。建议直接x64，像我这样闷头跟着写的话要把 GLEW 和 GLFW 的静态库全换一遍，或者去折腾CMake。&lt;/p>
&lt;hr>
&lt;h2 id="2-glew-glad-glfw">&lt;strong>2.&lt;/strong> GLEW, GLAD, GLFW&lt;/h2>
&lt;p>这三个比较常用。两个教程的选择都是 GLEW + GLFW，其中 GLEW 和 GLAD 定位相似，都是用于访问OpenGL函数。可以先看看自己喜欢哪一个，免得后面想换再费功夫。&lt;/p>
&lt;hr>
&lt;h2 id="3-texture-的实现----小心析构函数">&lt;strong>3.&lt;/strong> &lt;code>Texture&lt;/code> 的实现 &amp;ndash; 小心析构函数&lt;/h2>
&lt;p>LearnOpenGL中的&lt;code>Texture&lt;/code>只是一个存储数据的结构体：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Texture&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GLuint id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aiString path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而Cherno将&lt;code>Texture&lt;/code>创建为类，构造函数中直接完成加载图片的操作，并且在析构函数里调用&lt;code>glDeleteTextures&lt;/code>。&lt;br>
如果无脑缝代码就完蛋了，因为LearnOpenGL在&lt;code>Model::loadMaterialTextures&lt;/code>函数中创建了&lt;code>Texture&lt;/code>的临时对象并返回，会调用析构函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&lt;/span> loadMaterialTextures(aiMaterial&lt;span style="color:#f92672">*&lt;/span> mat, aiTextureType type, string typeName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&lt;/span> textures;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> textures;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以选择：&lt;/p>
&lt;ol>
&lt;li>修改Texture类的实现（比如把）glDeleteTextures单独调用；&lt;/li>
&lt;li>修改Model类中加载纹理的实现，例如传入Texture的引用；&lt;/li>
&lt;li>使用指针。我选择了使用智能指针（相对应的地方全要改）：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 顺便把参数改成 `aiTextureType`(Assimp定义的用于表示Texture不同类型的枚举)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 优化掉LearnOpenGL里那个丑陋的字符串处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> Model&lt;span style="color:#f92672">::&lt;/span>loadMaterialTextures(aiMaterial&lt;span style="color:#f92672">*&lt;/span> mat, aiTextureType type)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> textures;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (GLuint i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> mat&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetTextureCount(type); i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aiString str;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mat&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetTexture(type, i, &lt;span style="color:#f92672">&amp;amp;&lt;/span>str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> canSkip &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>textures_loaded.size(); j&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (textures_loaded[j]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>path &lt;span style="color:#f92672">==&lt;/span> str)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> textures.push_back(textures_loaded[j]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> canSkip &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>canSkip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string filename &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string(str.C_Str());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filename &lt;span style="color:#f92672">=&lt;/span> directory &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> filename;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&lt;/span> texture &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>make_shared&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&lt;/span>(filename); &lt;span style="color:#75715e">// 教程里此处调用了TextureFromFile()来初始化texture，但可以用Texture的构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> texture&lt;span style="color:#f92672">-&amp;gt;&lt;/span>type &lt;span style="color:#f92672">=&lt;/span> type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> texture&lt;span style="color:#f92672">-&amp;gt;&lt;/span>path &lt;span style="color:#f92672">=&lt;/span> str;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> textures.push_back(texture);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>textures_loaded.push_back(texture);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> textures;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同理，小心其他类里的析构函数（例如Shader类可能会在析构里调用glDeleteProgram）。&lt;/p></description><content type="html"><![CDATA[<p><img src="/images/ayanami_header.jpg" alt="hearder"></p>
<p>这两个月学习了一下OpenGL。从Cherno的教学视频开始学习，看完后开始看LearnOpenGL，应该是很常见的学习路径。<br>
在此以新手视角，记录一下学习中在工程方面遇到的一些坑（数学和底层方面就不打算开口丢人了）。</p>
<p><a href="https://www.youtube.com/@TheCherno">Cherno主页</a> | <a href="https://learnopengl.com/">LearnOpenGL</a></p>
<hr>
<h2 id="1-直接选择-64-位"><strong>1.</strong> 直接选择 64 位</h2>
<p>Cherno视频是2017及之前的，为了兼容性，教程里32位。而LearnOpenGL写到后面是64位，还要用Assimp库，默认是编译成64位。建议直接x64，像我这样闷头跟着写的话要把 GLEW 和 GLFW 的静态库全换一遍，或者去折腾CMake。</p>
<hr>
<h2 id="2-glew-glad-glfw"><strong>2.</strong> GLEW, GLAD, GLFW</h2>
<p>这三个比较常用。两个教程的选择都是 GLEW + GLFW，其中 GLEW 和 GLAD 定位相似，都是用于访问OpenGL函数。可以先看看自己喜欢哪一个，免得后面想换再费功夫。</p>
<hr>
<h2 id="3-texture-的实现----小心析构函数"><strong>3.</strong> <code>Texture</code> 的实现 &ndash; 小心析构函数</h2>
<p>LearnOpenGL中的<code>Texture</code>只是一个存储数据的结构体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Texture</span> {
</span></span><span style="display:flex;"><span>    GLuint id;
</span></span><span style="display:flex;"><span>    string type;
</span></span><span style="display:flex;"><span>    aiString path;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>而Cherno将<code>Texture</code>创建为类，构造函数中直接完成加载图片的操作，并且在析构函数里调用<code>glDeleteTextures</code>。<br>
如果无脑缝代码就完蛋了，因为LearnOpenGL在<code>Model::loadMaterialTextures</code>函数中创建了<code>Texture</code>的临时对象并返回，会调用析构函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span> loadMaterialTextures(aiMaterial<span style="color:#f92672">*</span> mat, aiTextureType type, string typeName)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span> textures;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> textures;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以选择：</p>
<ol>
<li>修改Texture类的实现（比如把）glDeleteTextures单独调用；</li>
<li>修改Model类中加载纹理的实现，例如传入Texture的引用；</li>
<li>使用指针。我选择了使用智能指针（相对应的地方全要改）：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 顺便把参数改成 `aiTextureType`(Assimp定义的用于表示Texture不同类型的枚举)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 优化掉LearnOpenGL里那个丑陋的字符串处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;&gt;</span> Model<span style="color:#f92672">::</span>loadMaterialTextures(aiMaterial<span style="color:#f92672">*</span> mat, aiTextureType type)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;&gt;</span> textures;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (GLuint i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> mat<span style="color:#f92672">-&gt;</span>GetTextureCount(type); i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        aiString str;
</span></span><span style="display:flex;"><span>        mat<span style="color:#f92672">-&gt;</span>GetTexture(type, i, <span style="color:#f92672">&amp;</span>str);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> canSkip <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>textures_loaded.size(); j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (textures_loaded[j]<span style="color:#f92672">-&gt;</span>path <span style="color:#f92672">==</span> str)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                textures.push_back(textures_loaded[j]);
</span></span><span style="display:flex;"><span>                canSkip <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>canSkip)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>string filename <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>string(str.C_Str());
</span></span><span style="display:flex;"><span>            filename <span style="color:#f92672">=</span> directory <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;/&#39;</span> <span style="color:#f92672">+</span> filename;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span> texture <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span>(filename); <span style="color:#75715e">// 教程里此处调用了TextureFromFile()来初始化texture，但可以用Texture的构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            texture<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">=</span> type;   
</span></span><span style="display:flex;"><span>            texture<span style="color:#f92672">-&gt;</span>path <span style="color:#f92672">=</span> str;
</span></span><span style="display:flex;"><span>            textures.push_back(texture);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>textures_loaded.push_back(texture);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> textures;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同理，小心其他类里的析构函数（例如Shader类可能会在析构里调用glDeleteProgram）。</p>
]]></content></item><item><title>C++ / Golang / 游戏开发 / TA 学习路线汇总</title><link>https://jekyulll.github.io/posts/means/</link><pubDate>Sun, 02 Jun 2024 19:46:34 +0800</pubDate><guid>https://jekyulll.github.io/posts/means/</guid><description>&lt;!-- -- 2024年6月2日23:56:19
收藏的路线越来越多，有点乱。单列一个文件，想到的时候汇总一下。 -->
&lt;h1 id="c">C++&lt;/h1>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/649667647">一篇文章学完 Effective Modern C++：条款 &amp;amp; 实践&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/14264391441">深入理解C++内存管理：指针、引用和内存分配&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/274189552/answer/3578048970">CPU的核心数和线程数量是什么关系？ - texttime vage的回答 - 知乎&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://space.bilibili.com/28615855/channel/collectiondetail?sid=43297">合集·现代 C++ 语言核心特性解析&lt;/a>。&lt;br>
&lt;a href="https://changkun.de/modern-cpp/zh-cn/01-intro/">现代 C++ 教程：高速上手 C++ 11/14/17/20&lt;/a>。&lt;/p>
&lt;p>小鹏的教程：&lt;a href="https://space.bilibili.com/263032155/channel/collectiondetail?sid=599074">合集·现代C++项目实战&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/290102232/answer/2094675219">校招C++大概学习到什么程度？ - 程序员内功修炼的回答 - 知乎&lt;/a>。八股文组合拳。&lt;/p>
&lt;p>陈皓（左耳朵耗子）的一些博客：&lt;br>
&lt;a href="https://blog.csdn.net/haoel/article/details/1948051">C++ 虚函数表解析&lt;/a>。&lt;br>
&lt;a href="https://haoel.blog.csdn.net/article/details/3081328">C++ 对象的内存布局（上）&lt;/a>。&lt;br>
&lt;a href="https://haoel.blog.csdn.net/article/details/2886">跟我一起写 Makefile（一）&lt;/a>。&lt;br>
&lt;a href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://github.com/Light-City/CPlusPlusThings">C++那些事 CPlusPlusThings&lt;/a>。&lt;br>
&lt;a href="https://light-city.github.io/stories_things/">C++那些事 中文&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">现代C++教程 2023&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">CUDA C++ Programming Guide&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/394704611/answer/1245846184">如何成为linux服务端C++开发专家? - 不谙世事的吴同学的回答 - 知乎&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/527327054">c++17 多态内存资源(PMR)&lt;/a>。&lt;br>
&lt;a href="https://zhuanlan.zhihu.com/p/452697297">内存管理：设计Arena&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1Se411D7y4/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">这本书加深了我对C++的理解 | C++ Core Guidelines解析&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_42136255/article/details/133815129">深入理解Asan:内存错误检测工具与实践&lt;/a>。&lt;/p>
&lt;!-- [C++翻译阶段中的编码转换-执行字符集与源字符集](https://www.bilibili.com/video/BV1yof2Y4EPF/?spm_id_from=333.1007.tianma.2-1-4.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a)。 -->
&lt;p>&lt;a href="https://www.zhihu.com/question/428340896/answer/2913419725">为什么C/C++等少数编程语言要区分左右值？ - 腾讯技术工程的回答 - 知乎&lt;/a>。非常牛逼。讲得很深，从C语言的发展、寄存器讲起。&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/670821214">13.纤程（Fiber）与协程（Coroutine）&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://baijiahao.baidu.com/s?id=1719486804831856788&amp;amp;wfr=spider&amp;amp;for=pc">深入并发之线程、进程、纤程、协程、管程与死锁、活锁｜详解&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/33979489/answer/1854635802">从操作系统内存管理来说，malloc申请一块内存的背后原理是什么？ - 编程指北的回答 - 知乎&lt;/a>。&lt;/p></description><content type="html"><![CDATA[<!-- -- 2024年6月2日23:56:19
收藏的路线越来越多，有点乱。单列一个文件，想到的时候汇总一下。 -->
<h1 id="c">C++</h1>
<p><a href="https://zhuanlan.zhihu.com/p/649667647">一篇文章学完 Effective Modern C++：条款 &amp; 实践</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/14264391441">深入理解C++内存管理：指针、引用和内存分配</a>。</p>
<p><a href="https://www.zhihu.com/question/274189552/answer/3578048970">CPU的核心数和线程数量是什么关系？ - texttime vage的回答 - 知乎</a>。</p>
<p><a href="https://space.bilibili.com/28615855/channel/collectiondetail?sid=43297">合集·现代 C++ 语言核心特性解析</a>。<br>
<a href="https://changkun.de/modern-cpp/zh-cn/01-intro/">现代 C++ 教程：高速上手 C++ 11/14/17/20</a>。</p>
<p>小鹏的教程：<a href="https://space.bilibili.com/263032155/channel/collectiondetail?sid=599074">合集·现代C++项目实战</a>。</p>
<p><a href="https://www.zhihu.com/question/290102232/answer/2094675219">校招C++大概学习到什么程度？ - 程序员内功修炼的回答 - 知乎</a>。八股文组合拳。</p>
<p>陈皓（左耳朵耗子）的一些博客：<br>
<a href="https://blog.csdn.net/haoel/article/details/1948051">C++ 虚函数表解析</a>。<br>
<a href="https://haoel.blog.csdn.net/article/details/3081328">C++ 对象的内存布局（上）</a>。<br>
<a href="https://haoel.blog.csdn.net/article/details/2886">跟我一起写 Makefile（一）</a>。<br>
<a href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a>。</p>
<p><a href="https://github.com/Light-City/CPlusPlusThings">C++那些事 CPlusPlusThings</a>。<br>
<a href="https://light-city.github.io/stories_things/">C++那些事 中文</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">现代C++教程 2023</a>。</p>
<p><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">CUDA C++ Programming Guide</a>。</p>
<p><a href="https://www.zhihu.com/question/394704611/answer/1245846184">如何成为linux服务端C++开发专家? - 不谙世事的吴同学的回答 - 知乎</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/527327054">c++17 多态内存资源(PMR)</a>。<br>
<a href="https://zhuanlan.zhihu.com/p/452697297">内存管理：设计Arena</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1Se411D7y4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">这本书加深了我对C++的理解 | C++ Core Guidelines解析</a>。</p>
<p><a href="https://blog.csdn.net/weixin_42136255/article/details/133815129">深入理解Asan:内存错误检测工具与实践</a>。</p>
<!-- [C++翻译阶段中的编码转换-执行字符集与源字符集](https://www.bilibili.com/video/BV1yof2Y4EPF/?spm_id_from=333.1007.tianma.2-1-4.click&vd_source=9b0b9cbfd8c349b95b4776bd10953f3a)。 -->
<p><a href="https://www.zhihu.com/question/428340896/answer/2913419725">为什么C/C++等少数编程语言要区分左右值？ - 腾讯技术工程的回答 - 知乎</a>。非常牛逼。讲得很深，从C语言的发展、寄存器讲起。</p>
<p><a href="https://zhuanlan.zhihu.com/p/670821214">13.纤程（Fiber）与协程（Coroutine）</a>。</p>
<p><a href="https://baijiahao.baidu.com/s?id=1719486804831856788&amp;wfr=spider&amp;for=pc">深入并发之线程、进程、纤程、协程、管程与死锁、活锁｜详解</a>。</p>
<p><a href="https://www.zhihu.com/question/33979489/answer/1854635802">从操作系统内存管理来说，malloc申请一块内存的背后原理是什么？ - 编程指北的回答 - 知乎</a>。</p>
<p><a href="https://blog.csdn.net/m0_49476241/article/details/131183319">深入理解程序的结构</a>。<br>
<a href="https://blog.csdn.net/qq_26626709/article/details/51887085">快速理解 <code>.bss</code>、<code>.data</code>和<code>.rodata</code></a>。
<a href="https://blog.csdn.net/OUYANG_LINUX007/article/details/7448814?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-7448814-blog-51887085.235%5Ev43%5Epc_blog_bottom_relevance_base4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-7448814-blog-51887085.235%5Ev43%5Epc_blog_bottom_relevance_base4&amp;utm_relevant_index=2">bss,data,text,rodata,堆,栈,常量段</a>。</p>
<p><a href="https://www.zhihu.com/question/20201738/answer/2928936881">有哪些优秀的 C/C++ 开源代码框架？这些框架的设计思路是怎样的？ - 南山烟雨珠江潮的回答 - 知乎</a>。</p>
<p><a href="https://www.bilibili.com/video/BV11cwbeXEyw/?spm_id_from=333.1007.tianma.2-2-5.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">C++内存模型：从C++11到C++23 - Alex Dathskovsky - CppCon 2023</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1Yr4y157Ci/">C++设计模式入门</a>。</p>
<p><a href="https://developer.aliyun.com/article/1324367">Linux系统调试篇——核心转储(core dump)</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1MtQLYhEm1">编译过程-动画演示</a>。</p>
<h3 id="项目--库">项目 / 库</h3>
<p><a href="https://aweiii.work/posts/23109e98/">webserver面试题汇总</a>。<br>
<a href="https://zhuanlan.zhihu.com/p/985908526">从面试角度重新看c++11的Webserver</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/6426611756">linux服务器编程：从epoll升级到io_uring</a>。
<a href="https://mp.weixin.qq.com/s?__biz=MzIyMDkxMTIwNA==&amp;mid=2247485149&amp;idx=1&amp;sn=20fc45200195e6af774599147d4c37dc&amp;chksm=96d59b436d32e4b4546098b54e43372ee243a5600c1914cb80311f0e7989918df8e20d88e441&amp;mpshare=1&amp;scene=23&amp;srcid=1101sK368AjN8MB04HoF6NK3&amp;sharer_shareinfo=89f1444dc11755950d46ef3891230eb1&amp;sharer_shareinfo_first=5fb62de6698930fcaad86ddac76a5b7f#rd">Swoole v6 将引入 Linux io_uring ，并发读写文件性能提升了 5 倍</a>。</p>
<p>知名开源小线程池：<a href="https://github.com/mtrebi/thread-pool">thread-pool</a>。<br>
<a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池 - Skykey的文章 - 知乎</a>。</p>
<p>C++项目：<a href="https://www.zhihu.com/question/280881677/answer/3110226717">如何找合适的C++项目给自己的简历加分？ - 大糖的回答 - 知乎</a>。</p>
<p>游双《Linux高性能服务器》springsnail（一个简易的四层负载均衡服务器，只提供least connection最小连接数算法，以进程池提供原动力）、LVS（linux virtual server，一个成熟的四层负载均衡服务器，提供了3种工作模式和10种负载均衡算法等等）</p>
<p><a href="https://zhuanlan.zhihu.com/p/3306132128">深入探索libevent网络库的内部实现机制</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1a4zzYKEAt/?spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">C++Linux进阶项目分析-仿写Redis之Qedis，深入掌握C++Linux必备的Redis技术栈</a>。</p>
<p>vectorDB：<a href="https://www.zhihu.com/question/610131777/answer/64211441517">有什么高质量c++练手项目推荐嘛？ - zlatan的回答 - 知乎</a>。</p>
<p><a href="https://space.bilibili.com/48698932/channel/collectiondetail?sid=1466783&amp;spm_id_from=333.788.0.0">合集·CheatEngine源码探究</a>。</p>
<p><a href="https://github.com/alibaba/yalantinglibs">雅兰亭库</a>, 是一个非常现代的c++库(阿里写的), 除了反射 还有协程库、RPC库&hellip;</p>
<p><a href="https://www.bilibili.com/video/BV1bGkPYzExW/?spm_id_from=333.1007.tianma.1-2-2.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">Linux C++项目推荐：WebFileServer文件服务器+如何快速上手C++大项目</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/18232912635?utm_campaign=shareopn&amp;utm_medium=social&amp;utm_psn=1862832492203089920&amp;utm_source=wechat_session">小而美的C++项目推荐：缓存系统</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/337200770?utm_campaign=shareopn&amp;utm_medium=social&amp;utm_psn=1864621380202528768&amp;utm_source=wechat_session">&ldquo;全球最强&rdquo; | C++ 动态反射库</a>。</p>
<p><a href="https://www.bilibili.com/cheese/play/ss3021?query_from=0&amp;search_id=10611084605111698952&amp;search_query=RPC&amp;csource=common_hpsearch_null_null&amp;spm_id_from=333.337.search-card.all.click">C++后台开发实战-高性能异步RPC框架</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/612921777">三个比较小的C++项目与简历内容 - 严格鸽的文章 - 知乎</a>。json解析器，跳表，线程池。</p>
<p><a href="https://github.com/CodingHanYa/workspace">workspace是基于C++11的轻量级异步执行框架</a>。一个开源的线程池。<br>
这是前身的教程：<a href="https://www.bilibili.com/video/BV1CY4y1Z7NG">01 Hipe_C++线程池框架_简介（更新）</a>。</p>
<p><a href="https://blog.csdn.net/m0_73311735/article/details/127788105">netty源码看不懂？试着写一个吧</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/113695485">深入了解QT消息循环及线程相关性Froser</a>。</p>
<p><a href="https://www.cnblogs.com/fortunely/p/17388565.html">spdlog库笔记汇总</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1YG41137Vk">黑马C++项目之分布式服务器编程</a>。</p>
<h3 id="面经">面经</h3>
<p>百度面经。<a href="https://www.zhihu.com/question/585465188/answer/2958195873">C++ 找工作校招需要掌握到什么程度？ - 阿biu的回答 - 知乎</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/1416699587">C/C++高频面试题：内存泄漏的原因、检测、解决方案</a>。</p>
<p><a href="https://www.nowcoder.com/discuss/353157644871475200">腾讯天美C++后端三次面试</a>。</p>
<p><a href="https://www.nowcoder.com/discuss/353154640814481408">一个失败者的秋招面经</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/4044485462">腾讯一面：malloc是如何分配内存的，free怎么知道该释放多少内存？</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1eHwPewE4E/?spm_id_from=333.337.top_right_bar_window_history.content.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">字节跳动C++二面：手撕shared_ptr</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1Rbwhe3Euh/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">华为海思C++一面：手撕线程池~源码分享</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1KgATecEDk/?spm_id_from=333.1007.tianma.2-2-5.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">腾讯、百度C++二面：手撕定时器实现、附实现源码~</a></p>
<p><a href="https://www.nowcoder.com/feed/main/detail/624784454bde4a04a8466f60c0dfc739?sourceSSR=search">momenta内推momenta面经 Go</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/985908526">从面试角度重新看c++11的Webserver</a>。</p>
<p><a href="https://www.zhihu.com/zvideo/1415721944793124864?utm_id=0">大厂面试系统设计题：如何设计一个红包雨系统？</a></p>
<p><a href="https://xiaolincoding.com/os/#%E5%B0%8F%E7%99%BD%E9%80%82%E5%90%88%E7%9C%8B%E5%90%97">小林coding图解系统</a>。</p>
<p><a href="https://www.zhihu.com/question/645463314/answer/3571960871">字节一面：TCP 和 UDP 可以使用同一个端口吗？ - 小林coding的回答 - 知乎</a>。<br>
<a href="https://www.zhihu.com/question/645463314/answer/3618363162">字节一面：TCP 和 UDP 可以使用同一个端口吗？ - 车小胖的回答 - 知乎</a>。一些非常刁钻的面试题。答案是可以，有点意外。</p>
<p><a href="https://zhuanlan.zhihu.com/p/19951719175">腾讯面试：那些腾讯面试过的MySQL场景问题 - 王中阳讲编程的文章 - 知乎</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/26153765896">美团C++面经 - 泸沽寻梦的文章 - 知乎</a>。</p>
<p><a href="https://blog.csdn.net/liangzc1124/article/details/145379276">内存泄漏的通用排查方法</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/677307438">天美一面 后台开发（凉） - 牛客面经的文章 - 知乎</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/629336564">C++面试题个人总结（2023-5）</a>。里面有一些听说不准确。</p>
<p><a href="https://zhuanlan.zhihu.com/p/836863961">Linux系统面试题汇总，纯八股文~</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/28707582070">几千HC下的大厂暑期实习锐评（一）</a>。</p>
<hr>
<h1 id="数学算法">数学/算法</h1>
<p><a href="https://www.bilibili.com/video/BV1ys411472E/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">【官方双语/合集】线性代数的本质 - 系列合集</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/147297924">【从入门到放弃】线性回归</a>。</p>
<p><a href="https://www.bilibili.com/list/watchlater?oid=882796110&amp;bvid=BV1AK4y1k7Px&amp;spm_id_from=333.1007.top_right_bar_window_view_later.content.click">《数值分析》| 华科 | 研究生基础课</a>。</p>
<p><a href="http://tutorial.math.lamar.edu/">Paul&rsquo;s Online Math Notes</a>。</p>
<p><a href="https://www.bilibili.com/video/BV18Q4y1d7Kt/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">你还不懂ZIP压缩的原理？一条视频讲清楚ZIP算法中的LZ77编码</a>。<br>
<a href="https://www.bilibili.com/video/BV1c64y1r7Sc/?spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">哈夫曼编码很难懂？一条视频讲清楚</a>。<br>
<a href="https://www.bilibili.com/video/BV17M4y1u7Ek?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">JPEG 有损压缩 离散余弦变换 DCT 一条视频讲清楚</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1zF68YdEJY/?spm_id_from=333.1007.tianma.2-3-6.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">模型分割后处理 加速 极致优化 4 矩阵乘法优化</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/695042849">图解世界上最快的排序算法：Timsort</a>。</p>
<h1 id="底层--四大件">底层 / 四大件</h1>
<p><a href="https://www.cnblogs.com/timlly/p/11471507.html#45-shader%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">深入GPU硬件架构及运行机制</a>。</p>
<p><a href="https://mp.weixin.qq.com/s/FOmUP9YcMORpPxqrz_Ravw">HPC(高性能计算第一篇):一文彻底搞懂并发编程与内存屏障</a>。</p>
<p><a href="https://mp.weixin.qq.com/s/bt2YVej-vXTHPA1Nfi_mHw">基础软件开发新坑 &ndash; 神秘的MESI和坑爹的LockFree（一）</a>。</p>
<p><a href="https://www.bilibili.com/video/BV12T4y1R78D/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">MIT 6.033 Spring 2021: Computer System 计算机系统</a>。</p>
<p>讲得很清晰的计网概述：<a href="https://mp.weixin.qq.com/s?__biz=MzI0MzI1Mjg5Nw==&amp;mid=2247484435&amp;idx=1&amp;sn=6ecaaab82bbd15d6b05ad05754501910&amp;chksm=e96eafddde1926cbab2f18d48f3b17886b91a1f176650216e51a212c9474176ef226905a77f3&amp;token=466537573&amp;lang=zh_CN#rd">详细剖析分布式微服务架构下网络通信的底层实现原理（图解）</a>。</p>
<p><a href="https://space.bilibili.com/12995787/channel/collectiondetail?sid=196337&amp;spm_id_from=333.788.0.0">合集·从零开始自制操作系统</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1px411E7ST/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">【合集】MIT 6.828: Operating System Engineering [Fall 2014] (无字幕)</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1oufmYEET7/?spm_id_from=333.1007.tianma.1-1-1.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">面试必考题：笨叔总结的DMA Cache用法1</a>。</p>
<p><a href="https://www.zhihu.com/question/653863659/answer/3476115054">我想写一个demo级别的编译器，我是该用C语言实现还是用nodejs实现？ - 南山烟雨珠江潮的回答 - 知乎</a>。南山对编译器入门的推荐。</p>
<p><a href="https://zhuanlan.zhihu.com/p/774701158">深入理解Linux的TCP三次握手</a>。<br>
从Linux系统函数角度，讲得比较深。</p>
<p><a href="https://www.zhihu.com/question/8348811114/answer/107394250557">有哪些讲源码的书籍？ - 南山烟雨珠江潮的回答 - 知乎</a>。</p>
<p><a href="https://cloud.tencent.com/developer/article/1848933">一文看懂 | 什么是页缓存（Page Cache）</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/679773351">一文读懂Linux内存管理</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/676385200">一口气搞懂【Linux内存管理】，就靠这60张图、59个问题了</a>。</p>
<hr>
<h1 id="go">Go</h1>
<p>uber出的go的指南<a href="https://github.com/uber-go/guide">guide</a>。</p>
<p><a href="https://books.studygolang.com/gopl-zh/">Go语言圣经（中文版）</a>。</p>
<p><a href="https://github.com/darius-khll/golang-developer-roadmap">Go Developer Roadmap</a>。</p>
<p><a href="https://blog.csdn.net/qq_45467608/article/details/137768942">【Go手写RPC框架】</a>。<br>
<a href="https://www.php.cn/faq/588274.html">如何在go语言中实现高并发的RPC框架</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/381788230">Go 语言中的零拷贝优化</a>。</p>
<p><a href="https://www.zhihu.com/question/369863905/answer/1018940882">有没有推荐的golang的练手项目？ - 极客兔兔的回答 - 知乎</a>。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247487656&amp;idx=1&amp;sn=e6e125db1fa1bad01048f341a4b7165a&amp;scene=21#wechat_redirect">字节跳动 Go RPC 框架 KiteX 性能优化实践</a>。</p>
<p><a href="https://izualzhy.cn/archive.html?tag=leveldb">leveldb的优秀博客</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1Pv411C7dL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">使用Golang实现Tcp反向代理服务器</a>。<br>
<a href="https://www.bilibili.com/video/BV1TD4y1d7s4/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">使用Golang实现内网端口映射</a>。</p>
<p><a href="https://space.bilibili.com/646640992/lists?sid=3820295&amp;spm_id_from=333.788.0.0">合集·大厂Go面经系列</a>。</p>
<p><a href="https://blog.csdn.net/CSDNedu/article/details/143511035">01 | IAM系统概述：我们要实现什么样的 Go 项目？</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/555188132?utm_campaign=shareopn&amp;utm_medium=social&amp;utm_psn=1875375517919744000&amp;utm_source=wechat_session">Go 组件：context 学习笔记</a>。</p>
<p><a href="https://github.com/HDT3213/godis">godis</a>。Go 语言实现的 Redis 服务器和分布式集群。</p>
<p><a href="https://blog.csdn.net/2401_84204413/article/details/145979165">基于Golang所开发的大模型API高性能调度平台</a>。</p>
<p><a href="https://github.com/fogleman/nes">nes</a>，这是一个用Golang编写的NES模拟器。可以看到如何用Golang编写一个模拟器，以及如何用Go模拟CPU和GPU。</p>
<p><a href="https://www.bilibili.com/video/BV1YG41137Vk">面试别再商城项目博客项目啦！双非学员用【分布式AI微服务Golang项目】已经上岸了！</a>。</p>
<h1 id="数据库">数据库</h1>
<p><a href="https://zhuanlan.zhihu.com/p/653179752">面试被经常问的SQL窗口函数！</a></p>
<p><a href="https://juejin.cn/post/7198982002304942138">课程：Redis - 大厂程序员是怎么用的</a>。掘金的字节课。</p>
<p><a href="https://www.cnblogs.com/ccEmma/p/9202107.html">为什么分布式一定要有redis?</a></p>
<p><a href="https://www.bilibili.com/video/BV1Q8NVetERW/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">Go 实战项目 rosedb 源码剖析 1—架构原理</a>。<br>
<a href="https://github.com/rosedblabs/rosedb">rosedb github</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1q2421L7Wd/?spm_id_from=333.1391.0.0&amp;p=2&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">2024年吃透MySQL数据库（MySQL高级优化+索引调优+SQL调优+经典面试题一站式掌握）</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1hQ4y1x7Ym?spm_id_from=333.788.videopod.episodes&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">2024吃透数据库MySQL+Redis缓存+分库分表实战，1000分钟数据库面试高质量教程！</a><br>
一些想看的场景题。</p>
<p><a href="https://blog.csdn.net/zhaoylzy/article/details/144204107">分布式数据库与集中式数据库区别详解！</a></p>
<h1 id="web-通识">web 通识</h1>
<p><a href="https://time.geekbang.org/column/article/398410">25 | 认证机制：应用程序如何进行访问认证？</a>讲得非常好。</p>
<p><a href="https://blog.csdn.net/2401_84240431/article/details/137848638">cookie、localStorage和sessionStorage三者的区别</a>。</p>
<h1 id="微服务--分布式--rpc--流计算--云计算">微服务 / 分布式 / rpc / 流计算 / 云计算</h1>
<p><a href="https://zhuanlan.zhihu.com/p/471626286">5种微服务注册中心如何选型？从原理给你解读！</a></p>
<p><a href="https://blog.csdn.net/weixin_46619605/article/details/142170925">解析消息队列（Kafka版本）</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1jk4y1D7mU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">全B站最好懂的云计算入门课（Azure）</a></p>
<p><a href="https://blog.csdn.net/yy139926/article/details/128468074">分布式 ID 详解 CSDN</a>。
<a href="https://cloud.tencent.com/developer/article/2364487">一文读懂“Snowflake（雪花）”算法 腾讯云</a>。</p>
<p><a href="https://blog.csdn.net/crazymakercircle/article/details/143200817">‘分布式事务‘ 圣经：从入门到精通，架构师尼恩最新、最全详解 (50+图文4万字全面总结 )</a>。</p>
<p><a href="https://www.upyun.com/tech/article/683/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%81%B0%E5%BA%A6%E6%9B%B4%E6%96%B0%E5%AE%9E%E8%B7%B5.html">云原生灰度更新实践</a>。<br>
<a href="https://blog.csdn.net/weixin_39702335/article/details/111797549">k8s灰度更新_k8s实现灰度发布</a>。<br>
未读。</p>
<p><a href="https://www.bilibili.com/video/BV1Vb411m7go">深入浅出讲解 MapReduce</a>。</p>
<p><a href="https://cloud.tencent.com/developer/article/1617967">HDFS原理 | 一文读懂HDFS架构与设计</a>。</p>
<p>分布式系统基础：</p>
<ul>
<li>CAP定理与BASE理论（理解分布式系统设计的核心约束）</li>
<li>共识算法（Raft/Paxos → 实现自己的简易版本）</li>
<li>分布式事务（2PC/TCC/SAGA → 结合具体框架如Seata）</li>
<li>服务发现与负载均衡（ZooKeeper/etcd → 实现服务注册中心）</li>
<li>分布式锁与时钟同步（Redlock算法与NTP协议）</li>
</ul>
<p>云计算核心：</p>
<ul>
<li>虚拟化技术（KVM/QEMU → 尝试手动创建虚拟机）</li>
<li>容器化演进（Docker原理 → 手动构建镜像并分析层级结构）</li>
<li>编排系统（Kubernetes架构 → 重点掌握Pod调度策略）</li>
<li>Serverless范式（冷启动问题与函数计算优化）</li>
<li>云原生生态（Service Mesh/Istio的sidecar模式）</li>
</ul>
<h1 id="架构">架构</h1>
<p><a href="https://blog.csdn.net/weixin_60707895/article/details/121143294">性能追击：30+图详解8大主流服务器程序线程模型展示</a>。</p>
<p><a href="https://www.infoq.cn/article/l1KUimTRzb8wZ0ffNNoG?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search">字节跳动开源 Go HTTP 框架 Hertz 设计实践</a>。</p>
<p><a href="https://www.zhihu.com/zvideo/1415721944793124864?utm_id=0">大厂面试系统设计题：如何设计一个红包雨系统？</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1445567">从0到10亿，微信后台架构及基础设施设计与实践！</a></p>
<hr>
<h1 id="ta--引擎--游戏">TA / 引擎 / 游戏</h1>
<p><a href="https://zhuanlan.zhihu.com/p/436920189">转行技术美术（TA）的分享</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/261861130">TA技术美术（偏T)学习规划</a>。</p>
<p><a href="https://www.zhihu.com/question/640467378/answer/3382207520">我是一名前端，部门想让我转webgl方向，要不要考虑一下？ - Jhohkkk的回答 - 知乎</a> &ndash; 图程路线。</p>
<p><a href="https://zhuanlan.zhihu.com/p/711481617">光线追踪无痛入门</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/129372723">Ray Tracing: The Next Week V3.0中文翻译（上）</a>。<br>
<a href="https://zhuanlan.zhihu.com/p/129745508">Ray Tracing: The Next Week V3.0中文翻译（下）</a>。</p>
<p><a href="https://www.nowcoder.com/discuss/590687392735014912">游戏研发秋招 经验信息分享帖</a>。</p>
<p><a href="https://www.audiokinetic.com/zh/">audiokinetic</a>。音频开发。</p>
<p><a href="https://zhuanlan.zhihu.com/p/410710318">在shader中实现五种描边方法</a>。</p>
<p><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/mesh-drawing-pipeline-in-unreal-engine">unreal engine Mesh Drawing Pipeline</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/711437664">游戏制作的窄门：构建mini游戏引擎 - 1 - Third Party Libs</a>。<br>
音频库<a href="https://codyclaborn.me/tutorials/setting-up-xcode-and-visual-studio-for-fmod-development/">FMOD</a>。<br>
<a href="https://www.fmod.com/download#fmodengine">FMOD</a>。远不仅是音频库，还有引擎内核的。</p>
<p><a href="https://zhuanlan.zhihu.com/p/637308167">花了一年半时间写的玩具离线渲染器，用来学习并实现各种渲染算法</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1ys4y167Cb?spm_id_from=333.788.videopod.sections&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">【搬运】Hazel 3D游戏引擎开发教程#001</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1avCsYMEsS/?spm_id_from=333.1007.tianma.2-2-5.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">用C++打造超强物理引擎 - 模拟机械运动</a>。</p>
<p>导出 3D 刚体物理并用 C/C++ 实现：<a href="https://www.youtube.com/watch?v=4r_EvmPKOvY">Deriving 3D Rigid Body Physics and implementing it in C/C++ (with intuitions)</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/16489499289">数字孪生常见特效Shader实现4 直线 PolyLine</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/96089089">游戏引擎开发新感觉！(6) c++17内存管理</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/648804908">OpenGL 面试题 - Leslie的文章 - 知乎</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/39707078">《游戏设计模式》(游戏编程模式)全书笔记+Unity实现</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/398852950">Unreal从0到1专栏概述</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/25796897059">对UE5神经网络引擎的一些理解和看法</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/492678365">【游戏开发】动画技术文章合集</a>。</p>
<p>图形学：
入门：GAMES-101 
实时渲染：GAMES-202、GAMES-104、RTR4(<a href="https://github.com/Morakito/Real-Time-Rendering-4th-CN">https://github.com/Morakito/Real-Time-Rendering-4th-CN</a>)
离线渲染：
简单的软光追：Ray Tracing in One Weekend三部曲(<a href="https://raytracing.github.io">https://raytracing.github.io</a>)
进阶：PBRT-V4 (<a href="https://pbr-book.org/4ed/contents">https://pbr-book.org/4ed/contents</a>)
图形API：
OpenGL：https://learnopengl-cn.github.io
Vulkan：渐进式教程：https://vulkan-tutorial.com
      Example：https://github.com/SaschaWillems/Vulkan
      将Vulkan封装成RHI，写出小引擎：https://github.com/BoomingTech/Piccolo
引擎原理:
GAMES-104, 课程附带的 Piccolo源码值得一读 (<a href="https://github.com/BoomingTech/Piccolo">https://github.com/BoomingTech/Piccolo</a>)
Godot (<a href="https://github.com/godotengine/godot">https://github.com/godotengine/godot</a>)
以及虚幻5源码</p>
<p>引擎使用:
Unity：https://catlikecoding.com/unity/tutorials/</p>
<p>编程:
C#：《C#图解教程》
Shader：《Unity Shader 入门精要》
C++：《C++ Primer》《Effective Modern C++》《深度探索C++对象模型》《C++并发编程实战》
Lua：《Lua程序设计》
以及设计模式
其他:
GDC
SIGGRAPH</p>
<!-- 
作者：AE酱
链接：https://www.nowcoder.com/?
来源：牛客网 -->
<p>Unity开发，手机sdk接入<br>
<a href="https://zhuanlan.zhihu.com/p/720705077">搞懂Unity在Android上C#，Java，C++的互通</a>。</p>
<hr>
<h1 id="ai--机器学习">AI / 机器学习</h1>
<p><a href="https://www.bilibili.com/video/BV1R1xWeSEUR?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">B站最全智能优化算法课程，模拟退火算法，粒子群算法，遗传算法等16种优化算法_机器学习_深度学习_人工智能</a>。</p>
<hr>
<h1 id="python">Python</h1>
<p><a href="https://zhuanlan.zhihu.com/p/673578424">一个标星144.4k⭐Python项目 100 天从新手到大师 :Python-100-Days</a>。<br>
<a href="https://github.com/jackfrued/Python-100-Days">Python-100-Days</a>。</p>
<p><a href="https://www.bilibili.com/video/BV1RDfpYVEcX/?spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">通过一个项目全面了解FastAPI（绝无废话！）</a></p>
<p><a href="https://www.bilibili.com/video/BV1ZxQ2YAERj">13分钟解释每个Python库/模块 ｜ Python 常用库</a>。</p>
<hr>
<h1 id="其他">其他</h1>
<!-- 一些要补的东西：设计模式、互联网各种架构、分布式、云计算。 -->
<p><a href="https://blog.csdn.net/oOBubbleX/article/details/140127181">【大数据】什么是数据融合（Data Fusion)?</a></p>
<p><a href="https://www.bilibili.com/video/BV1Nb421p7ov/?trackid=web_pegasus_7.router-web-pegasus-1901290-6fffd7554f-wzxmd.1737806345154.451&amp;track_id=pbaes.zI5yT6S9ARdssOJatHoNZM9QXe5HTP9ttPkZjoy7mJpDOxzpoiEH-lCRLgYg2xUK3UnJ3UqCdFOFvGj-JwHiPv5tJDO0AUHdVB-rcuHU_bmsfbsknR3R_9gioyEg--PjL7s3YisvN1rpI-Dpvvee0DsaDipQiYGQ6svyDtl4DI38_PZjZDxLUtSBGyDzlDQt&amp;caid=__CAID__&amp;resource_id=__RESOURCEID__&amp;source_id=5614&amp;request_id=1737806345205q172a27a45a218q6281&amp;from_spmid=__FROMSPMID__&amp;creative_id=205962179&amp;linked_creative_id=205962179&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">【情报修考】形式语言与自动机 基础知识</a>。</p>
<p>java <a href="https://www.bilibili.com/video/BV16P411L7Er/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">手写一个WEB应用服务，彻底搞懂Tomcat</a>。</p>
<h3 id="训练营证书比赛gamejam实习">训练营、证书、比赛、GameJam、实习</h3>
<p>PAT考试<br>
OSPP开源之夏<br>
字节青训营<br>
七牛云1024创作节<br>
code forces<br>
GitLink“确实开源”编程夏令营(GLCC)</p>
]]></content></item><item><title/><link>https://jekyulll.github.io/posts/cpp-%E4%BA%8B%E5%8A%A1%E6%80%A7%E5%86%85%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E4%BA%8B%E5%8A%A1%E6%80%A7%E5%86%85%E5%AD%98/</guid><description>&lt;!-- +++
date = '2025-03-10T12:05:47+08:00'
draft = false
title = '【AI】使用普通的互斥锁实现读写锁'
author = 'JekYUlll'
lastmod = '2025-03-10T12:05:47+08:00'
tags = ['cpp','algorithm']
categories = ['cpp']
+++ -->
&lt;p>// TODO&lt;/p></description><content type="html">&lt;!-- +++
date = '2025-03-10T12:05:47+08:00'
draft = false
title = '【AI】使用普通的互斥锁实现读写锁'
author = 'JekYUlll'
lastmod = '2025-03-10T12:05:47+08:00'
tags = ['cpp','algorithm']
categories = ['cpp']
+++ -->
&lt;p>// TODO&lt;/p>
</content></item></channel></rss>