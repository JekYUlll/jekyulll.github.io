<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="JekYUlll"><meta name=description content="
这两个月学习了一下OpenGL。从Cherno的教学视频开始学习，看完后开始看LearnOpenGL，应该是很常见的学习路径。
在此以新手视角，记录一下学习中在工程方面遇到的一些坑（数学和底层方面就不打算开口丢人了）。
Cherno主页 | LearnOpenGL
1. 直接选择 64 位 Cherno视频是2017及之前的，为了兼容性，教程里32位。而LearnOpenGL写到后面是64位，还要用Assimp库，默认是编译成64位。建议直接x64，像我这样闷头跟着写的话要把 GLEW 和 GLFW 的静态库全换一遍，或者去折腾CMake。
2. GLEW, GLAD, GLFW 这三个比较常用。两个教程的选择都是 GLEW + GLFW，其中 GLEW 和 GLAD 定位相似，都是用于访问OpenGL函数。可以先看看自己喜欢哪一个，免得后面想换再费功夫。
3. Texture 的实现 &ndash; 小心析构函数 LearnOpenGL中的Texture只是一个存储数据的结构体：
struct Texture { GLuint id; string type; aiString path; }; 而Cherno将Texture创建为类，构造函数中直接完成加载图片的操作，并且在析构函数里调用glDeleteTextures。
如果无脑缝代码就完蛋了，因为LearnOpenGL在Model::loadMaterialTextures函数中创建了Texture的临时对象并返回，会调用析构函数：
vector<Texture> loadMaterialTextures(aiMaterial* mat, aiTextureType type, string typeName) { vector<Texture> textures; // ... return textures; } 可以选择：
修改Texture类的实现（比如把）glDeleteTextures单独调用； 修改Model类中加载纹理的实现，例如传入Texture的引用； 使用指针。我选择了使用智能指针（相对应的地方全要改）： // 顺便把参数改成 `aiTextureType`(Assimp定义的用于表示Texture不同类型的枚举) // 优化掉LearnOpenGL里那个丑陋的字符串处理 std::vector<std::shared_ptr<Texture>> Model::loadMaterialTextures(aiMaterial* mat, aiTextureType type) { std::vector<std::shared_ptr<Texture>> textures; for (GLuint i = 0; i < mat->GetTextureCount(type); i++) { aiString str; mat->GetTexture(type, i, &amp;str); bool canSkip = false; for (int j = 0; j < this->textures_loaded.size(); j++) { if (textures_loaded[j]->path == str) { textures.push_back(textures_loaded[j]); canSkip = true; break; } } if (!canSkip) { std::string filename = std::string(str.C_Str()); filename = directory + '/' + filename; std::shared_ptr<Texture> texture = std::make_shared<Texture>(filename); // 教程里此处调用了TextureFromFile()来初始化texture，但可以用Texture的构造函数 texture->type = type; texture->path = str; textures.push_back(texture); this->textures_loaded.push_back(texture); } } return textures; } 同理，小心其他类里的析构函数（例如Shader类可能会在析构里调用glDeleteProgram）。
"><meta name=keywords content="homepage,blog,opengl,graphics,game"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://jekyulll.github.io/post/opengl-%E8%8F%9C--opengl-%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0----cherno-+-learnopengl/><title>OpenGL 初学笔记 -- Cherno + LearnOpenGL :: Hello Friend NG — A simple theme for Hugo
</title><link rel=stylesheet href=/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css integrity="sha256-JEGDzeGjjgsI+CwReRGBKI+arBzJYYzW9OnncQxXaLo=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="OpenGL 初学笔记 -- Cherno + LearnOpenGL"><meta itemprop=description content="这两个月学习了一下OpenGL。从Cherno的教学视频开始学习，看完后开始看LearnOpenGL，应该是很常见的学习路径。
在此以新手视角，记录一下学习中在工程方面遇到的一些坑（数学和底层方面就不打算开口丢人了）。
Cherno主页 | LearnOpenGL
1. 直接选择 64 位 Cherno视频是2017及之前的，为了兼容性，教程里32位。而LearnOpenGL写到后面是64位，还要用Assimp库，默认是编译成64位。建议直接x64，像我这样闷头跟着写的话要把 GLEW 和 GLFW 的静态库全换一遍，或者去折腾CMake。
2. GLEW, GLAD, GLFW 这三个比较常用。两个教程的选择都是 GLEW + GLFW，其中 GLEW 和 GLAD 定位相似，都是用于访问OpenGL函数。可以先看看自己喜欢哪一个，免得后面想换再费功夫。
3. Texture 的实现 – 小心析构函数 LearnOpenGL中的Texture只是一个存储数据的结构体：
struct Texture { GLuint id; string type; aiString path; }; 而Cherno将Texture创建为类，构造函数中直接完成加载图片的操作，并且在析构函数里调用glDeleteTextures。
如果无脑缝代码就完蛋了，因为LearnOpenGL在Model::loadMaterialTextures函数中创建了Texture的临时对象并返回，会调用析构函数：
vector<Texture> loadMaterialTextures(aiMaterial* mat, aiTextureType type, string typeName) { vector<Texture> textures; // ... return textures; } 可以选择：
修改Texture类的实现（比如把）glDeleteTextures单独调用； 修改Model类中加载纹理的实现，例如传入Texture的引用； 使用指针。我选择了使用智能指针（相对应的地方全要改）： // 顺便把参数改成 `aiTextureType`(Assimp定义的用于表示Texture不同类型的枚举) // 优化掉LearnOpenGL里那个丑陋的字符串处理 std::vector<std::shared_ptr<Texture>> Model::loadMaterialTextures(aiMaterial* mat, aiTextureType type) { std::vector<std::shared_ptr<Texture>> textures; for (GLuint i = 0; i < mat->GetTextureCount(type); i++) { aiString str; mat->GetTexture(type, i, &amp;str); bool canSkip = false; for (int j = 0; j < this->textures_loaded.size(); j++) { if (textures_loaded[j]->path == str) { textures.push_back(textures_loaded[j]); canSkip = true; break; } } if (!canSkip) { std::string filename = std::string(str.C_Str()); filename = directory + '/' + filename; std::shared_ptr<Texture> texture = std::make_shared<Texture>(filename); // 教程里此处调用了TextureFromFile()来初始化texture，但可以用Texture的构造函数 texture->type = type; texture->path = str; textures.push_back(texture); this->textures_loaded.push_back(texture); } } return textures; } 同理，小心其他类里的析构函数（例如Shader类可能会在析构里调用glDeleteProgram）。"><meta itemprop=datePublished content="2024-07-29T21:05:47+08:00"><meta itemprop=dateModified content="2024-12-22T21:05:47+08:00"><meta itemprop=wordCount content="151"><meta itemprop=image content="https://jekyulll.github.io/"><meta itemprop=keywords content="Opengl,Graphics,Game"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jekyulll.github.io/"><meta name=twitter:title content="OpenGL 初学笔记 -- Cherno + LearnOpenGL"><meta name=twitter:description content="这两个月学习了一下OpenGL。从Cherno的教学视频开始学习，看完后开始看LearnOpenGL，应该是很常见的学习路径。
在此以新手视角，记录一下学习中在工程方面遇到的一些坑（数学和底层方面就不打算开口丢人了）。
Cherno主页 | LearnOpenGL
1. 直接选择 64 位 Cherno视频是2017及之前的，为了兼容性，教程里32位。而LearnOpenGL写到后面是64位，还要用Assimp库，默认是编译成64位。建议直接x64，像我这样闷头跟着写的话要把 GLEW 和 GLFW 的静态库全换一遍，或者去折腾CMake。
2. GLEW, GLAD, GLFW 这三个比较常用。两个教程的选择都是 GLEW + GLFW，其中 GLEW 和 GLAD 定位相似，都是用于访问OpenGL函数。可以先看看自己喜欢哪一个，免得后面想换再费功夫。
3. Texture 的实现 – 小心析构函数 LearnOpenGL中的Texture只是一个存储数据的结构体：
struct Texture { GLuint id; string type; aiString path; }; 而Cherno将Texture创建为类，构造函数中直接完成加载图片的操作，并且在析构函数里调用glDeleteTextures。
如果无脑缝代码就完蛋了，因为LearnOpenGL在Model::loadMaterialTextures函数中创建了Texture的临时对象并返回，会调用析构函数：
vector<Texture> loadMaterialTextures(aiMaterial* mat, aiTextureType type, string typeName) { vector<Texture> textures; // ... return textures; } 可以选择：
修改Texture类的实现（比如把）glDeleteTextures单独调用； 修改Model类中加载纹理的实现，例如传入Texture的引用； 使用指针。我选择了使用智能指针（相对应的地方全要改）： // 顺便把参数改成 `aiTextureType`(Assimp定义的用于表示Texture不同类型的枚举) // 优化掉LearnOpenGL里那个丑陋的字符串处理 std::vector<std::shared_ptr<Texture>> Model::loadMaterialTextures(aiMaterial* mat, aiTextureType type) { std::vector<std::shared_ptr<Texture>> textures; for (GLuint i = 0; i < mat->GetTextureCount(type); i++) { aiString str; mat->GetTexture(type, i, &amp;str); bool canSkip = false; for (int j = 0; j < this->textures_loaded.size(); j++) { if (textures_loaded[j]->path == str) { textures.push_back(textures_loaded[j]); canSkip = true; break; } } if (!canSkip) { std::string filename = std::string(str.C_Str()); filename = directory + '/' + filename; std::shared_ptr<Texture> texture = std::make_shared<Texture>(filename); // 教程里此处调用了TextureFromFile()来初始化texture，但可以用Texture的构造函数 texture->type = type; texture->path = str; textures.push_back(texture); this->textures_loaded.push_back(texture); } } return textures; } 同理，小心其他类里的析构函数（例如Shader类可能会在析构里调用glDeleteProgram）。"><meta property="og:url" content="https://jekyulll.github.io/post/opengl-%E8%8F%9C--opengl-%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0----cherno-+-learnopengl/"><meta property="og:site_name" content="Hello Friend NG"><meta property="og:title" content="OpenGL 初学笔记 -- Cherno + LearnOpenGL"><meta property="og:description" content="这两个月学习了一下OpenGL。从Cherno的教学视频开始学习，看完后开始看LearnOpenGL，应该是很常见的学习路径。
在此以新手视角，记录一下学习中在工程方面遇到的一些坑（数学和底层方面就不打算开口丢人了）。
Cherno主页 | LearnOpenGL
1. 直接选择 64 位 Cherno视频是2017及之前的，为了兼容性，教程里32位。而LearnOpenGL写到后面是64位，还要用Assimp库，默认是编译成64位。建议直接x64，像我这样闷头跟着写的话要把 GLEW 和 GLFW 的静态库全换一遍，或者去折腾CMake。
2. GLEW, GLAD, GLFW 这三个比较常用。两个教程的选择都是 GLEW + GLFW，其中 GLEW 和 GLAD 定位相似，都是用于访问OpenGL函数。可以先看看自己喜欢哪一个，免得后面想换再费功夫。
3. Texture 的实现 – 小心析构函数 LearnOpenGL中的Texture只是一个存储数据的结构体：
struct Texture { GLuint id; string type; aiString path; }; 而Cherno将Texture创建为类，构造函数中直接完成加载图片的操作，并且在析构函数里调用glDeleteTextures。
如果无脑缝代码就完蛋了，因为LearnOpenGL在Model::loadMaterialTextures函数中创建了Texture的临时对象并返回，会调用析构函数：
vector<Texture> loadMaterialTextures(aiMaterial* mat, aiTextureType type, string typeName) { vector<Texture> textures; // ... return textures; } 可以选择：
修改Texture类的实现（比如把）glDeleteTextures单独调用； 修改Model类中加载纹理的实现，例如传入Texture的引用； 使用指针。我选择了使用智能指针（相对应的地方全要改）： // 顺便把参数改成 `aiTextureType`(Assimp定义的用于表示Texture不同类型的枚举) // 优化掉LearnOpenGL里那个丑陋的字符串处理 std::vector<std::shared_ptr<Texture>> Model::loadMaterialTextures(aiMaterial* mat, aiTextureType type) { std::vector<std::shared_ptr<Texture>> textures; for (GLuint i = 0; i < mat->GetTextureCount(type); i++) { aiString str; mat->GetTexture(type, i, &amp;str); bool canSkip = false; for (int j = 0; j < this->textures_loaded.size(); j++) { if (textures_loaded[j]->path == str) { textures.push_back(textures_loaded[j]); canSkip = true; break; } } if (!canSkip) { std::string filename = std::string(str.C_Str()); filename = directory + '/' + filename; std::shared_ptr<Texture> texture = std::make_shared<Texture>(filename); // 教程里此处调用了TextureFromFile()来初始化texture，但可以用Texture的构造函数 texture->type = type; texture->path = str; textures.push_back(texture); this->textures_loaded.push_back(texture); } } return textures; } 同理，小心其他类里的析构函数（例如Shader类可能会在析构里调用glDeleteProgram）。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-07-29T21:05:47+08:00"><meta property="article:modified_time" content="2024-12-22T21:05:47+08:00"><meta property="article:tag" content="Opengl"><meta property="article:tag" content="Graphics"><meta property="article:tag" content="Game"><meta property="og:image" content="https://jekyulll.github.io/"><meta property="article:section" content="game"><meta property="article:published_time" content="2024-07-29 21:05:47 +0800 +0800"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello friend ng</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>Blog</a></li><ul class=submenu><li class=dropdown><a href=javascript:void(0) class=dropbtn>en</a><div class=dropdown-content></div></li></ul></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://jekyulll.github.io/post/opengl-%E8%8F%9C--opengl-%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0----cherno-+-learnopengl/>OpenGL 初学笔记 &ndash; Cherno + LearnOpenGL</a></h2><div class=post-content><p><img src=/images/ayanami_header.jpg alt=hearder></p><p>这两个月学习了一下OpenGL。从Cherno的教学视频开始学习，看完后开始看LearnOpenGL，应该是很常见的学习路径。<br>在此以新手视角，记录一下学习中在工程方面遇到的一些坑（数学和底层方面就不打算开口丢人了）。</p><p><a href=https://www.youtube.com/@TheCherno>Cherno主页</a> | <a href=https://learnopengl.com/>LearnOpenGL</a></p><hr><h2 id=1-直接选择-64-位><strong>1.</strong> 直接选择 64 位</h2><p>Cherno视频是2017及之前的，为了兼容性，教程里32位。而LearnOpenGL写到后面是64位，还要用Assimp库，默认是编译成64位。建议直接x64，像我这样闷头跟着写的话要把 GLEW 和 GLFW 的静态库全换一遍，或者去折腾CMake。</p><hr><h2 id=2-glew-glad-glfw><strong>2.</strong> GLEW, GLAD, GLFW</h2><p>这三个比较常用。两个教程的选择都是 GLEW + GLFW，其中 GLEW 和 GLAD 定位相似，都是用于访问OpenGL函数。可以先看看自己喜欢哪一个，免得后面想换再费功夫。</p><hr><h2 id=3-texture-的实现----小心析构函数><strong>3.</strong> <code>Texture</code> 的实现 &ndash; 小心析构函数</h2><p>LearnOpenGL中的<code>Texture</code>只是一个存储数据的结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Texture</span> {
</span></span><span style=display:flex><span>    GLuint id;
</span></span><span style=display:flex><span>    string type;
</span></span><span style=display:flex><span>    aiString path;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>而Cherno将<code>Texture</code>创建为类，构造函数中直接完成加载图片的操作，并且在析构函数里调用<code>glDeleteTextures</code>。<br>如果无脑缝代码就完蛋了，因为LearnOpenGL在<code>Model::loadMaterialTextures</code>函数中创建了<code>Texture</code>的临时对象并返回，会调用析构函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>Texture<span style=color:#f92672>&gt;</span> loadMaterialTextures(aiMaterial<span style=color:#f92672>*</span> mat, aiTextureType type, string typeName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>Texture<span style=color:#f92672>&gt;</span> textures;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> textures;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以选择：</p><ol><li>修改Texture类的实现（比如把）glDeleteTextures单独调用；</li><li>修改Model类中加载纹理的实现，例如传入Texture的引用；</li><li>使用指针。我选择了使用智能指针（相对应的地方全要改）：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 顺便把参数改成 `aiTextureType`(Assimp定义的用于表示Texture不同类型的枚举)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 优化掉LearnOpenGL里那个丑陋的字符串处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Texture<span style=color:#f92672>&gt;&gt;</span> Model<span style=color:#f92672>::</span>loadMaterialTextures(aiMaterial<span style=color:#f92672>*</span> mat, aiTextureType type)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Texture<span style=color:#f92672>&gt;&gt;</span> textures;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (GLuint i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> mat<span style=color:#f92672>-&gt;</span>GetTextureCount(type); i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        aiString str;
</span></span><span style=display:flex><span>        mat<span style=color:#f92672>-&gt;</span>GetTexture(type, i, <span style=color:#f92672>&amp;</span>str);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> canSkip <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>textures_loaded.size(); j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (textures_loaded[j]<span style=color:#f92672>-&gt;</span>path <span style=color:#f92672>==</span> str)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                textures.push_back(textures_loaded[j]);
</span></span><span style=display:flex><span>                canSkip <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>canSkip)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>string filename <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>string(str.C_Str());
</span></span><span style=display:flex><span>            filename <span style=color:#f92672>=</span> directory <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;/&#39;</span> <span style=color:#f92672>+</span> filename;
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Texture<span style=color:#f92672>&gt;</span> texture <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>Texture<span style=color:#f92672>&gt;</span>(filename); <span style=color:#75715e>// 教程里此处调用了TextureFromFile()来初始化texture，但可以用Texture的构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            texture<span style=color:#f92672>-&gt;</span>type <span style=color:#f92672>=</span> type;   
</span></span><span style=display:flex><span>            texture<span style=color:#f92672>-&gt;</span>path <span style=color:#f92672>=</span> str;
</span></span><span style=display:flex><span>            textures.push_back(texture);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>textures_loaded.push_back(texture);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> textures;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>同理，小心其他类里的析构函数（例如Shader类可能会在析构里调用glDeleteProgram）。</p></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://jekyulll.github.io/tags/opengl/>opengl</a></span>
<span class=tag><a href=https://jekyulll.github.io/tags/graphics/>graphics</a></span>
<span class=tag><a href=https://jekyulll.github.io/tags/game/>game</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://jekyulll.github.io/categories/game/>game</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>