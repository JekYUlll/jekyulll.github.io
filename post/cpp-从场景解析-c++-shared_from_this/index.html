<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="JekYUlll"><meta name=description content=' 智能指针之shared_ptr易错点05。
掌握C++ 智能指针的自我引用：深入解析 shared_from_this 和 weak_from_this。
C++之shared_from_this用法以及类自引用this指针陷阱。
思考：
设计一个树的节点的时候，如果使用智能指针：用一个std::vector<shared_ptr<TreeNode>>来存储子节点，为避免循环引用，用weak_ptr<TreeNode>来存储自身的父节点指针。
那添加子节点的时候，怎么把自身的shared_ptr赋值给子节点存储的父节点指针呢？
两个错误做法： 使用std::make_shared<TreeNode<T>>(*this)来创建一个新的shared_ptr，然后赋值给子节点存储的父节点指针。 void addChild(std::shared_ptr<TreeNode<T>> child) { // 使用 make_shared 来创建子节点并设置父节点 child->setParent(std::make_shared<TreeNode<T>>(*this)); // 错误的做法 children.push_back(child); } 使用 std::make_shared<TreeNode<T>>(*this) 时，实际上是对当前对象的 拷贝构造（调用拷贝构造函数）来创建一个新的 TreeNode<T> 对象。这意味着你将当前节点的状态（但不是智能指针）拷贝到一个新的对象中，而新对象的生命周期由 std::shared_ptr 管理。
使用 std::shared_ptr<TreeNode<T>> ptr(this) 把裸指针 this 包装为 shared_ptr。 将 this 传递给 std::shared_ptr<TreeNode<T>> 会导致新创建的 shared_ptr 管理一个裸指针，而裸指针的生命周期没有由智能指针控制。
引出一个常规问题，从裸指针创建 shared_ptr 的隐患：
当 shared_ptr 的引用计数归零时，它会释放它所管理的对象。如果裸指针在此时继续存在，它仍然会指向原来的内存地址。但这时该内存已被释放，裸指针成为了悬空指针，也就是所谓的野指针。 如果裸指针指向的内存已经被释放（例如，该指针原本由 delete 或 delete[] 释放），然后你用这个裸指针创建 shared_ptr，那么 shared_ptr 仍然会管理这个已经释放的内存区域。这会导致访问已释放内存（悬空指针）或双重释放内存的问题（如果 shared_ptr 销毁时再次释放内存）。 裸指针可能指向一个栈上的对象：如果裸指针指向一个栈上分配的对象，并且你用它创建 shared_ptr，那么 shared_ptr 会试图在引用计数归零时释放这个栈上对象的内存。然而，栈上对象的生命周期由栈帧的销毁来管理，而 shared_ptr 并不清楚这一点。这将导致程序的未定义行为。 案例：
class TestB { public: TestB(){ cout << "TestB create" << endl; } ~TestB(){ cout << "TestB destory" << endl; } shared_ptr<TestB> getSharedFromThis() { return shared_ptr<TestB> (this); } }; int main(){ { shared_ptr<TestB> ptr3(new TestB()); shared_ptr<TestB> ptr4 = ptr3->getSharedFromThis(); cout << "ptr2 count: " << ptr3.use_count() << " ptr4 count: " << ptr4.use_count() << endl; //输出：ptr2 count: 1 ptr4 count: 1 然后会崩溃因为重复释放 } cin.get(); return 0; } 如何会导致shared_ptr指向同一个对象，但是不共享引用计数器？
是因为裸指针与shared_ptr混用，如果我们用一个裸指针初始化或者赋值给shared_ptr指针时，在shared_ptr内部生成一个计数器，当另外一个shared_ptr不用share_ptr赋值或者初始化的话，再次将一个裸指针赋值给另外一个shared_ptr时，又一次生成一个计数器，两个计数器不共享。
'><meta name=keywords content="homepage,blog,cpp"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://jekyulll.github.io/post/cpp-%E4%BB%8E%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90-c++-shared_from_this/><title>从场景解析 C++ shared_from_this :: Hello Friend NG — A simple theme for Hugo
</title><link rel=stylesheet href=/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css integrity="sha256-JEGDzeGjjgsI+CwReRGBKI+arBzJYYzW9OnncQxXaLo=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="从场景解析 C++ shared_from_this"><meta itemprop=description content='智能指针之shared_ptr易错点05。
掌握C++ 智能指针的自我引用：深入解析 shared_from_this 和 weak_from_this。
C++之shared_from_this用法以及类自引用this指针陷阱。
思考：
设计一个树的节点的时候，如果使用智能指针：用一个std::vector<shared_ptr<TreeNode>>来存储子节点，为避免循环引用，用weak_ptr<TreeNode>来存储自身的父节点指针。
那添加子节点的时候，怎么把自身的shared_ptr赋值给子节点存储的父节点指针呢？
两个错误做法： 使用std::make_shared<TreeNode<T>>(*this)来创建一个新的shared_ptr，然后赋值给子节点存储的父节点指针。 void addChild(std::shared_ptr<TreeNode<T>> child) { // 使用 make_shared 来创建子节点并设置父节点 child->setParent(std::make_shared<TreeNode<T>>(*this)); // 错误的做法 children.push_back(child); } 使用 std::make_shared<TreeNode<T>>(*this) 时，实际上是对当前对象的 拷贝构造（调用拷贝构造函数）来创建一个新的 TreeNode<T> 对象。这意味着你将当前节点的状态（但不是智能指针）拷贝到一个新的对象中，而新对象的生命周期由 std::shared_ptr 管理。
使用 std::shared_ptr<TreeNode<T>> ptr(this) 把裸指针 this 包装为 shared_ptr。 将 this 传递给 std::shared_ptr<TreeNode<T>> 会导致新创建的 shared_ptr 管理一个裸指针，而裸指针的生命周期没有由智能指针控制。
引出一个常规问题，从裸指针创建 shared_ptr 的隐患：
当 shared_ptr 的引用计数归零时，它会释放它所管理的对象。如果裸指针在此时继续存在，它仍然会指向原来的内存地址。但这时该内存已被释放，裸指针成为了悬空指针，也就是所谓的野指针。 如果裸指针指向的内存已经被释放（例如，该指针原本由 delete 或 delete[] 释放），然后你用这个裸指针创建 shared_ptr，那么 shared_ptr 仍然会管理这个已经释放的内存区域。这会导致访问已释放内存（悬空指针）或双重释放内存的问题（如果 shared_ptr 销毁时再次释放内存）。 裸指针可能指向一个栈上的对象：如果裸指针指向一个栈上分配的对象，并且你用它创建 shared_ptr，那么 shared_ptr 会试图在引用计数归零时释放这个栈上对象的内存。然而，栈上对象的生命周期由栈帧的销毁来管理，而 shared_ptr 并不清楚这一点。这将导致程序的未定义行为。 案例：
class TestB { public: TestB(){ cout << "TestB create" << endl; } ~TestB(){ cout << "TestB destory" << endl; } shared_ptr<TestB> getSharedFromThis() { return shared_ptr<TestB> (this); } }; int main(){ { shared_ptr<TestB> ptr3(new TestB()); shared_ptr<TestB> ptr4 = ptr3->getSharedFromThis(); cout << "ptr2 count: " << ptr3.use_count() << " ptr4 count: " << ptr4.use_count() << endl; //输出：ptr2 count: 1 ptr4 count: 1 然后会崩溃因为重复释放 } cin.get(); return 0; } 如何会导致shared_ptr指向同一个对象，但是不共享引用计数器？
是因为裸指针与shared_ptr混用，如果我们用一个裸指针初始化或者赋值给shared_ptr指针时，在shared_ptr内部生成一个计数器，当另外一个shared_ptr不用share_ptr赋值或者初始化的话，再次将一个裸指针赋值给另外一个shared_ptr时，又一次生成一个计数器，两个计数器不共享。'><meta itemprop=datePublished content="2025-01-09T20:05:47+08:00"><meta itemprop=dateModified content="2025-01-09T20:05:47+08:00"><meta itemprop=wordCount content="316"><meta itemprop=image content="https://jekyulll.github.io/"><meta itemprop=keywords content="Cpp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jekyulll.github.io/"><meta name=twitter:title content="从场景解析 C++ shared_from_this"><meta name=twitter:description content='智能指针之shared_ptr易错点05。
掌握C++ 智能指针的自我引用：深入解析 shared_from_this 和 weak_from_this。
C++之shared_from_this用法以及类自引用this指针陷阱。
思考：
设计一个树的节点的时候，如果使用智能指针：用一个std::vector<shared_ptr<TreeNode>>来存储子节点，为避免循环引用，用weak_ptr<TreeNode>来存储自身的父节点指针。
那添加子节点的时候，怎么把自身的shared_ptr赋值给子节点存储的父节点指针呢？
两个错误做法： 使用std::make_shared<TreeNode<T>>(*this)来创建一个新的shared_ptr，然后赋值给子节点存储的父节点指针。 void addChild(std::shared_ptr<TreeNode<T>> child) { // 使用 make_shared 来创建子节点并设置父节点 child->setParent(std::make_shared<TreeNode<T>>(*this)); // 错误的做法 children.push_back(child); } 使用 std::make_shared<TreeNode<T>>(*this) 时，实际上是对当前对象的 拷贝构造（调用拷贝构造函数）来创建一个新的 TreeNode<T> 对象。这意味着你将当前节点的状态（但不是智能指针）拷贝到一个新的对象中，而新对象的生命周期由 std::shared_ptr 管理。
使用 std::shared_ptr<TreeNode<T>> ptr(this) 把裸指针 this 包装为 shared_ptr。 将 this 传递给 std::shared_ptr<TreeNode<T>> 会导致新创建的 shared_ptr 管理一个裸指针，而裸指针的生命周期没有由智能指针控制。
引出一个常规问题，从裸指针创建 shared_ptr 的隐患：
当 shared_ptr 的引用计数归零时，它会释放它所管理的对象。如果裸指针在此时继续存在，它仍然会指向原来的内存地址。但这时该内存已被释放，裸指针成为了悬空指针，也就是所谓的野指针。 如果裸指针指向的内存已经被释放（例如，该指针原本由 delete 或 delete[] 释放），然后你用这个裸指针创建 shared_ptr，那么 shared_ptr 仍然会管理这个已经释放的内存区域。这会导致访问已释放内存（悬空指针）或双重释放内存的问题（如果 shared_ptr 销毁时再次释放内存）。 裸指针可能指向一个栈上的对象：如果裸指针指向一个栈上分配的对象，并且你用它创建 shared_ptr，那么 shared_ptr 会试图在引用计数归零时释放这个栈上对象的内存。然而，栈上对象的生命周期由栈帧的销毁来管理，而 shared_ptr 并不清楚这一点。这将导致程序的未定义行为。 案例：
class TestB { public: TestB(){ cout << "TestB create" << endl; } ~TestB(){ cout << "TestB destory" << endl; } shared_ptr<TestB> getSharedFromThis() { return shared_ptr<TestB> (this); } }; int main(){ { shared_ptr<TestB> ptr3(new TestB()); shared_ptr<TestB> ptr4 = ptr3->getSharedFromThis(); cout << "ptr2 count: " << ptr3.use_count() << " ptr4 count: " << ptr4.use_count() << endl; //输出：ptr2 count: 1 ptr4 count: 1 然后会崩溃因为重复释放 } cin.get(); return 0; } 如何会导致shared_ptr指向同一个对象，但是不共享引用计数器？
是因为裸指针与shared_ptr混用，如果我们用一个裸指针初始化或者赋值给shared_ptr指针时，在shared_ptr内部生成一个计数器，当另外一个shared_ptr不用share_ptr赋值或者初始化的话，再次将一个裸指针赋值给另外一个shared_ptr时，又一次生成一个计数器，两个计数器不共享。'><meta property="og:url" content="https://jekyulll.github.io/post/cpp-%E4%BB%8E%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90-c++-shared_from_this/"><meta property="og:site_name" content="Hello Friend NG"><meta property="og:title" content="从场景解析 C++ shared_from_this"><meta property="og:description" content='智能指针之shared_ptr易错点05。
掌握C++ 智能指针的自我引用：深入解析 shared_from_this 和 weak_from_this。
C++之shared_from_this用法以及类自引用this指针陷阱。
思考：
设计一个树的节点的时候，如果使用智能指针：用一个std::vector<shared_ptr<TreeNode>>来存储子节点，为避免循环引用，用weak_ptr<TreeNode>来存储自身的父节点指针。
那添加子节点的时候，怎么把自身的shared_ptr赋值给子节点存储的父节点指针呢？
两个错误做法： 使用std::make_shared<TreeNode<T>>(*this)来创建一个新的shared_ptr，然后赋值给子节点存储的父节点指针。 void addChild(std::shared_ptr<TreeNode<T>> child) { // 使用 make_shared 来创建子节点并设置父节点 child->setParent(std::make_shared<TreeNode<T>>(*this)); // 错误的做法 children.push_back(child); } 使用 std::make_shared<TreeNode<T>>(*this) 时，实际上是对当前对象的 拷贝构造（调用拷贝构造函数）来创建一个新的 TreeNode<T> 对象。这意味着你将当前节点的状态（但不是智能指针）拷贝到一个新的对象中，而新对象的生命周期由 std::shared_ptr 管理。
使用 std::shared_ptr<TreeNode<T>> ptr(this) 把裸指针 this 包装为 shared_ptr。 将 this 传递给 std::shared_ptr<TreeNode<T>> 会导致新创建的 shared_ptr 管理一个裸指针，而裸指针的生命周期没有由智能指针控制。
引出一个常规问题，从裸指针创建 shared_ptr 的隐患：
当 shared_ptr 的引用计数归零时，它会释放它所管理的对象。如果裸指针在此时继续存在，它仍然会指向原来的内存地址。但这时该内存已被释放，裸指针成为了悬空指针，也就是所谓的野指针。 如果裸指针指向的内存已经被释放（例如，该指针原本由 delete 或 delete[] 释放），然后你用这个裸指针创建 shared_ptr，那么 shared_ptr 仍然会管理这个已经释放的内存区域。这会导致访问已释放内存（悬空指针）或双重释放内存的问题（如果 shared_ptr 销毁时再次释放内存）。 裸指针可能指向一个栈上的对象：如果裸指针指向一个栈上分配的对象，并且你用它创建 shared_ptr，那么 shared_ptr 会试图在引用计数归零时释放这个栈上对象的内存。然而，栈上对象的生命周期由栈帧的销毁来管理，而 shared_ptr 并不清楚这一点。这将导致程序的未定义行为。 案例：
class TestB { public: TestB(){ cout << "TestB create" << endl; } ~TestB(){ cout << "TestB destory" << endl; } shared_ptr<TestB> getSharedFromThis() { return shared_ptr<TestB> (this); } }; int main(){ { shared_ptr<TestB> ptr3(new TestB()); shared_ptr<TestB> ptr4 = ptr3->getSharedFromThis(); cout << "ptr2 count: " << ptr3.use_count() << " ptr4 count: " << ptr4.use_count() << endl; //输出：ptr2 count: 1 ptr4 count: 1 然后会崩溃因为重复释放 } cin.get(); return 0; } 如何会导致shared_ptr指向同一个对象，但是不共享引用计数器？
是因为裸指针与shared_ptr混用，如果我们用一个裸指针初始化或者赋值给shared_ptr指针时，在shared_ptr内部生成一个计数器，当另外一个shared_ptr不用share_ptr赋值或者初始化的话，再次将一个裸指针赋值给另外一个shared_ptr时，又一次生成一个计数器，两个计数器不共享。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-09T20:05:47+08:00"><meta property="article:modified_time" content="2025-01-09T20:05:47+08:00"><meta property="article:tag" content="Cpp"><meta property="og:image" content="https://jekyulll.github.io/"><meta property="article:section" content="cpp"><meta property="article:published_time" content="2025-01-09 20:05:47 +0800 +0800"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello friend ng</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>Blog</a></li><ul class=submenu><li class=dropdown><a href=javascript:void(0) class=dropbtn>en</a><div class=dropdown-content></div></li></ul></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://jekyulll.github.io/post/cpp-%E4%BB%8E%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90-c++-shared_from_this/>从场景解析 C++ shared_from_this</a></h2><div class=post-content><hr><p><a href=https://blog.csdn.net/weixin_44517656/article/details/114208041>智能指针之shared_ptr易错点05</a>。<br><a href=https://zhuanlan.zhihu.com/p/701343248>掌握C++ 智能指针的自我引用：深入解析 <code>shared_from_this</code> 和 <code>weak_from_this</code></a>。<br><a href=https://blog.csdn.net/weixin_44834554/article/details/131589849>C++之shared_from_this用法以及类自引用this指针陷阱</a>。</p><hr><p><strong>思考</strong>：</p><blockquote><p>设计一个树的节点的时候，如果使用智能指针：用一个<code>std::vector&lt;shared_ptr&lt;TreeNode>></code>来存储子节点，为避免循环引用，用<code>weak_ptr&lt;TreeNode></code>来存储自身的父节点指针。<br>那添加子节点的时候，怎么把自身的<code>shared_ptr</code>赋值给子节点存储的父节点指针呢？</p></blockquote><h3 id=两个错误做法>两个错误做法：</h3><ol><li>使用<code>std::make_shared&lt;TreeNode&lt;T>>(*this)</code>来创建一个新的<code>shared_ptr</code>，然后赋值给子节点存储的父节点指针。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addChild</span>(std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> child) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 make_shared 来创建子节点并设置父节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    child<span style=color:#f92672>-&gt;</span>setParent(std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>));  <span style=color:#75715e>// 错误的做法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    children.push_back(child);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 <code>std::make_shared&lt;TreeNode&lt;T>>(*this)</code> 时，实际上是对当前对象的 拷贝构造（调用拷贝构造函数）来创建一个新的 <code>TreeNode&lt;T></code> 对象。这意味着你将当前节点的状态（但不是智能指针）拷贝到一个新的对象中，而新对象的生命周期由 <code>std::shared_ptr</code> 管理。</p><ol start=2><li>使用 <code>std::shared_ptr&lt;TreeNode&lt;T>> ptr(this)</code> 把裸指针 <code>this</code> 包装为 <code>shared_ptr</code>。</li></ol><p>将 <code>this</code> 传递给 <code>std::shared_ptr&lt;TreeNode&lt;T>></code> 会导致新创建的 <code>shared_ptr</code> 管理一个裸指针，而裸指针的生命周期没有由智能指针控制。</p><p>引出一个常规问题，从裸指针创建 <code>shared_ptr</code> 的隐患：</p><ul><li>当 <code>shared_ptr</code> 的引用计数归零时，它会释放它所管理的对象。如果裸指针在此时继续存在，它仍然会指向原来的内存地址。但这时该内存已被释放，裸指针成为了<em>悬空指针</em>，也就是所谓的<em>野指针</em>。</li><li>如果裸指针指向的内存已经被释放（例如，该指针原本由 <code>delete</code> 或 <code>delete[]</code> 释放），然后你用这个裸指针创建 <code>shared_ptr</code>，那么 <code>shared_ptr</code> 仍然会管理这个已经释放的内存区域。这会导致访问已释放内存（悬空指针）或<em>双重释放内存</em>的问题（如果 <code>shared_ptr</code> 销毁时再次释放内存）。</li><li>裸指针可能指向一个栈上的对象：如果裸指针指向一个栈上分配的对象，并且你用它创建 <code>shared_ptr</code>，那么 <code>shared_ptr</code> 会试图在引用计数归零时释放这个栈上对象的内存。然而，栈上对象的生命周期由栈帧的销毁来管理，而 <code>shared_ptr</code> 并不清楚这一点。这将导致程序的未定义行为。</li></ul><p><strong>案例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestB</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	TestB(){
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;TestB create&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#f92672>~</span>TestB(){
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;TestB destory&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	shared_ptr<span style=color:#f92672>&lt;</span>TestB<span style=color:#f92672>&gt;</span> getSharedFromThis() { 
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>  shared_ptr<span style=color:#f92672>&lt;</span>TestB<span style=color:#f92672>&gt;</span> (<span style=color:#66d9ef>this</span>); 
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		shared_ptr<span style=color:#f92672>&lt;</span>TestB<span style=color:#f92672>&gt;</span> ptr3(<span style=color:#66d9ef>new</span> TestB());
</span></span><span style=display:flex><span>		shared_ptr<span style=color:#f92672>&lt;</span>TestB<span style=color:#f92672>&gt;</span> ptr4 <span style=color:#f92672>=</span> ptr3<span style=color:#f92672>-&gt;</span>getSharedFromThis();
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;ptr2 count: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> ptr3.use_count() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; ptr4 count: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> ptr4.use_count() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>		<span style=color:#75715e>//输出：ptr2 count: 1 ptr4 count: 1 然后会崩溃因为重复释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	cin.get();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如何会导致<code>shared_ptr</code>指向同一个对象，但是不共享引用计数器？<br>是因为裸指针与<code>shared_ptr</code>混用，如果我们用一个裸指针初始化或者赋值给<code>shared_ptr</code>指针时，在<code>shared_ptr</code>内部生成一个计数器，当另外一个<code>shared_ptr</code>不用<code>share_ptr</code>赋值或者初始化的话，再次将一个裸指针赋值给另外一个<code>shared_ptr</code>时，又一次生成一个计数器，两个计数器不共享。</p><hr><h3 id=shared_ptr实现原理><code>shared_ptr</code>实现原理：</h3><p><code>shared_ptr</code> 从 <code>_Ptr_base</code> 继承了 <code>element_type</code> 和 <code>_Ref_count_base</code> 类型的两个成员变量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Ty</span><span style=color:#f92672>&gt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Ptr_base</span>
</span></span><span style=display:flex><span>{ 
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span> 
</span></span><span style=display:flex><span>        element_type <span style=color:#f92672>*</span> _Ptr{
</span></span><span style=display:flex><span>            ptr
</span></span><span style=display:flex><span>        }; <span style=color:#75715e>// 指向资源的指针 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _Ref_count_base <span style=color:#f92672>*</span> _Rep{
</span></span><span style=display:flex><span>            ptr
</span></span><span style=display:flex><span>        }; <span style=color:#75715e>// 指向资源引用计数的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p><code>_Ref_count_base</code> 中定义了原子类型的变量 <code>_Uses</code> 和 <code>_Weaks</code>，它们分别记录资源的引用个数和资源观察者的个数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>__declspec</span>(novtable) _Ref_count_base
</span></span><span style=display:flex><span>{ 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>         _Atomic_counter_t _Uses;<span style=color:#75715e>//记录资源引用个数 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         _Atomic_counter_t _Weaks;<span style=color:#75715e>//记录观察者个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><hr><h3 id=从-this-构造智能指针的正确做法>从 <code>this</code> 构造智能指针的正确做法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span><span style=color:#f92672>:</span> enable_shared_from_this<span style=color:#f92672>&lt;</span>MyClass<span style=color:#f92672>&gt;</span><span style=color:#75715e>//必须继承enable_shared_from_this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    shared_ptr<span style=color:#f92672>&lt;</span>MyClass<span style=color:#f92672>&gt;</span> getself()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>shared_from_this</span>();
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>shared_from_this</code> 是 C++11 中引入的功能，允许对象在继承了 <code>std::enable_shared_from_this</code> 的情况下，安全地生成自身的 <code>std::shared_ptr</code> 实例，而不会创建新的控制块（reference counting block）。这样可以避免悬垂指针的问题，特别是在对象的成员函数中使用时，可以确保对象在使用期间不被销毁。</p><p><code>std::enable_shared_from_this&lt;T></code> 内部维护了一个 <code>std::weak_ptr&lt;T></code>。当第一个 <code>std::shared_ptr&lt;T></code> 开始管理该对象时，这个 <code>weak_ptr</code> 被初始化。之后，当 <code>shared_from_this()</code> 被调用时，它将基于这个已经存在的 <code>weak_ptr</code> 返回一个新的 <code>std::shared_ptr&lt;T></code>，这个新的 <code>shared_ptr</code> 与原有的 <code>shared_ptr</code> 共享对对象的所有权。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    shared_ptr<span style=color:#f92672>&lt;</span>_Tp<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>      shared_from_this()
</span></span><span style=display:flex><span>      { <span style=color:#66d9ef>return</span> shared_ptr<span style=color:#f92672>&lt;</span>_Tp<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>_M_weak_this); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      shared_ptr<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> _Tp<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>      shared_from_this() <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>      { <span style=color:#66d9ef>return</span> shared_ptr<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> _Tp<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>_M_weak_this); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>mutable</span> weak_ptr<span style=color:#f92672>&lt;</span>_Tp<span style=color:#f92672>&gt;</span>  _M_weak_this;
</span></span></code></pre></div><hr><p><strong>实践</strong>：</p><p>实现这个 <code>TreeNode</code> 类的时候，<code>shared_from_this</code> 解析不出来(似乎是因为模板导致的 clangd 语法解析失败)。</p><p><img src=/images/ERRORshared_from_this.png alt=语法></p><p>改为 <code>this->shared_from_this()</code> 后报错消失，因为 <code>shared_from_this</code> 实际上是当前父类 <code>enable_shared_from_this</code> 的成员函数。</p><p>最终实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TreeNode</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>enable_shared_from_this<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TreeNode(T value) <span style=color:#f92672>:</span> value(value) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setParent</span>(std<span style=color:#f92672>::</span>weak_ptr<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> parent) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>parent <span style=color:#f92672>=</span> parent;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addChild</span>(std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> child) {
</span></span><span style=display:flex><span>        child<span style=color:#f92672>-&gt;</span>setParent(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>shared_from_this());
</span></span><span style=display:flex><span>        children.push_back(child);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T <span style=color:#a6e22e>getValue</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> getParent() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> parent.lock();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;&gt;&amp;</span> getChildren() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> children;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    T value;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;&gt;</span> children;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>weak_ptr<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> parent;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://jekyulll.github.io/tags/cpp/>cpp</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://jekyulll.github.io/categories/cpp/>cpp</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>