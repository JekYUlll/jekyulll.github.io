<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="JekYUlll"><meta name=description content='一篇文章学完 Effective Modern C++：条款 & 实践：
条款1： 模板参数类型推导，引用折叠 template<typename T> void f(T&& param); int x = 27; const int cx = x; const int& rx = x; // 左值的情况 f(x); // T 的类型为 int&, paramType 为 int& f(cx); // T 的类型为 const int&, paramType 为 const int& f(rx); // T 的类型为 const int&, paramType 为 const int& // 右值的情况 f(27) // T 的类型为 int, paramType 为 int&& 对于指向 const 对象的 const 指针的传递，仅有指针本身的常量性会被忽略：
template<typename T> void f(T param); const char* const ptr = "Fun with pointers"; f(ptr); // T 和 param 的类型均为 const char* 按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：
'><meta name=keywords content="homepage,blog,cpp,morden cpp,template"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://jekyulll.github.io/post/cpp-morden-c++-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/><title>C++ 模板类型推导 :: Hello Friend NG — A simple theme for Hugo
</title><link rel=stylesheet href=/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css integrity="sha256-JEGDzeGjjgsI+CwReRGBKI+arBzJYYzW9OnncQxXaLo=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="C++ 模板类型推导"><meta itemprop=description content='一篇文章学完 Effective Modern C++：条款 & 实践：
条款1： 模板参数类型推导，引用折叠 template<typename T> void f(T&& param); int x = 27; const int cx = x; const int& rx = x; // 左值的情况 f(x); // T 的类型为 int&, paramType 为 int& f(cx); // T 的类型为 const int&, paramType 为 const int& f(rx); // T 的类型为 const int&, paramType 为 const int& // 右值的情况 f(27) // T 的类型为 int, paramType 为 int&& 对于指向 const 对象的 const 指针的传递，仅有指针本身的常量性会被忽略：
template<typename T> void f(T param); const char* const ptr = "Fun with pointers"; f(ptr); // T 和 param 的类型均为 const char* 按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：'><meta itemprop=datePublished content="2024-09-01T18:05:47+08:00"><meta itemprop=dateModified content="2024-09-01T18:05:47+08:00"><meta itemprop=wordCount content="263"><meta itemprop=image content="https://jekyulll.github.io/"><meta itemprop=keywords content="Cpp,Morden Cpp,Template"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jekyulll.github.io/"><meta name=twitter:title content="C++ 模板类型推导"><meta name=twitter:description content='一篇文章学完 Effective Modern C++：条款 & 实践：
条款1： 模板参数类型推导，引用折叠 template<typename T> void f(T&& param); int x = 27; const int cx = x; const int& rx = x; // 左值的情况 f(x); // T 的类型为 int&, paramType 为 int& f(cx); // T 的类型为 const int&, paramType 为 const int& f(rx); // T 的类型为 const int&, paramType 为 const int& // 右值的情况 f(27) // T 的类型为 int, paramType 为 int&& 对于指向 const 对象的 const 指针的传递，仅有指针本身的常量性会被忽略：
template<typename T> void f(T param); const char* const ptr = "Fun with pointers"; f(ptr); // T 和 param 的类型均为 const char* 按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：'><meta property="og:url" content="https://jekyulll.github.io/post/cpp-morden-c++-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"><meta property="og:site_name" content="Hello Friend NG"><meta property="og:title" content="C++ 模板类型推导"><meta property="og:description" content='一篇文章学完 Effective Modern C++：条款 & 实践：
条款1： 模板参数类型推导，引用折叠 template<typename T> void f(T&& param); int x = 27; const int cx = x; const int& rx = x; // 左值的情况 f(x); // T 的类型为 int&, paramType 为 int& f(cx); // T 的类型为 const int&, paramType 为 const int& f(rx); // T 的类型为 const int&, paramType 为 const int& // 右值的情况 f(27) // T 的类型为 int, paramType 为 int&& 对于指向 const 对象的 const 指针的传递，仅有指针本身的常量性会被忽略：
template<typename T> void f(T param); const char* const ptr = "Fun with pointers"; f(ptr); // T 和 param 的类型均为 const char* 按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-01T18:05:47+08:00"><meta property="article:modified_time" content="2024-09-01T18:05:47+08:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Morden Cpp"><meta property="article:tag" content="Template"><meta property="og:image" content="https://jekyulll.github.io/"><meta property="article:section" content="cpp"><meta property="article:published_time" content="2024-09-01 18:05:47 +0800 +0800"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello friend ng</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>Blog</a></li><ul class=submenu><li class=dropdown><a href=javascript:void(0) class=dropbtn>en</a><div class=dropdown-content></div></li></ul></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://jekyulll.github.io/post/cpp-morden-c++-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/>C++ 模板类型推导</a></h2><div class=post-content><p><a href=https://zhuanlan.zhihu.com/p/649667647>一篇文章学完 Effective Modern C++：条款 & 实践</a>：</p><h2 id=条款1-模板参数类型推导引用折叠>条款1： 模板参数类型推导，引用折叠</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> f(T<span style=color:#f92672>&amp;&amp;</span> param);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>27</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> cx <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> rx <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 左值的情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>f(x);    <span style=color:#75715e>// T 的类型为 int&amp;, paramType 为 int&amp;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>f(cx);   <span style=color:#75715e>// T 的类型为 const int&amp;, paramType 为 const int&amp;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>f(rx);   <span style=color:#75715e>// T 的类型为 const int&amp;, paramType 为 const int&amp;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 右值的情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>f(<span style=color:#ae81ff>27</span>)    <span style=color:#75715e>// T 的类型为 int, paramType 为 int&amp;&amp;
</span></span></span></code></pre></div><p>对于指向 <code>const</code> 对象的 <code>const</code> 指针的传递，仅有指针本身的常量性会被忽略：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> f(T param);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> ptr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Fun with pointers&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f(ptr);    <span style=color:#75715e>// T 和 param 的类型均为 const char*
</span></span></span></code></pre></div><p>按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> f(T<span style=color:#f92672>&amp;</span> param);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> name[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;J. P. Briggs&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f(name);   <span style=color:#75715e>// T 的类型为 const char[13], paramType 为 const char (&amp;)[13]
</span></span></span></code></pre></div><p>利用声明数组引用这一能力可以创造出一个模板，用来推导出数组含有的元素个数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, std<span style=color:#f92672>::</span>size_t N<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> std<span style=color:#f92672>::</span>size_t arraySize(T (<span style=color:#f92672>&amp;</span>)[N]) <span style=color:#66d9ef>noexcept</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> N;
</span></span><span style=display:flex><span>} <span style=color:#75715e>// constexpr 函数，表示这个函数可以在编译时计算结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> arr[<span style=color:#ae81ff>10</span>];
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t size <span style=color:#f92672>=</span> arraySize(arr); <span style=color:#75715e>// size 的值是 10
</span></span></span></code></pre></div><p>函数类型同样也会退化成函数指针，并且和数组类型的规则类似：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>someFunc</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>double</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> f1(T param);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> f2(T<span style=color:#f92672>&amp;</span> param);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f1(someFunc);   <span style=color:#75715e>// param 被推导为函数指针，具体类型为 void (*)(int, double)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>f2(someFunc);   <span style=color:#75715e>// param 被推导为函数引用，具体类型为 void (&amp;)(int, double)
</span></span></span></code></pre></div><h2 id=条款2-auto类型推导>条款2： auto类型推导</h2><h2 id=条款3理解-decltype>条款3：理解 decltype</h2><p>在 C++11 中，<code>decltype</code>的主要用途是声明返回值类型依赖于形参类型的函数模板，这需要用到返回值类型尾置语法(trailing return type syntax)：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Container, <span style=color:#66d9ef>typename</span> Index<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> authAndAccess(Container<span style=color:#f92672>&amp;</span> c, Index i) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>decltype</span>(c[i]) {
</span></span><span style=display:flex><span>    authenticateUser();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> c[i];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>C++11 允许对单表达式的 lambda 的返回值实施类型推导，而 C++14 将这个允许范围扩张到了一切函数和一切 lambda，包括那些多表达式的。这就意味着在 C++14 中可以去掉返回值类型尾置语法，仅保留前导<code>auto</code>。<br>但编译器会为<code>auto</code>指定为返回值类型的函数实施模板类型推导，这样就会留下隐患（例如忽略初始化表达的引用性），使用<code>decltype(auto)</code>来说明我们采用的是<code>decltype</code>的规则，就可以解决这个问题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Container, <span style=color:#66d9ef>typename</span> Index<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>decltype</span>(<span style=color:#66d9ef>auto</span>) authAndAccess(Container<span style=color:#f92672>&amp;</span> c, Index i) {
</span></span><span style=display:flex><span>    authenticateUser();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> c[i];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在初始化表达式处也可以应用<code>decltype</code>类型推导规则：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Widget w;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> Widget<span style=color:#f92672>&amp;</span> cw <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> myWidget1 <span style=color:#f92672>=</span> cw;            <span style=color:#75715e>// auto 推导出类型为 Widget
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>decltype</span>(<span style=color:#66d9ef>auto</span>) myWidget2 <span style=color:#f92672>=</span> cw;  <span style=color:#75715e>// decltype 推导出类型为 const Widget&amp;
</span></span></span></code></pre></div><p>在上述情形中，我们无法向函数传递右值容器，若想要采用一种既能绑定到左值也能绑定到右值的引用形参，就需要借助万能引用，并应用<code>std::forward</code>（参考条款 25）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Container, <span style=color:#66d9ef>typename</span> Index<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>decltype</span>(<span style=color:#66d9ef>auto</span>) authAndAccess(Container<span style=color:#f92672>&amp;&amp;</span> c, Index i) {
</span></span><span style=display:flex><span>    authenticateUser();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>Container<span style=color:#f92672>&gt;</span>(c)[i];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://jekyulll.github.io/tags/cpp/>cpp</a></span>
<span class=tag><a href=https://jekyulll.github.io/tags/morden-cpp/>morden cpp</a></span>
<span class=tag><a href=https://jekyulll.github.io/tags/template/>template</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://jekyulll.github.io/categories/cpp/>cpp</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>