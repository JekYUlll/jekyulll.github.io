<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="JekYUlll"><meta name=description content='观察以下这段明显错误的代码：
const char* get_c() { std::string s = "hello world"; return s.c_str(); } int main() { printf("danger : %s\n", get_c()); return 0; } 字符串s是一个函数内部的临时对象，返回的const char*实际上是一个指针。函数结束后s会析构，而指针理论上会变成悬空的。
实际上正确打印出了：
danger : hello world (实际上只是因为该段内存没有被立刻覆盖，理论上是不安全的)
查看一下汇编：
构造 s： leaq .LC0(%rip), %rcx ; 加载 "hello world" 地址到 %rcx leaq -64(%rbp), %rax ; 栈上分配 s 的内存 call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_ ; 调用构造函数 字符串 "hello world" 存储在 .rodata 只读数据段（.LC0）。 s 在栈上构造，通过 SSO 直接存储字符串内容。 获取 c_str()： leaq -64(%rbp), %rax call _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv@PLT movq %rax, %rbx ; 将 c_str() 指针保存到 %rbx 析构 s： leaq -64(%rbp), %rax movq %rax, %rdi call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@PLT ; 调用析构函数 对于较短的字符串（如 &ldquo;hello world"），std::string 可能使用 短字符串优化（SSO），将数据直接存储在对象内部的栈空间中，而非堆内存。
在get_c中，s是在栈上分配的，当函数返回时，栈空间可能未被其他数据覆盖，所以字符串内容仍然保留。此时调用printf，可能仍然能读取到原来的数据，但这只是巧合，属于未定义行为的表现。
'><meta name=keywords content="homepage,blog,cpp"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://jekyulll.github.io/post/cpp-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAc_str%E7%9A%84%E5%B0%8F%E5%9D%91/><title>如何让函数安全返回 std::string 的 c_str :: Hello Friend NG — A simple theme for Hugo
</title><link rel=stylesheet href=/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css integrity="sha256-JEGDzeGjjgsI+CwReRGBKI+arBzJYYzW9OnncQxXaLo=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="如何让函数安全返回 std::string 的 c_str"><meta itemprop=description content='观察以下这段明显错误的代码：
const char* get_c() { std::string s = "hello world"; return s.c_str(); } int main() { printf("danger : %s\n", get_c()); return 0; } 字符串s是一个函数内部的临时对象，返回的const char*实际上是一个指针。函数结束后s会析构，而指针理论上会变成悬空的。
实际上正确打印出了：
danger : hello world (实际上只是因为该段内存没有被立刻覆盖，理论上是不安全的)
查看一下汇编：
构造 s： leaq .LC0(%rip), %rcx ; 加载 "hello world" 地址到 %rcx leaq -64(%rbp), %rax ; 栈上分配 s 的内存 call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_ ; 调用构造函数 字符串 "hello world" 存储在 .rodata 只读数据段（.LC0）。 s 在栈上构造，通过 SSO 直接存储字符串内容。 获取 c_str()： leaq -64(%rbp), %rax call _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv@PLT movq %rax, %rbx ; 将 c_str() 指针保存到 %rbx 析构 s： leaq -64(%rbp), %rax movq %rax, %rdi call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@PLT ; 调用析构函数 对于较短的字符串（如 “hello world"），std::string 可能使用 短字符串优化（SSO），将数据直接存储在对象内部的栈空间中，而非堆内存。
在get_c中，s是在栈上分配的，当函数返回时，栈空间可能未被其他数据覆盖，所以字符串内容仍然保留。此时调用printf，可能仍然能读取到原来的数据，但这只是巧合，属于未定义行为的表现。'><meta itemprop=datePublished content="2025-02-23T12:05:47+08:00"><meta itemprop=dateModified content="2025-02-23T12:05:47+08:00"><meta itemprop=wordCount content="179"><meta itemprop=image content="https://jekyulll.github.io/"><meta itemprop=keywords content="Cpp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jekyulll.github.io/"><meta name=twitter:title content="如何让函数安全返回 std::string 的 c_str"><meta name=twitter:description content='观察以下这段明显错误的代码：
const char* get_c() { std::string s = "hello world"; return s.c_str(); } int main() { printf("danger : %s\n", get_c()); return 0; } 字符串s是一个函数内部的临时对象，返回的const char*实际上是一个指针。函数结束后s会析构，而指针理论上会变成悬空的。
实际上正确打印出了：
danger : hello world (实际上只是因为该段内存没有被立刻覆盖，理论上是不安全的)
查看一下汇编：
构造 s： leaq .LC0(%rip), %rcx ; 加载 "hello world" 地址到 %rcx leaq -64(%rbp), %rax ; 栈上分配 s 的内存 call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_ ; 调用构造函数 字符串 "hello world" 存储在 .rodata 只读数据段（.LC0）。 s 在栈上构造，通过 SSO 直接存储字符串内容。 获取 c_str()： leaq -64(%rbp), %rax call _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv@PLT movq %rax, %rbx ; 将 c_str() 指针保存到 %rbx 析构 s： leaq -64(%rbp), %rax movq %rax, %rdi call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@PLT ; 调用析构函数 对于较短的字符串（如 “hello world"），std::string 可能使用 短字符串优化（SSO），将数据直接存储在对象内部的栈空间中，而非堆内存。
在get_c中，s是在栈上分配的，当函数返回时，栈空间可能未被其他数据覆盖，所以字符串内容仍然保留。此时调用printf，可能仍然能读取到原来的数据，但这只是巧合，属于未定义行为的表现。'><meta property="og:url" content="https://jekyulll.github.io/post/cpp-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAc_str%E7%9A%84%E5%B0%8F%E5%9D%91/"><meta property="og:site_name" content="Hello Friend NG"><meta property="og:title" content="如何让函数安全返回 std::string 的 c_str"><meta property="og:description" content='观察以下这段明显错误的代码：
const char* get_c() { std::string s = "hello world"; return s.c_str(); } int main() { printf("danger : %s\n", get_c()); return 0; } 字符串s是一个函数内部的临时对象，返回的const char*实际上是一个指针。函数结束后s会析构，而指针理论上会变成悬空的。
实际上正确打印出了：
danger : hello world (实际上只是因为该段内存没有被立刻覆盖，理论上是不安全的)
查看一下汇编：
构造 s： leaq .LC0(%rip), %rcx ; 加载 "hello world" 地址到 %rcx leaq -64(%rbp), %rax ; 栈上分配 s 的内存 call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_ ; 调用构造函数 字符串 "hello world" 存储在 .rodata 只读数据段（.LC0）。 s 在栈上构造，通过 SSO 直接存储字符串内容。 获取 c_str()： leaq -64(%rbp), %rax call _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv@PLT movq %rax, %rbx ; 将 c_str() 指针保存到 %rbx 析构 s： leaq -64(%rbp), %rax movq %rax, %rdi call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@PLT ; 调用析构函数 对于较短的字符串（如 “hello world"），std::string 可能使用 短字符串优化（SSO），将数据直接存储在对象内部的栈空间中，而非堆内存。
在get_c中，s是在栈上分配的，当函数返回时，栈空间可能未被其他数据覆盖，所以字符串内容仍然保留。此时调用printf，可能仍然能读取到原来的数据，但这只是巧合，属于未定义行为的表现。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-02-23T12:05:47+08:00"><meta property="article:modified_time" content="2025-02-23T12:05:47+08:00"><meta property="article:tag" content="Cpp"><meta property="og:image" content="https://jekyulll.github.io/"><meta property="article:section" content="cpp"><meta property="article:published_time" content="2025-02-23 12:05:47 +0800 +0800"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello friend ng</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>Blog</a></li><ul class=submenu><li class=dropdown><a href=javascript:void(0) class=dropbtn>en</a><div class=dropdown-content></div></li></ul></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://jekyulll.github.io/post/cpp-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAc_str%E7%9A%84%E5%B0%8F%E5%9D%91/>如何让函数安全返回 std::string 的 c_str</a></h2><div class=post-content><p>观察以下这段明显错误的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>get_c</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello world&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> s.c_str();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;danger : %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, get_c());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>字符串<code>s</code>是一个函数内部的临时对象，返回的<code>const char*</code>实际上是一个指针。函数结束后<code>s</code>会析构，而指针理论上会变成悬空的。<br>实际上正确打印出了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>danger : hello world
</span></span></code></pre></div><p>(实际上只是因为该段内存没有被立刻覆盖，理论上是不安全的)</p><p>查看一下汇编：</p><ol><li>构造 <code>s</code>：</li></ol><pre tabindex=0><code class=language-ass data-lang=ass>leaq    .LC0(%rip), %rcx         ; 加载 &#34;hello world&#34; 地址到 %rcx
leaq    -64(%rbp), %rax          ; 栈上分配 s 的内存
call    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_ ; 调用构造函数
</code></pre><ul><li>字符串 <code>"hello world"</code> 存储在 <code>.rodata</code> 只读数据段（.LC0）。</li><li>s 在栈上构造，通过 SSO 直接存储字符串内容。</li></ul><ol start=2><li>获取 <code>c_str()</code>：</li></ol><pre tabindex=0><code class=language-ass data-lang=ass>leaq    -64(%rbp), %rax
call    _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv@PLT
movq    %rax, %rbx               ; 将 c_str() 指针保存到 %rbx
</code></pre><ol start=3><li>析构 <code>s</code>：</li></ol><pre tabindex=0><code class=language-ass data-lang=ass>leaq    -64(%rbp), %rax
movq    %rax, %rdi
call    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@PLT ; 调用析构函数
</code></pre><p>对于较短的字符串（如 &ldquo;<code>hello world</code>"），<code>std::string</code> 可能使用 短字符串优化（SSO），将数据直接存储在对象内部的栈空间中，而非堆内存。<br>在<code>get_c</code>中，<code>s</code>是在栈上分配的，当函数返回时，栈空间可能未被其他数据覆盖，所以字符串内容仍然保留。此时调用printf，可能仍然能读取到原来的数据，但这只是巧合，属于未定义行为的表现。</p><hr><h3 id=前情提要>前情提要</h3><p>写 webserver 的时候，设计了一个配置加载类用于加载配置文件。<br><em>eg</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>redis</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>host</span> = <span style=color:#e6db74>&#34;127.0.0.1&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>port</span> = <span style=color:#ae81ff>6379</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>password</span> = <span style=color:#e6db74>&#34;donotpanic&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>db</span> = <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>逻辑差不多长这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Config Config<span style=color:#f92672>::</span>_instance;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> Config<span style=color:#f92672>::</span>_configMap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>string Config<span style=color:#f92672>::</span>GetConfig(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> key) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> _configMap.find(key);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (it <span style=color:#f92672>!=</span> _configMap.end()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> it<span style=color:#f92672>-&gt;</span>second;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    LOG_W(<span style=color:#e6db74>&#34;Config &#39;{}&#39; not found&#34;</span>, key);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我想让其返回<code>c_str</code>，直接返回是不行的。添加一个<code>static</code>的<code>string</code>作为cache即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> Config<span style=color:#f92672>::</span>GetConfig(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> key) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> std<span style=color:#f92672>::</span>string cache;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> _configMap.find(key);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (it <span style=color:#f92672>!=</span> _configMap.end()) {
</span></span><span style=display:flex><span>        cache <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>second;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cache.c_str;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    LOG_W(<span style=color:#e6db74>&#34;Config &#39;{}&#39; not found&#34;</span>, key);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://jekyulll.github.io/tags/cpp/>cpp</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://jekyulll.github.io/categories/cpp/>cpp</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>