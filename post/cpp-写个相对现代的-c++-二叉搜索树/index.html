<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>写个相对现代的 C++ 二叉搜索树 - HOREB EVAN JEKYULLL BLOG</title>
<meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="JekYUlll"><meta name=description content=' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #include <functional> #include <iostream> #include <optional> #include <string> #include <vector> template <typename T> concept Comparable = requires(T a, T b) { { a < b } -> std::convertible_to<bool>; { a > b } -> std::convertible_to<bool>; { a == b } -> std::convertible_to<bool>; }; template <typename T> concept Streamable = requires(T a, std::ostream& os) { { os << a } -> std::same_as<std::ostream&>; }; template <Comparable K, Streamable V> class PairBSTree { private: using Pair = std::pair<K, V>; struct TreeNode { Pair _pair; TreeNode* _left; TreeNode* _right; TreeNode() = default; TreeNode(const Pair& pair) : _pair(pair), _left(nullptr), _right(nullptr) {} TreeNode(Pair&& pair) : _pair(std::move(pair)), _left(nullptr), _right(nullptr) {} ~TreeNode() = default; }; TreeNode* _root; void build_(const std::vector<Pair>& nodes) { for (const auto& pair : nodes) { Insert(pair); } } void build_(std::vector<Pair>&& nodes) { for (Pair& pair : nodes) { Insert(std::move(pair)); } } void destroy_(TreeNode* node) { if (node) { destroy_(node->_left); destroy_(node->_right); delete node; node = nullptr; } } TreeNode*& search_(TreeNode*& node, K key) const { if (!node || key == node->_pair.first) { return node; } if (key < node->_pair.first) { return search_(node->_left, key); } return search_(node->_right, key); } void insert_(TreeNode*& node, const Pair& pair) { if (!node) { node = new TreeNode(pair); return; } auto key = pair.first; if (key == node->_pair.first) { node->_pair = pair; } else if (key < node->_pair.first) { insert_(node->_left, pair); } else { insert_(node->_right, pair); } } TreeNode*& go_to_max_(TreeNode*& node) { while (node->_right) { node = node->_right; } return node; } TreeNode*& go_to_min_(TreeNode*& node) { while (node->_left) { node = node->_left; } return node; } void delete_(TreeNode*& node, K key) { auto& target = search_(node, key); if (!target) { return; } if (!target->_left && !target->_right) { delete target; target = nullptr; return; } if (!target->_left) { TreeNode* temp = target->_right; delete target; target = temp; return; } if (!target->_right) { TreeNode* temp = target->_left; delete target; target = temp; return; } auto& max_in_left = go_to_max_(target->_left); target->_pair = max_in_left->_pair; // 1. 常规的递归，把整个左子树当做新的树 // delete_(target->_left, max_in_left->_pair.first); // 2. 直接传入 max_in_left 即可 // delete_(max_in_left, max_in_left->_pair.first); // 3. 实际上不需要递归，因为 max_in_left 是左边最大的值，一定没有右子树 TreeNode* temp = max_in_left->_left; delete max_in_left; max_in_left = temp; // 我开始时候的代码（有误）： // auto& max_in_left = go_to_max_(node->_left); // 应该是 // current->_left current->_pair = max_in_left->_pair; delete // (max_in_left); max_in_left = nullptr; // 第三种和我开始时候的逻辑类似 // 但我当时忘了保留 max_in_left 的左子树（如果存在） } static void normal_print_func_(const Pair& pair) { std::cout << pair.second << " | "; } void in_order_(TreeNode* node, std::function<void(const Pair&)> func) { if (!node) { return; } in_order_(node->_left, func); func(node->_pair); in_order_(node->_right, func); } public: PairBSTree() : _root(nullptr) {} PairBSTree(const std::vector<Pair>& pairs) : _root(nullptr) { build_(pairs); } PairBSTree(std::vector<Pair>&& pairs) : _root(nullptr) { build_(std::move(pairs)); } ~PairBSTree() { destroy_(_root); } std::optional<V> Search(K key) { auto node = search_(_root, key); if (!node) { return std::nullopt; } return node->_pair.second; } void Insert(const Pair& pair) { insert_(_root, pair); } void Delete(K key) { delete_(_root, key); } void InOrder(std::function<void(Pair)> func = normal_print_func_) { in_order_(_root, func); } [[nodiscard]] size_t Size() { size_t size = 0; InOrder([&amp;size](std::pair<K, V>) { ++size; }); return size; } [[nodiscard]] V Max() { auto temp = _root; go_to_max_(temp); return temp->_pair.second; } [[nodiscard]] V Min() { auto temp = _root; go_to_min_(temp); return temp->_pair.second; } }; int main(void) { std::vector<std::pair<int, std::string>> pairs = { {2, "Bob"}, {9, "Jack"}, {4, "Lucy"}, {23, "Evan"}, {3, "Gorge"}, {12, "Lily"}, {15, "Mono"}, {90, "Rick"}, {14, "Lance"}, {76, "Molly"}, {24, "Stan"}, {11, "Scot"}, {54, "Mint"}, {37, "Biance"}, {35, "Cower"}, {1, "Brick"}, }; PairBSTree tree(pairs); std::cout << "Name of 9: " << tree.Search(9).value_or("nothing") << &#39;\n&#39;; std::cout << "Size: " << tree.Size() << &#39;\n&#39;; // std::cout << "Min: " << tree.Min() << &#39;\n&#39;; // std::cout << "Max: " << tree.Max() << &#39;\n&#39;; tree.InOrder(); std::cout << &#39;\n&#39;; tree.Delete(15); std::cout << "Size: " << tree.Size() << &#39;\n&#39;; tree.InOrder(); std::cout << &#39;\n&#39;; std::vector<std::string> names_in_order; tree.InOrder([&amp;names_in_order](std::pair<int, std::string> pair) { std::cout << pair.second << " -- "; names_in_order.push_back(pair.second); }); std::cout << std::endl; return 0; } '><meta name=keywords content="JekYUlll,theme,even"><meta name=generator content="Hugo 0.140.0 with theme even"><link rel=canonical href=https://jekyulll.github.io/post/cpp-%E5%86%99%E4%B8%AA%E7%9B%B8%E5%AF%B9%E7%8E%B0%E4%BB%A3%E7%9A%84-c++-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:url" content="https://jekyulll.github.io/post/cpp-%E5%86%99%E4%B8%AA%E7%9B%B8%E5%AF%B9%E7%8E%B0%E4%BB%A3%E7%9A%84-c++-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"><meta property="og:site_name" content="HOREB EVAN JEKYULLL BLOG"><meta property="og:title" content="写个相对现代的 C++ 二叉搜索树"><meta property="og:description" content='1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #include <functional> #include <iostream> #include <optional> #include <string> #include <vector> template <typename T> concept Comparable = requires(T a, T b) { { a < b } -> std::convertible_to<bool>; { a > b } -> std::convertible_to<bool>; { a == b } -> std::convertible_to<bool>; }; template <typename T> concept Streamable = requires(T a, std::ostream& os) { { os << a } -> std::same_as<std::ostream&>; }; template <Comparable K, Streamable V> class PairBSTree { private: using Pair = std::pair<K, V>; struct TreeNode { Pair _pair; TreeNode* _left; TreeNode* _right; TreeNode() = default; TreeNode(const Pair& pair) : _pair(pair), _left(nullptr), _right(nullptr) {} TreeNode(Pair&& pair) : _pair(std::move(pair)), _left(nullptr), _right(nullptr) {} ~TreeNode() = default; }; TreeNode* _root; void build_(const std::vector<Pair>& nodes) { for (const auto& pair : nodes) { Insert(pair); } } void build_(std::vector<Pair>&& nodes) { for (Pair& pair : nodes) { Insert(std::move(pair)); } } void destroy_(TreeNode* node) { if (node) { destroy_(node->_left); destroy_(node->_right); delete node; node = nullptr; } } TreeNode*& search_(TreeNode*& node, K key) const { if (!node || key == node->_pair.first) { return node; } if (key < node->_pair.first) { return search_(node->_left, key); } return search_(node->_right, key); } void insert_(TreeNode*& node, const Pair& pair) { if (!node) { node = new TreeNode(pair); return; } auto key = pair.first; if (key == node->_pair.first) { node->_pair = pair; } else if (key < node->_pair.first) { insert_(node->_left, pair); } else { insert_(node->_right, pair); } } TreeNode*& go_to_max_(TreeNode*& node) { while (node->_right) { node = node->_right; } return node; } TreeNode*& go_to_min_(TreeNode*& node) { while (node->_left) { node = node->_left; } return node; } void delete_(TreeNode*& node, K key) { auto& target = search_(node, key); if (!target) { return; } if (!target->_left && !target->_right) { delete target; target = nullptr; return; } if (!target->_left) { TreeNode* temp = target->_right; delete target; target = temp; return; } if (!target->_right) { TreeNode* temp = target->_left; delete target; target = temp; return; } auto& max_in_left = go_to_max_(target->_left); target->_pair = max_in_left->_pair; // 1. 常规的递归，把整个左子树当做新的树 // delete_(target->_left, max_in_left->_pair.first); // 2. 直接传入 max_in_left 即可 // delete_(max_in_left, max_in_left->_pair.first); // 3. 实际上不需要递归，因为 max_in_left 是左边最大的值，一定没有右子树 TreeNode* temp = max_in_left->_left; delete max_in_left; max_in_left = temp; // 我开始时候的代码（有误）： // auto& max_in_left = go_to_max_(node->_left); // 应该是 // current->_left current->_pair = max_in_left->_pair; delete // (max_in_left); max_in_left = nullptr; // 第三种和我开始时候的逻辑类似 // 但我当时忘了保留 max_in_left 的左子树（如果存在） } static void normal_print_func_(const Pair& pair) { std::cout << pair.second << " | "; } void in_order_(TreeNode* node, std::function<void(const Pair&)> func) { if (!node) { return; } in_order_(node->_left, func); func(node->_pair); in_order_(node->_right, func); } public: PairBSTree() : _root(nullptr) {} PairBSTree(const std::vector<Pair>& pairs) : _root(nullptr) { build_(pairs); } PairBSTree(std::vector<Pair>&& pairs) : _root(nullptr) { build_(std::move(pairs)); } ~PairBSTree() { destroy_(_root); } std::optional<V> Search(K key) { auto node = search_(_root, key); if (!node) { return std::nullopt; } return node->_pair.second; } void Insert(const Pair& pair) { insert_(_root, pair); } void Delete(K key) { delete_(_root, key); } void InOrder(std::function<void(Pair)> func = normal_print_func_) { in_order_(_root, func); } [[nodiscard]] size_t Size() { size_t size = 0; InOrder([&amp;size](std::pair<K, V>) { ++size; }); return size; } [[nodiscard]] V Max() { auto temp = _root; go_to_max_(temp); return temp->_pair.second; } [[nodiscard]] V Min() { auto temp = _root; go_to_min_(temp); return temp->_pair.second; } }; int main(void) { std::vector<std::pair<int, std::string>> pairs = { {2, "Bob"}, {9, "Jack"}, {4, "Lucy"}, {23, "Evan"}, {3, "Gorge"}, {12, "Lily"}, {15, "Mono"}, {90, "Rick"}, {14, "Lance"}, {76, "Molly"}, {24, "Stan"}, {11, "Scot"}, {54, "Mint"}, {37, "Biance"}, {35, "Cower"}, {1, "Brick"}, }; PairBSTree tree(pairs); std::cout << "Name of 9: " << tree.Search(9).value_or("nothing") << &#39;\n&#39;; std::cout << "Size: " << tree.Size() << &#39;\n&#39;; // std::cout << "Min: " << tree.Min() << &#39;\n&#39;; // std::cout << "Max: " << tree.Max() << &#39;\n&#39;; tree.InOrder(); std::cout << &#39;\n&#39;; tree.Delete(15); std::cout << "Size: " << tree.Size() << &#39;\n&#39;; tree.InOrder(); std::cout << &#39;\n&#39;; std::vector<std::string> names_in_order; tree.InOrder([&amp;names_in_order](std::pair<int, std::string> pair) { std::cout << pair.second << " -- "; names_in_order.push_back(pair.second); }); std::cout << std::endl; return 0; }'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-21T12:05:47+08:00"><meta property="article:modified_time" content="2025-01-21T12:05:47+08:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Morden Cpp"><meta property="article:tag" content="Template"><meta property="article:tag" content="Data Structure"><meta itemprop=name content="写个相对现代的 C++ 二叉搜索树"><meta itemprop=description content='1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #include <functional> #include <iostream> #include <optional> #include <string> #include <vector> template <typename T> concept Comparable = requires(T a, T b) { { a < b } -> std::convertible_to<bool>; { a > b } -> std::convertible_to<bool>; { a == b } -> std::convertible_to<bool>; }; template <typename T> concept Streamable = requires(T a, std::ostream& os) { { os << a } -> std::same_as<std::ostream&>; }; template <Comparable K, Streamable V> class PairBSTree { private: using Pair = std::pair<K, V>; struct TreeNode { Pair _pair; TreeNode* _left; TreeNode* _right; TreeNode() = default; TreeNode(const Pair& pair) : _pair(pair), _left(nullptr), _right(nullptr) {} TreeNode(Pair&& pair) : _pair(std::move(pair)), _left(nullptr), _right(nullptr) {} ~TreeNode() = default; }; TreeNode* _root; void build_(const std::vector<Pair>& nodes) { for (const auto& pair : nodes) { Insert(pair); } } void build_(std::vector<Pair>&& nodes) { for (Pair& pair : nodes) { Insert(std::move(pair)); } } void destroy_(TreeNode* node) { if (node) { destroy_(node->_left); destroy_(node->_right); delete node; node = nullptr; } } TreeNode*& search_(TreeNode*& node, K key) const { if (!node || key == node->_pair.first) { return node; } if (key < node->_pair.first) { return search_(node->_left, key); } return search_(node->_right, key); } void insert_(TreeNode*& node, const Pair& pair) { if (!node) { node = new TreeNode(pair); return; } auto key = pair.first; if (key == node->_pair.first) { node->_pair = pair; } else if (key < node->_pair.first) { insert_(node->_left, pair); } else { insert_(node->_right, pair); } } TreeNode*& go_to_max_(TreeNode*& node) { while (node->_right) { node = node->_right; } return node; } TreeNode*& go_to_min_(TreeNode*& node) { while (node->_left) { node = node->_left; } return node; } void delete_(TreeNode*& node, K key) { auto& target = search_(node, key); if (!target) { return; } if (!target->_left && !target->_right) { delete target; target = nullptr; return; } if (!target->_left) { TreeNode* temp = target->_right; delete target; target = temp; return; } if (!target->_right) { TreeNode* temp = target->_left; delete target; target = temp; return; } auto& max_in_left = go_to_max_(target->_left); target->_pair = max_in_left->_pair; // 1. 常规的递归，把整个左子树当做新的树 // delete_(target->_left, max_in_left->_pair.first); // 2. 直接传入 max_in_left 即可 // delete_(max_in_left, max_in_left->_pair.first); // 3. 实际上不需要递归，因为 max_in_left 是左边最大的值，一定没有右子树 TreeNode* temp = max_in_left->_left; delete max_in_left; max_in_left = temp; // 我开始时候的代码（有误）： // auto& max_in_left = go_to_max_(node->_left); // 应该是 // current->_left current->_pair = max_in_left->_pair; delete // (max_in_left); max_in_left = nullptr; // 第三种和我开始时候的逻辑类似 // 但我当时忘了保留 max_in_left 的左子树（如果存在） } static void normal_print_func_(const Pair& pair) { std::cout << pair.second << " | "; } void in_order_(TreeNode* node, std::function<void(const Pair&)> func) { if (!node) { return; } in_order_(node->_left, func); func(node->_pair); in_order_(node->_right, func); } public: PairBSTree() : _root(nullptr) {} PairBSTree(const std::vector<Pair>& pairs) : _root(nullptr) { build_(pairs); } PairBSTree(std::vector<Pair>&& pairs) : _root(nullptr) { build_(std::move(pairs)); } ~PairBSTree() { destroy_(_root); } std::optional<V> Search(K key) { auto node = search_(_root, key); if (!node) { return std::nullopt; } return node->_pair.second; } void Insert(const Pair& pair) { insert_(_root, pair); } void Delete(K key) { delete_(_root, key); } void InOrder(std::function<void(Pair)> func = normal_print_func_) { in_order_(_root, func); } [[nodiscard]] size_t Size() { size_t size = 0; InOrder([&amp;size](std::pair<K, V>) { ++size; }); return size; } [[nodiscard]] V Max() { auto temp = _root; go_to_max_(temp); return temp->_pair.second; } [[nodiscard]] V Min() { auto temp = _root; go_to_min_(temp); return temp->_pair.second; } }; int main(void) { std::vector<std::pair<int, std::string>> pairs = { {2, "Bob"}, {9, "Jack"}, {4, "Lucy"}, {23, "Evan"}, {3, "Gorge"}, {12, "Lily"}, {15, "Mono"}, {90, "Rick"}, {14, "Lance"}, {76, "Molly"}, {24, "Stan"}, {11, "Scot"}, {54, "Mint"}, {37, "Biance"}, {35, "Cower"}, {1, "Brick"}, }; PairBSTree tree(pairs); std::cout << "Name of 9: " << tree.Search(9).value_or("nothing") << &#39;\n&#39;; std::cout << "Size: " << tree.Size() << &#39;\n&#39;; // std::cout << "Min: " << tree.Min() << &#39;\n&#39;; // std::cout << "Max: " << tree.Max() << &#39;\n&#39;; tree.InOrder(); std::cout << &#39;\n&#39;; tree.Delete(15); std::cout << "Size: " << tree.Size() << &#39;\n&#39;; tree.InOrder(); std::cout << &#39;\n&#39;; std::vector<std::string> names_in_order; tree.InOrder([&amp;names_in_order](std::pair<int, std::string> pair) { std::cout << pair.second << " -- "; names_in_order.push_back(pair.second); }); std::cout << std::endl; return 0; }'><meta itemprop=datePublished content="2025-01-21T12:05:47+08:00"><meta itemprop=dateModified content="2025-01-21T12:05:47+08:00"><meta itemprop=wordCount content="950"><meta itemprop=keywords content="Cpp,Morden Cpp,Template,Data Structure"><meta name=twitter:card content="summary"><meta name=twitter:title content="写个相对现代的 C++ 二叉搜索树"><meta name=twitter:description content='1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #include <functional> #include <iostream> #include <optional> #include <string> #include <vector> template <typename T> concept Comparable = requires(T a, T b) { { a < b } -> std::convertible_to<bool>; { a > b } -> std::convertible_to<bool>; { a == b } -> std::convertible_to<bool>; }; template <typename T> concept Streamable = requires(T a, std::ostream& os) { { os << a } -> std::same_as<std::ostream&>; }; template <Comparable K, Streamable V> class PairBSTree { private: using Pair = std::pair<K, V>; struct TreeNode { Pair _pair; TreeNode* _left; TreeNode* _right; TreeNode() = default; TreeNode(const Pair& pair) : _pair(pair), _left(nullptr), _right(nullptr) {} TreeNode(Pair&& pair) : _pair(std::move(pair)), _left(nullptr), _right(nullptr) {} ~TreeNode() = default; }; TreeNode* _root; void build_(const std::vector<Pair>& nodes) { for (const auto& pair : nodes) { Insert(pair); } } void build_(std::vector<Pair>&& nodes) { for (Pair& pair : nodes) { Insert(std::move(pair)); } } void destroy_(TreeNode* node) { if (node) { destroy_(node->_left); destroy_(node->_right); delete node; node = nullptr; } } TreeNode*& search_(TreeNode*& node, K key) const { if (!node || key == node->_pair.first) { return node; } if (key < node->_pair.first) { return search_(node->_left, key); } return search_(node->_right, key); } void insert_(TreeNode*& node, const Pair& pair) { if (!node) { node = new TreeNode(pair); return; } auto key = pair.first; if (key == node->_pair.first) { node->_pair = pair; } else if (key < node->_pair.first) { insert_(node->_left, pair); } else { insert_(node->_right, pair); } } TreeNode*& go_to_max_(TreeNode*& node) { while (node->_right) { node = node->_right; } return node; } TreeNode*& go_to_min_(TreeNode*& node) { while (node->_left) { node = node->_left; } return node; } void delete_(TreeNode*& node, K key) { auto& target = search_(node, key); if (!target) { return; } if (!target->_left && !target->_right) { delete target; target = nullptr; return; } if (!target->_left) { TreeNode* temp = target->_right; delete target; target = temp; return; } if (!target->_right) { TreeNode* temp = target->_left; delete target; target = temp; return; } auto& max_in_left = go_to_max_(target->_left); target->_pair = max_in_left->_pair; // 1. 常规的递归，把整个左子树当做新的树 // delete_(target->_left, max_in_left->_pair.first); // 2. 直接传入 max_in_left 即可 // delete_(max_in_left, max_in_left->_pair.first); // 3. 实际上不需要递归，因为 max_in_left 是左边最大的值，一定没有右子树 TreeNode* temp = max_in_left->_left; delete max_in_left; max_in_left = temp; // 我开始时候的代码（有误）： // auto& max_in_left = go_to_max_(node->_left); // 应该是 // current->_left current->_pair = max_in_left->_pair; delete // (max_in_left); max_in_left = nullptr; // 第三种和我开始时候的逻辑类似 // 但我当时忘了保留 max_in_left 的左子树（如果存在） } static void normal_print_func_(const Pair& pair) { std::cout << pair.second << " | "; } void in_order_(TreeNode* node, std::function<void(const Pair&)> func) { if (!node) { return; } in_order_(node->_left, func); func(node->_pair); in_order_(node->_right, func); } public: PairBSTree() : _root(nullptr) {} PairBSTree(const std::vector<Pair>& pairs) : _root(nullptr) { build_(pairs); } PairBSTree(std::vector<Pair>&& pairs) : _root(nullptr) { build_(std::move(pairs)); } ~PairBSTree() { destroy_(_root); } std::optional<V> Search(K key) { auto node = search_(_root, key); if (!node) { return std::nullopt; } return node->_pair.second; } void Insert(const Pair& pair) { insert_(_root, pair); } void Delete(K key) { delete_(_root, key); } void InOrder(std::function<void(Pair)> func = normal_print_func_) { in_order_(_root, func); } [[nodiscard]] size_t Size() { size_t size = 0; InOrder([&amp;size](std::pair<K, V>) { ++size; }); return size; } [[nodiscard]] V Max() { auto temp = _root; go_to_max_(temp); return temp->_pair.second; } [[nodiscard]] V Min() { auto temp = _root; go_to_min_(temp); return temp->_pair.second; } }; int main(void) { std::vector<std::pair<int, std::string>> pairs = { {2, "Bob"}, {9, "Jack"}, {4, "Lucy"}, {23, "Evan"}, {3, "Gorge"}, {12, "Lily"}, {15, "Mono"}, {90, "Rick"}, {14, "Lance"}, {76, "Molly"}, {24, "Stan"}, {11, "Scot"}, {54, "Mint"}, {37, "Biance"}, {35, "Cower"}, {1, "Brick"}, }; PairBSTree tree(pairs); std::cout << "Name of 9: " << tree.Search(9).value_or("nothing") << &#39;\n&#39;; std::cout << "Size: " << tree.Size() << &#39;\n&#39;; // std::cout << "Min: " << tree.Min() << &#39;\n&#39;; // std::cout << "Max: " << tree.Max() << &#39;\n&#39;; tree.InOrder(); std::cout << &#39;\n&#39;; tree.Delete(15); std::cout << "Size: " << tree.Size() << &#39;\n&#39;; tree.InOrder(); std::cout << &#39;\n&#39;; std::vector<std::string> names_in_order; tree.InOrder([&amp;names_in_order](std::pair<int, std::string> pair) { std::cout << pair.second << " -- "; names_in_order.push_back(pair.second); }); std::cout << std::endl; return 0; }'><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Horeb</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Horeb</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>写个相对现代的 C++ 二叉搜索树</h1><div class=post-meta><span class=post-time>2025-01-21</span><div class=post-category><a href=/categories/cpp/>cpp</a></div><span class=more-meta>950 words </span><span class=more-meta>2 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents></nav></div></div><div class=post-content><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;functional&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;optional&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>concept</span> <span class=n>Comparable</span> <span class=o>=</span> <span class=k>requires</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>b</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>convertible_to</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>convertible_to</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>a</span> <span class=o>==</span> <span class=n>b</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>convertible_to</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>concept</span> <span class=n>Streamable</span> <span class=o>=</span> <span class=k>requires</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>same_as</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=n>Comparable</span> <span class=n>K</span><span class=p>,</span> <span class=n>Streamable</span> <span class=n>V</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PairBSTree</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>Pair</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>TreeNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Pair</span> <span class=n>_pair</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span><span class=o>*</span> <span class=n>_left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span><span class=o>*</span> <span class=n>_right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span><span class=p>(</span><span class=k>const</span> <span class=n>Pair</span><span class=o>&amp;</span> <span class=n>pair</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>:</span> <span class=n>_pair</span><span class=p>(</span><span class=n>pair</span><span class=p>),</span> <span class=n>_left</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>_right</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span><span class=p>(</span><span class=n>Pair</span><span class=o>&amp;&amp;</span> <span class=n>pair</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>:</span> <span class=n>_pair</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>pair</span><span class=p>)),</span> <span class=n>_left</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>_right</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=o>~</span><span class=n>TreeNode</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*</span> <span class=n>_root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>build_</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Pair</span><span class=o>&gt;&amp;</span> <span class=n>nodes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>pair</span> <span class=p>:</span> <span class=n>nodes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Insert</span><span class=p>(</span><span class=n>pair</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>build_</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Pair</span><span class=o>&gt;&amp;&amp;</span> <span class=n>nodes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>Pair</span><span class=o>&amp;</span> <span class=nl>pair</span> <span class=p>:</span> <span class=n>nodes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Insert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>pair</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>destroy_</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>destroy_</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>destroy_</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>delete</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*&amp;</span> <span class=n>search_</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*&amp;</span> <span class=n>node</span><span class=p>,</span> <span class=n>K</span> <span class=n>key</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>node</span> <span class=o>||</span> <span class=n>key</span> <span class=o>==</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>_pair</span><span class=p>.</span><span class=n>first</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>_pair</span><span class=p>.</span><span class=n>first</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nf>search_</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>search_</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_right</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>insert_</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*&amp;</span> <span class=n>node</span><span class=p>,</span> <span class=k>const</span> <span class=n>Pair</span><span class=o>&amp;</span> <span class=n>pair</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TreeNode</span><span class=p>(</span><span class=n>pair</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>key</span> <span class=o>=</span> <span class=n>pair</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>key</span> <span class=o>==</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>_pair</span><span class=p>.</span><span class=n>first</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=o>-&gt;</span><span class=n>_pair</span> <span class=o>=</span> <span class=n>pair</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>_pair</span><span class=p>.</span><span class=n>first</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>insert_</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>,</span> <span class=n>pair</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>insert_</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_right</span><span class=p>,</span> <span class=n>pair</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*&amp;</span> <span class=n>go_to_max_</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*&amp;</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>_right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*&amp;</span> <span class=n>go_to_min_</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*&amp;</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>delete_</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*&amp;</span> <span class=n>node</span><span class=p>,</span> <span class=n>K</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span><span class=o>&amp;</span> <span class=n>target</span> <span class=o>=</span> <span class=n>search_</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>target</span><span class=o>-&gt;</span><span class=n>_left</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>target</span><span class=o>-&gt;</span><span class=n>_right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>delete</span> <span class=n>target</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>target</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>target</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>TreeNode</span><span class=o>*</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>target</span><span class=o>-&gt;</span><span class=n>_right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>delete</span> <span class=n>target</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>target</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>target</span><span class=o>-&gt;</span><span class=n>_right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>TreeNode</span><span class=o>*</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>target</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>delete</span> <span class=n>target</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>target</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span><span class=o>&amp;</span> <span class=n>max_in_left</span> <span class=o>=</span> <span class=n>go_to_max_</span><span class=p>(</span><span class=n>target</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>target</span><span class=o>-&gt;</span><span class=n>_pair</span> <span class=o>=</span> <span class=n>max_in_left</span><span class=o>-&gt;</span><span class=n>_pair</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 1. 常规的递归，把整个左子树当做新的树
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// delete_(target-&gt;_left, max_in_left-&gt;_pair.first);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 2. 直接传入 max_in_left 即可
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// delete_(max_in_left, max_in_left-&gt;_pair.first);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 3. 实际上不需要递归，因为 max_in_left 是左边最大的值，一定没有右子树
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>TreeNode</span><span class=o>*</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>max_in_left</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>max_in_left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>max_in_left</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 我开始时候的代码（有误）：
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// auto&amp; max_in_left = go_to_max_(node-&gt;_left);  // 应该是
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// current-&gt;_left current-&gt;_pair = max_in_left-&gt;_pair; delete
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// (max_in_left); max_in_left = nullptr;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 第三种和我开始时候的逻辑类似
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 但我当时忘了保留 max_in_left 的左子树（如果存在）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>void</span> <span class=nf>normal_print_func_</span><span class=p>(</span><span class=k>const</span> <span class=n>Pair</span><span class=o>&amp;</span> <span class=n>pair</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pair</span><span class=p>.</span><span class=n>second</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; | &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>in_order_</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>node</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>(</span><span class=k>const</span> <span class=n>Pair</span><span class=o>&amp;</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>func</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>in_order_</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_left</span><span class=p>,</span> <span class=n>func</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>func</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_pair</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>in_order_</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>_right</span><span class=p>,</span> <span class=n>func</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>PairBSTree</span><span class=p>()</span> <span class=o>:</span> <span class=n>_root</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PairBSTree</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Pair</span><span class=o>&gt;&amp;</span> <span class=n>pairs</span><span class=p>)</span> <span class=o>:</span> <span class=n>_root</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>build_</span><span class=p>(</span><span class=n>pairs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PairBSTree</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Pair</span><span class=o>&gt;&amp;&amp;</span> <span class=n>pairs</span><span class=p>)</span> <span class=o>:</span> <span class=n>_root</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>build_</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>pairs</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>PairBSTree</span><span class=p>()</span> <span class=p>{</span> <span class=n>destroy_</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>optional</span><span class=o>&lt;</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>Search</span><span class=p>(</span><span class=n>K</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>node</span> <span class=o>=</span> <span class=n>search_</span><span class=p>(</span><span class=n>_root</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>nullopt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>_pair</span><span class=p>.</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Insert</span><span class=p>(</span><span class=k>const</span> <span class=n>Pair</span><span class=o>&amp;</span> <span class=n>pair</span><span class=p>)</span> <span class=p>{</span> <span class=n>insert_</span><span class=p>(</span><span class=n>_root</span><span class=p>,</span> <span class=n>pair</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Delete</span><span class=p>(</span><span class=n>K</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span> <span class=n>delete_</span><span class=p>(</span><span class=n>_root</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InOrder</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>(</span><span class=n>Pair</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>func</span> <span class=o>=</span> <span class=n>normal_print_func_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>in_order_</span><span class=p>(</span><span class=n>_root</span><span class=p>,</span> <span class=n>func</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=na>[[nodiscard]]</span> <span class=n>size_t</span> <span class=n>Size</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>InOrder</span><span class=p>([</span><span class=o>&amp;</span><span class=n>size</span><span class=p>](</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span> <span class=o>++</span><span class=n>size</span><span class=p>;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=na>[[nodiscard]]</span> <span class=n>V</span> <span class=n>Max</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>_root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>go_to_max_</span><span class=p>(</span><span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>_pair</span><span class=p>.</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=na>[[nodiscard]]</span> <span class=n>V</span> <span class=n>Min</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>_root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>go_to_min_</span><span class=p>(</span><span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>_pair</span><span class=p>.</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&gt;</span> <span class=n>pairs</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;Bob&#34;</span><span class=p>},</span>    <span class=p>{</span><span class=mi>9</span><span class=p>,</span> <span class=s>&#34;Jack&#34;</span><span class=p>},</span>    <span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=s>&#34;Lucy&#34;</span><span class=p>},</span>   <span class=p>{</span><span class=mi>23</span><span class=p>,</span> <span class=s>&#34;Evan&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;Gorge&#34;</span><span class=p>},</span>  <span class=p>{</span><span class=mi>12</span><span class=p>,</span> <span class=s>&#34;Lily&#34;</span><span class=p>},</span>   <span class=p>{</span><span class=mi>15</span><span class=p>,</span> <span class=s>&#34;Mono&#34;</span><span class=p>},</span>  <span class=p>{</span><span class=mi>90</span><span class=p>,</span> <span class=s>&#34;Rick&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>14</span><span class=p>,</span> <span class=s>&#34;Lance&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>76</span><span class=p>,</span> <span class=s>&#34;Molly&#34;</span><span class=p>},</span>  <span class=p>{</span><span class=mi>24</span><span class=p>,</span> <span class=s>&#34;Stan&#34;</span><span class=p>},</span>  <span class=p>{</span><span class=mi>11</span><span class=p>,</span> <span class=s>&#34;Scot&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>54</span><span class=p>,</span> <span class=s>&#34;Mint&#34;</span><span class=p>},</span>  <span class=p>{</span><span class=mi>37</span><span class=p>,</span> <span class=s>&#34;Biance&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>35</span><span class=p>,</span> <span class=s>&#34;Cower&#34;</span><span class=p>},</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;Brick&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PairBSTree</span> <span class=n>tree</span><span class=p>(</span><span class=n>pairs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Name of 9: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>tree</span><span class=p>.</span><span class=n>Search</span><span class=p>(</span><span class=mi>9</span><span class=p>).</span><span class=n>value_or</span><span class=p>(</span><span class=s>&#34;nothing&#34;</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>tree</span><span class=p>.</span><span class=n>Size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// std::cout &lt;&lt; &#34;Min: &#34; &lt;&lt; tree.Min() &lt;&lt; &#39;\n&#39;;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// std::cout &lt;&lt; &#34;Max: &#34; &lt;&lt; tree.Max() &lt;&lt; &#39;\n&#39;;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=p>.</span><span class=n>InOrder</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=p>.</span><span class=n>Delete</span><span class=p>(</span><span class=mi>15</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>tree</span><span class=p>.</span><span class=n>Size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=p>.</span><span class=n>InOrder</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>names_in_order</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=p>.</span><span class=n>InOrder</span><span class=p>([</span><span class=o>&amp;</span><span class=n>names_in_order</span><span class=p>](</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>pair</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pair</span><span class=p>.</span><span class=n>second</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; -- &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>names_in_order</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>pair</span><span class=p>.</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>JekYUlll</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2025-01-21</span></p><p class=copyright-item><span class=item-title>Markdown</span>
<span class=item-content><a class=link-to-markdown href=https://jekyulll.github.io/post/cpp-%E5%86%99%E4%B8%AA%E7%9B%B8%E5%AF%B9%E7%8E%B0%E4%BB%A3%E7%9A%84-c++-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/index.md target=_blank>The Markdown version »</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp/>cpp</a>
<a href=/tags/morden-cpp/>morden cpp</a>
<a href=/tags/template/>template</a>
<a href=/tags/data-structure/>data structure</a></div><nav class=post-nav><a class=prev href=/post/cpp-%E6%A3%80%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9A%84%E5%AD%90%E4%B8%B2/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">检查字符串是否是另一个的子串</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/post/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/><span class="next-text nav-default">C++ std::function 之脱裤子放屁的优化</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:jekyulll@gmail.com class="iconfont icon-email" title=email></a><a href=https://github.com/JekYUlll class="iconfont icon-github" title=github></a><a href=https://www.zhihu.com/people/yu-bei-28-33 class="iconfont icon-zhihu" title=zhihu></a><a href=https://space.bilibili.com/11060371 class="iconfont icon-bilibili" title=bilibili></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span><span class=copyright-year>&copy;
2024 -
2025<span class=heart><i class="iconfont icon-heart"></i></span><span></span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6473FXND4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q6473FXND4")}</script></body></html>