<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="JekYUlll"><meta name=description content="在 C++ 中，当函数返回一个对象时，编译器通常需要进行对象的拷贝或移动操作。例如：
SomeClass createObject() { SomeClass obj; // 设置 obj 的一些成员 return obj; // 返回一个对象 } 在没有优化的情况下，obj 被返回时，编译器可能会执行一次拷贝构造或移动构造操作，甚至可能是两次（先拷贝到临时对象，再从临时对象拷贝到目标变量）。这些额外的拷贝或移动操作会导致性能下降。
为了减少这种不必要的开销，现代 C++ 编译器通常会进行优化，减少返回值时的拷贝或移动，使用如 RVO 和 NRVO 的优化策略。
1. RVO（Return Value Optimization，返回值优化） RVO（Return Value Optimization，返回值优化），编译器可以直接在目标变量的位置构造返回值，减少不必要的对象拷贝和内存开销。
SomeClass createObject() { SomeClass obj; // 局部对象 return obj; // 返回该对象 } 在没有优化的情况下，obj 被返回时，编译器可能会做两次操作：
将 obj 拷贝或移动到一个临时对象中。 将临时对象拷贝或移动到调用者的目标变量。 RVO 的核心思想是，在函数返回临时对象时，编译器可以直接将返回值构造到调用者的接收变量中，而无需通过中间的临时对象进行拷贝或移动。
int main() { SomeClass obj = createObject(); // RVO 优化将直接构造在 obj 中 } RVO 只适用于临时对象返回的场景，对于具名对象（有名称的局部对象），编译器一般不能直接应用 RVO。返回具名对象时，编译器会尝试应用 NRVO（Named Return Value Optimization，命名返回值优化），以减少不必要的拷贝或移动。
SomeClass createObject() { SomeClass obj; // 具名局部变量 return obj; // 这里不能使用 RVO } 编译器行为：
"><meta name=keywords content="homepage,blog,cpp,compiler"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://jekyulll.github.io/post/cpp-c++-%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/><title>C++ 编译器返回值优化 :: Hello Friend NG — A simple theme for Hugo
</title><link rel=stylesheet href=/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css integrity="sha256-JEGDzeGjjgsI+CwReRGBKI+arBzJYYzW9OnncQxXaLo=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="C++ 编译器返回值优化"><meta itemprop=description content="在 C++ 中，当函数返回一个对象时，编译器通常需要进行对象的拷贝或移动操作。例如：
SomeClass createObject() { SomeClass obj; // 设置 obj 的一些成员 return obj; // 返回一个对象 } 在没有优化的情况下，obj 被返回时，编译器可能会执行一次拷贝构造或移动构造操作，甚至可能是两次（先拷贝到临时对象，再从临时对象拷贝到目标变量）。这些额外的拷贝或移动操作会导致性能下降。
为了减少这种不必要的开销，现代 C++ 编译器通常会进行优化，减少返回值时的拷贝或移动，使用如 RVO 和 NRVO 的优化策略。
1. RVO（Return Value Optimization，返回值优化） RVO（Return Value Optimization，返回值优化），编译器可以直接在目标变量的位置构造返回值，减少不必要的对象拷贝和内存开销。
SomeClass createObject() { SomeClass obj; // 局部对象 return obj; // 返回该对象 } 在没有优化的情况下，obj 被返回时，编译器可能会做两次操作：
将 obj 拷贝或移动到一个临时对象中。 将临时对象拷贝或移动到调用者的目标变量。 RVO 的核心思想是，在函数返回临时对象时，编译器可以直接将返回值构造到调用者的接收变量中，而无需通过中间的临时对象进行拷贝或移动。
int main() { SomeClass obj = createObject(); // RVO 优化将直接构造在 obj 中 } RVO 只适用于临时对象返回的场景，对于具名对象（有名称的局部对象），编译器一般不能直接应用 RVO。返回具名对象时，编译器会尝试应用 NRVO（Named Return Value Optimization，命名返回值优化），以减少不必要的拷贝或移动。
SomeClass createObject() { SomeClass obj; // 具名局部变量 return obj; // 这里不能使用 RVO } 编译器行为："><meta itemprop=datePublished content="2024-12-23T08:42:29+08:00"><meta itemprop=dateModified content="2024-12-23T08:42:29+08:00"><meta itemprop=wordCount content="172"><meta itemprop=image content="https://jekyulll.github.io/"><meta itemprop=keywords content="Cpp,Compiler"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jekyulll.github.io/"><meta name=twitter:title content="C++ 编译器返回值优化"><meta name=twitter:description content="在 C++ 中，当函数返回一个对象时，编译器通常需要进行对象的拷贝或移动操作。例如：
SomeClass createObject() { SomeClass obj; // 设置 obj 的一些成员 return obj; // 返回一个对象 } 在没有优化的情况下，obj 被返回时，编译器可能会执行一次拷贝构造或移动构造操作，甚至可能是两次（先拷贝到临时对象，再从临时对象拷贝到目标变量）。这些额外的拷贝或移动操作会导致性能下降。
为了减少这种不必要的开销，现代 C++ 编译器通常会进行优化，减少返回值时的拷贝或移动，使用如 RVO 和 NRVO 的优化策略。
1. RVO（Return Value Optimization，返回值优化） RVO（Return Value Optimization，返回值优化），编译器可以直接在目标变量的位置构造返回值，减少不必要的对象拷贝和内存开销。
SomeClass createObject() { SomeClass obj; // 局部对象 return obj; // 返回该对象 } 在没有优化的情况下，obj 被返回时，编译器可能会做两次操作：
将 obj 拷贝或移动到一个临时对象中。 将临时对象拷贝或移动到调用者的目标变量。 RVO 的核心思想是，在函数返回临时对象时，编译器可以直接将返回值构造到调用者的接收变量中，而无需通过中间的临时对象进行拷贝或移动。
int main() { SomeClass obj = createObject(); // RVO 优化将直接构造在 obj 中 } RVO 只适用于临时对象返回的场景，对于具名对象（有名称的局部对象），编译器一般不能直接应用 RVO。返回具名对象时，编译器会尝试应用 NRVO（Named Return Value Optimization，命名返回值优化），以减少不必要的拷贝或移动。
SomeClass createObject() { SomeClass obj; // 具名局部变量 return obj; // 这里不能使用 RVO } 编译器行为："><meta property="og:url" content="https://jekyulll.github.io/post/cpp-c++-%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/"><meta property="og:site_name" content="Hello Friend NG"><meta property="og:title" content="C++ 编译器返回值优化"><meta property="og:description" content="在 C++ 中，当函数返回一个对象时，编译器通常需要进行对象的拷贝或移动操作。例如：
SomeClass createObject() { SomeClass obj; // 设置 obj 的一些成员 return obj; // 返回一个对象 } 在没有优化的情况下，obj 被返回时，编译器可能会执行一次拷贝构造或移动构造操作，甚至可能是两次（先拷贝到临时对象，再从临时对象拷贝到目标变量）。这些额外的拷贝或移动操作会导致性能下降。
为了减少这种不必要的开销，现代 C++ 编译器通常会进行优化，减少返回值时的拷贝或移动，使用如 RVO 和 NRVO 的优化策略。
1. RVO（Return Value Optimization，返回值优化） RVO（Return Value Optimization，返回值优化），编译器可以直接在目标变量的位置构造返回值，减少不必要的对象拷贝和内存开销。
SomeClass createObject() { SomeClass obj; // 局部对象 return obj; // 返回该对象 } 在没有优化的情况下，obj 被返回时，编译器可能会做两次操作：
将 obj 拷贝或移动到一个临时对象中。 将临时对象拷贝或移动到调用者的目标变量。 RVO 的核心思想是，在函数返回临时对象时，编译器可以直接将返回值构造到调用者的接收变量中，而无需通过中间的临时对象进行拷贝或移动。
int main() { SomeClass obj = createObject(); // RVO 优化将直接构造在 obj 中 } RVO 只适用于临时对象返回的场景，对于具名对象（有名称的局部对象），编译器一般不能直接应用 RVO。返回具名对象时，编译器会尝试应用 NRVO（Named Return Value Optimization，命名返回值优化），以减少不必要的拷贝或移动。
SomeClass createObject() { SomeClass obj; // 具名局部变量 return obj; // 这里不能使用 RVO } 编译器行为："><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-12-23T08:42:29+08:00"><meta property="article:modified_time" content="2024-12-23T08:42:29+08:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Compiler"><meta property="og:image" content="https://jekyulll.github.io/"><meta property="article:section" content="cpp"><meta property="article:published_time" content="2024-12-23 08:42:29 +0800 +0800"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello friend ng</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>Blog</a></li><ul class=submenu><li class=dropdown><a href=javascript:void(0) class=dropbtn>en</a><div class=dropdown-content></div></li></ul></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://jekyulll.github.io/post/cpp-c++-%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/>C++ 编译器返回值优化</a></h2><div class=post-content><p>在 C++ 中，当函数返回一个对象时，编译器通常需要进行对象的拷贝或移动操作。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>SomeClass <span style=color:#a6e22e>createObject</span>() {
</span></span><span style=display:flex><span>    SomeClass obj;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置 obj 的一些成员
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> obj;  <span style=color:#75715e>// 返回一个对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>在没有优化的情况下，<code>obj</code> 被返回时，编译器可能会执行一次拷贝构造或移动构造操作，甚至可能是两次（先拷贝到临时对象，再从临时对象拷贝到目标变量）。这些额外的拷贝或移动操作会导致性能下降。</p><p>为了减少这种不必要的开销，现代 C++ 编译器通常会进行优化，减少返回值时的拷贝或移动，使用如 <strong>RVO</strong> 和 <strong>NRVO</strong> 的优化策略。</p><h3 id=1-rvoreturn-value-optimization返回值优化>1. RVO（Return Value Optimization，返回值优化）</h3><p>RVO（Return Value Optimization，返回值优化），编译器可以直接在目标变量的位置构造返回值，减少不必要的对象拷贝和内存开销。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>SomeClass <span style=color:#a6e22e>createObject</span>() {
</span></span><span style=display:flex><span>    SomeClass obj;   <span style=color:#75715e>// 局部对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> obj;      <span style=color:#75715e>// 返回该对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>在没有优化的情况下，<code>obj</code> 被返回时，编译器可能会做两次操作：</p><ol><li>将 <code>obj</code> 拷贝或移动到一个临时对象中。</li><li>将临时对象拷贝或移动到调用者的目标变量。</li></ol><p>RVO 的核心思想是，在函数返回临时对象时，编译器可以<u>直接将返回值构造到调用者的接收变量中</u>，而无需通过中间的临时对象进行拷贝或移动。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    SomeClass obj <span style=color:#f92672>=</span> createObject();  <span style=color:#75715e>// RVO 优化将直接构造在 obj 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>RVO 只适用于临时对象返回的场景，对于具名对象（有名称的局部对象），编译器一般不能直接应用 RVO。返回具名对象时，编译器会尝试应用 NRVO（Named Return Value Optimization，命名返回值优化），以减少不必要的拷贝或移动。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>SomeClass <span style=color:#a6e22e>createObject</span>() {
</span></span><span style=display:flex><span>    SomeClass obj;   <span style=color:#75715e>// 具名局部变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> obj;      <span style=color:#75715e>// 这里不能使用 RVO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>编译器行为：</p><ul><li><strong>GCC/Clang</strong>：启用优化选项（如 <code>-O2</code> 或 <code>-O3</code>）时，编译器会自动应用 RVO 来优化返回临时对象的代码。</li><li><strong>MSVC</strong>：在 Visual Studio 中，编译器会自动应用 RVO，并且它通常比 GCC 和 Clang 更早地进行这种优化。</li></ul><h3 id=2-nrvonamed-return-value-optimization命名返回值优化>2. NRVO（Named Return Value Optimization，命名返回值优化）</h3><p>NRVO 可以看作是 RVO 的一种扩展。<br>它仅在返回的是具名对象时有效。具体来说，当函数返回一个具名的局部变量时，NRVO 允许编译器直接将该局部变量的位置“转移”到调用者的接收变量中，而不需要进行拷贝或移动。</p><hr><h1 id=拓展>拓展</h1><p><a href=https://zhuanlan.zhihu.com/p/656372497>从函数中返回stl容器开销很大吗？</a></p><p>禁用 NRVO 优化的情况下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>X</span> {
</span></span><span style=display:flex><span>    X() { puts(<span style=color:#e6db74>&#34;X()&#34;</span>); }
</span></span><span style=display:flex><span>    X(<span style=color:#66d9ef>const</span> X<span style=color:#f92672>&amp;</span>) { puts(<span style=color:#e6db74>&#34;X(const X&amp;)&#34;</span>); }
</span></span><span style=display:flex><span>    X(X<span style=color:#f92672>&amp;&amp;</span>)<span style=color:#66d9ef>noexcept</span> { puts(<span style=color:#e6db74>&#34;X(X&amp;&amp;)&#34;</span>); }
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>X() {puts(<span style=color:#e6db74>&#34;~X()&#34;</span>);}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>X <span style=color:#a6e22e>func</span>() {
</span></span><span style=display:flex><span>    X x;
</span></span><span style=display:flex><span>    puts(<span style=color:#e6db74>&#34;-----------&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> result <span style=color:#f92672>=</span> func();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>X()
-----------
X(X&amp;&amp;)
~X()
X(X&amp;&amp;)
~X()
~X()
</code></pre><p>如果启用了 命名返回值优化（NRVO），编译器可以直接将 <code>x</code> 移动到返回值位置，而无需额外的构造操作。<br>由于 <code>x</code> 是一个左值，标准情况下会调用拷贝构造函数，但在返回时，由于是函数返回值（即返回局部变量），且需要将返回值传递给 <code>result</code>（通过移动语义优化），C++ 编译器通常会选择移动构造。</p></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://jekyulll.github.io/tags/cpp/>cpp</a></span>
<span class=tag><a href=https://jekyulll.github.io/tags/compiler/>compiler</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://jekyulll.github.io/categories/cpp/>cpp</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>