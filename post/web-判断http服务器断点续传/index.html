<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="JekYUlll"><meta name=description content='一、HTTP协议基础 HTTP协议通过Range请求实现断点续传：
客户端请求指定范围
客户端在请求头中携带Range字段，例如：
GET /file.zip HTTP/1.1 Range: bytes=500-1000 服务端响应部分内容
若支持范围请求，服务端返回状态码206 Partial Content及对应数据片段：
HTTP/1.1 206 Partial Content Content-Range: bytes 500-1000/5000 Content-Length: 501 完整性校验机制
通过ETag或Last-Modified头确保文件未变更，避免续传数据不一致。
二、Nginx静态资源断点续传 Nginx默认支持静态文件的断点续传。需要有以下配置：
server { location /static { root /data/files; # 文件存储路径 add_header Accept-Ranges bytes; # 声明支持字节范围请求 } } 验证方法：
使用curl检测响应头：
curl -I http://your-domain/static/large-file.iso 若输出包含Accept-Ranges: bytes与Content-Length，则表明支持续传。
三、Go实现 对于动态生成的文件（如需鉴权的资源），需手动处理Range请求。
package main import ( "fmt" "net/http" "os" "strconv" "strings" ) func handleDownload(w http.ResponseWriter, r *http.Request) { filePath := "/data/dynamic-file.bin" file, err := os.Open(filePath) if err != nil { http.Error(w, "File not found", http.StatusNotFound) return } defer file.Close() fileInfo, _ := file.Stat() fileSize := fileInfo.Size() w.Header().Set("Content-Length", strconv.FormatInt(fileSize, 10)) w.Header().Set("ETag", fmt.Sprintf("\"%x\"", fileInfo.ModTime().UnixNano())) rangeHeader := r.Header.Get("Range") if rangeHeader == "" { http.ServeContent(w, r, fileInfo.Name(), fileInfo.ModTime(), file) return } ranges := strings.Split(rangeHeader, "=")[1] parts := strings.Split(ranges, "-") start, _ := strconv.ParseInt(parts[0], 10, 64) end := fileSize - 1 if parts[1] != "" { end, _ = strconv.ParseInt(parts[1], 10, 64) } if start >= fileSize || end >= fileSize { http.Error(w, "Requested range not satisfiable", http.StatusRequestedRangeNotSatisfiable) return } w.Header().Set("Content-Range", fmt.Sprintf("bytes %d-%d/%d", start, end, fileSize)) w.Header().Set("Content-Length", strconv.FormatInt(end-start+1, 10)) w.WriteHeader(http.StatusPartialContent) file.Seek(start, 0) http.ServeContent(w, r, fileInfo.Name(), fileInfo.ModTime(), file) } func main() { http.HandleFunc("/download", handleDownload) http.ListenAndServe(":8080", nil) } • 解析Range请求头并验证范围有效性 • 使用Seek定位文件指针，返回部分内容 • 通过ETag实现文件一致性校验
'><meta name=keywords content="homepage,blog,go,web,backend"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://jekyulll.github.io/post/web-%E5%88%A4%E6%96%ADhttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/><title>实现服务端断点续传：Go与Nginx :: Hello Friend NG — A simple theme for Hugo
</title><link rel=stylesheet href=/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css integrity="sha256-JEGDzeGjjgsI+CwReRGBKI+arBzJYYzW9OnncQxXaLo=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="实现服务端断点续传：Go与Nginx"><meta itemprop=description content='一、HTTP协议基础 HTTP协议通过Range请求实现断点续传：
客户端请求指定范围
客户端在请求头中携带Range字段，例如：
GET /file.zip HTTP/1.1 Range: bytes=500-1000 服务端响应部分内容
若支持范围请求，服务端返回状态码206 Partial Content及对应数据片段：
HTTP/1.1 206 Partial Content Content-Range: bytes 500-1000/5000 Content-Length: 501 完整性校验机制
通过ETag或Last-Modified头确保文件未变更，避免续传数据不一致。
二、Nginx静态资源断点续传 Nginx默认支持静态文件的断点续传。需要有以下配置：
server { location /static { root /data/files; # 文件存储路径 add_header Accept-Ranges bytes; # 声明支持字节范围请求 } } 验证方法：
使用curl检测响应头：
curl -I http://your-domain/static/large-file.iso 若输出包含Accept-Ranges: bytes与Content-Length，则表明支持续传。
三、Go实现 对于动态生成的文件（如需鉴权的资源），需手动处理Range请求。
package main import ( "fmt" "net/http" "os" "strconv" "strings" ) func handleDownload(w http.ResponseWriter, r *http.Request) { filePath := "/data/dynamic-file.bin" file, err := os.Open(filePath) if err != nil { http.Error(w, "File not found", http.StatusNotFound) return } defer file.Close() fileInfo, _ := file.Stat() fileSize := fileInfo.Size() w.Header().Set("Content-Length", strconv.FormatInt(fileSize, 10)) w.Header().Set("ETag", fmt.Sprintf("\"%x\"", fileInfo.ModTime().UnixNano())) rangeHeader := r.Header.Get("Range") if rangeHeader == "" { http.ServeContent(w, r, fileInfo.Name(), fileInfo.ModTime(), file) return } ranges := strings.Split(rangeHeader, "=")[1] parts := strings.Split(ranges, "-") start, _ := strconv.ParseInt(parts[0], 10, 64) end := fileSize - 1 if parts[1] != "" { end, _ = strconv.ParseInt(parts[1], 10, 64) } if start >= fileSize || end >= fileSize { http.Error(w, "Requested range not satisfiable", http.StatusRequestedRangeNotSatisfiable) return } w.Header().Set("Content-Range", fmt.Sprintf("bytes %d-%d/%d", start, end, fileSize)) w.Header().Set("Content-Length", strconv.FormatInt(end-start+1, 10)) w.WriteHeader(http.StatusPartialContent) file.Seek(start, 0) http.ServeContent(w, r, fileInfo.Name(), fileInfo.ModTime(), file) } func main() { http.HandleFunc("/download", handleDownload) http.ListenAndServe(":8080", nil) } • 解析Range请求头并验证范围有效性 • 使用Seek定位文件指针，返回部分内容 • 通过ETag实现文件一致性校验'><meta itemprop=datePublished content="2025-04-23T12:05:47+08:00"><meta itemprop=dateModified content="2025-04-23T12:05:47+08:00"><meta itemprop=wordCount content="265"><meta itemprop=image content="https://jekyulll.github.io/"><meta itemprop=keywords content="Go,Web,Backend"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jekyulll.github.io/"><meta name=twitter:title content="实现服务端断点续传：Go与Nginx"><meta name=twitter:description content='一、HTTP协议基础 HTTP协议通过Range请求实现断点续传：
客户端请求指定范围
客户端在请求头中携带Range字段，例如：
GET /file.zip HTTP/1.1 Range: bytes=500-1000 服务端响应部分内容
若支持范围请求，服务端返回状态码206 Partial Content及对应数据片段：
HTTP/1.1 206 Partial Content Content-Range: bytes 500-1000/5000 Content-Length: 501 完整性校验机制
通过ETag或Last-Modified头确保文件未变更，避免续传数据不一致。
二、Nginx静态资源断点续传 Nginx默认支持静态文件的断点续传。需要有以下配置：
server { location /static { root /data/files; # 文件存储路径 add_header Accept-Ranges bytes; # 声明支持字节范围请求 } } 验证方法：
使用curl检测响应头：
curl -I http://your-domain/static/large-file.iso 若输出包含Accept-Ranges: bytes与Content-Length，则表明支持续传。
三、Go实现 对于动态生成的文件（如需鉴权的资源），需手动处理Range请求。
package main import ( "fmt" "net/http" "os" "strconv" "strings" ) func handleDownload(w http.ResponseWriter, r *http.Request) { filePath := "/data/dynamic-file.bin" file, err := os.Open(filePath) if err != nil { http.Error(w, "File not found", http.StatusNotFound) return } defer file.Close() fileInfo, _ := file.Stat() fileSize := fileInfo.Size() w.Header().Set("Content-Length", strconv.FormatInt(fileSize, 10)) w.Header().Set("ETag", fmt.Sprintf("\"%x\"", fileInfo.ModTime().UnixNano())) rangeHeader := r.Header.Get("Range") if rangeHeader == "" { http.ServeContent(w, r, fileInfo.Name(), fileInfo.ModTime(), file) return } ranges := strings.Split(rangeHeader, "=")[1] parts := strings.Split(ranges, "-") start, _ := strconv.ParseInt(parts[0], 10, 64) end := fileSize - 1 if parts[1] != "" { end, _ = strconv.ParseInt(parts[1], 10, 64) } if start >= fileSize || end >= fileSize { http.Error(w, "Requested range not satisfiable", http.StatusRequestedRangeNotSatisfiable) return } w.Header().Set("Content-Range", fmt.Sprintf("bytes %d-%d/%d", start, end, fileSize)) w.Header().Set("Content-Length", strconv.FormatInt(end-start+1, 10)) w.WriteHeader(http.StatusPartialContent) file.Seek(start, 0) http.ServeContent(w, r, fileInfo.Name(), fileInfo.ModTime(), file) } func main() { http.HandleFunc("/download", handleDownload) http.ListenAndServe(":8080", nil) } • 解析Range请求头并验证范围有效性 • 使用Seek定位文件指针，返回部分内容 • 通过ETag实现文件一致性校验'><meta property="og:url" content="https://jekyulll.github.io/post/web-%E5%88%A4%E6%96%ADhttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"><meta property="og:site_name" content="Hello Friend NG"><meta property="og:title" content="实现服务端断点续传：Go与Nginx"><meta property="og:description" content='一、HTTP协议基础 HTTP协议通过Range请求实现断点续传：
客户端请求指定范围
客户端在请求头中携带Range字段，例如：
GET /file.zip HTTP/1.1 Range: bytes=500-1000 服务端响应部分内容
若支持范围请求，服务端返回状态码206 Partial Content及对应数据片段：
HTTP/1.1 206 Partial Content Content-Range: bytes 500-1000/5000 Content-Length: 501 完整性校验机制
通过ETag或Last-Modified头确保文件未变更，避免续传数据不一致。
二、Nginx静态资源断点续传 Nginx默认支持静态文件的断点续传。需要有以下配置：
server { location /static { root /data/files; # 文件存储路径 add_header Accept-Ranges bytes; # 声明支持字节范围请求 } } 验证方法：
使用curl检测响应头：
curl -I http://your-domain/static/large-file.iso 若输出包含Accept-Ranges: bytes与Content-Length，则表明支持续传。
三、Go实现 对于动态生成的文件（如需鉴权的资源），需手动处理Range请求。
package main import ( "fmt" "net/http" "os" "strconv" "strings" ) func handleDownload(w http.ResponseWriter, r *http.Request) { filePath := "/data/dynamic-file.bin" file, err := os.Open(filePath) if err != nil { http.Error(w, "File not found", http.StatusNotFound) return } defer file.Close() fileInfo, _ := file.Stat() fileSize := fileInfo.Size() w.Header().Set("Content-Length", strconv.FormatInt(fileSize, 10)) w.Header().Set("ETag", fmt.Sprintf("\"%x\"", fileInfo.ModTime().UnixNano())) rangeHeader := r.Header.Get("Range") if rangeHeader == "" { http.ServeContent(w, r, fileInfo.Name(), fileInfo.ModTime(), file) return } ranges := strings.Split(rangeHeader, "=")[1] parts := strings.Split(ranges, "-") start, _ := strconv.ParseInt(parts[0], 10, 64) end := fileSize - 1 if parts[1] != "" { end, _ = strconv.ParseInt(parts[1], 10, 64) } if start >= fileSize || end >= fileSize { http.Error(w, "Requested range not satisfiable", http.StatusRequestedRangeNotSatisfiable) return } w.Header().Set("Content-Range", fmt.Sprintf("bytes %d-%d/%d", start, end, fileSize)) w.Header().Set("Content-Length", strconv.FormatInt(end-start+1, 10)) w.WriteHeader(http.StatusPartialContent) file.Seek(start, 0) http.ServeContent(w, r, fileInfo.Name(), fileInfo.ModTime(), file) } func main() { http.HandleFunc("/download", handleDownload) http.ListenAndServe(":8080", nil) } • 解析Range请求头并验证范围有效性 • 使用Seek定位文件指针，返回部分内容 • 通过ETag实现文件一致性校验'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-04-23T12:05:47+08:00"><meta property="article:modified_time" content="2025-04-23T12:05:47+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Web"><meta property="article:tag" content="Backend"><meta property="og:image" content="https://jekyulll.github.io/"><meta property="article:section" content="web"><meta property="article:published_time" content="2025-04-23 12:05:47 +0800 +0800"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello friend ng</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>Blog</a></li><ul class=submenu><li class=dropdown><a href=javascript:void(0) class=dropbtn>en</a><div class=dropdown-content></div></li></ul></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://jekyulll.github.io/post/web-%E5%88%A4%E6%96%ADhttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/>实现服务端断点续传：Go与Nginx</a></h2><div class=post-content><h3 id=一http协议基础>一、HTTP协议基础</h3><p>HTTP协议通过<strong>Range请求</strong>实现断点续传：</p><ol><li><p><strong>客户端请求指定范围</strong><br>客户端在请求头中携带<code>Range</code>字段，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#a6e22e>GET</span> /file.zip <span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span>
</span></span><span style=display:flex><span>Range<span style=color:#f92672>:</span> <span style=color:#ae81ff>bytes=500-1000</span>
</span></span></code></pre></div></li><li><p><strong>服务端响应部分内容</strong><br>若支持范围请求，服务端返回状态码<code>206 Partial Content</code>及对应数据片段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span> <span style=color:#ae81ff>206</span> <span style=color:#a6e22e>Partial Content</span>
</span></span><span style=display:flex><span>Content-Range<span style=color:#f92672>:</span> <span style=color:#ae81ff>bytes 500-1000/5000</span>
</span></span><span style=display:flex><span>Content-Length<span style=color:#f92672>:</span> <span style=color:#ae81ff>501</span>
</span></span></code></pre></div></li><li><p><strong>完整性校验机制</strong><br>通过<code>ETag</code>或<code>Last-Modified</code>头确保文件未变更，避免续传数据不一致。</p></li></ol><hr><h3 id=二nginx静态资源断点续传>二、Nginx静态资源断点续传</h3><p>Nginx默认支持静态文件的断点续传。需要有以下配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>server</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>location</span> <span style=color:#e6db74>/static</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>root</span> <span style=color:#e6db74>/data/files</span>;           <span style=color:#75715e># 文件存储路径
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>add_header</span> <span style=color:#e6db74>Accept-Ranges</span> <span style=color:#e6db74>bytes</span>;  <span style=color:#75715e># 声明支持字节范围请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>验证方法</strong>：<br>使用<code>curl</code>检测响应头：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -I http://your-domain/static/large-file.iso
</span></span></code></pre></div><p>若输出包含<code>Accept-Ranges: bytes</code>与<code>Content-Length</code>，则表明支持续传。</p><hr><h3 id=三go实现>三、Go实现</h3><p>对于动态生成的文件（如需鉴权的资源），需手动处理<code>Range</code>请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleDownload</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filePath</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;/data/dynamic-file.bin&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>filePath</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;File not found&#34;</span>, <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusNotFound</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fileInfo</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Stat</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fileSize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fileInfo</span>.<span style=color:#a6e22e>Size</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Length&#34;</span>, <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatInt</span>(<span style=color:#a6e22e>fileSize</span>, <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;ETag&#34;</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;\&#34;%x\&#34;&#34;</span>, <span style=color:#a6e22e>fileInfo</span>.<span style=color:#a6e22e>ModTime</span>().<span style=color:#a6e22e>UnixNano</span>()))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rangeHeader</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Header</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;Range&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rangeHeader</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ServeContent</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>fileInfo</span>.<span style=color:#a6e22e>Name</span>(), <span style=color:#a6e22e>fileInfo</span>.<span style=color:#a6e22e>ModTime</span>(), <span style=color:#a6e22e>file</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ranges</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>rangeHeader</span>, <span style=color:#e6db74>&#34;=&#34;</span>)[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>parts</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>ranges</span>, <span style=color:#e6db74>&#34;-&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>start</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>ParseInt</span>(<span style=color:#a6e22e>parts</span>[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>end</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fileSize</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>parts</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>end</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>ParseInt</span>(<span style=color:#a6e22e>parts</span>[<span style=color:#ae81ff>1</span>], <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>start</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>fileSize</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>end</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>fileSize</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Requested range not satisfiable&#34;</span>, <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusRequestedRangeNotSatisfiable</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Range&#34;</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;bytes %d-%d/%d&#34;</span>, <span style=color:#a6e22e>start</span>, <span style=color:#a6e22e>end</span>, <span style=color:#a6e22e>fileSize</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Length&#34;</span>, <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatInt</span>(<span style=color:#a6e22e>end</span><span style=color:#f92672>-</span><span style=color:#a6e22e>start</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusPartialContent</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Seek</span>(<span style=color:#a6e22e>start</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ServeContent</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>fileInfo</span>.<span style=color:#a6e22e>Name</span>(), <span style=color:#a6e22e>fileInfo</span>.<span style=color:#a6e22e>ModTime</span>(), <span style=color:#a6e22e>file</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/download&#34;</span>, <span style=color:#a6e22e>handleDownload</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>• 解析<code>Range</code>请求头并验证范围有效性
• 使用<code>Seek</code>定位文件指针，返回部分内容
• 通过<code>ETag</code>实现文件一致性校验</p><hr><h3 id=四客户端如何检测服务端是否支持>四、客户端如何检测服务端是否支持？</h3><p>可通过以下步骤判断：</p><ol><li><p><strong>发送HEAD请求</strong><br>获取响应头信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -I http://your-domain/file.zip
</span></span></code></pre></div></li><li><p><strong>检查关键头字段</strong><br>• <strong><code>Accept-Ranges: bytes</code></strong>：表明支持字节范围请求
• <strong><code>Content-Length</code></strong>：必须存在且为固定值（动态内容可能无法支持）
• <strong><code>ETag</code>或<code>Last-Modified</code></strong>：用于文件变更校验</p></li><li><p><strong>实验性范围请求测试</strong><br>发送带<code>Range</code>头的GET请求：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -H <span style=color:#e6db74>&#34;Range: bytes=0-100&#34;</span> http://your-domain/file.zip
</span></span></code></pre></div><p>若响应状态码为<code>206</code>且包含<code>Content-Range</code>头，则确认支持续传。</p></li></ol><hr><h3 id=五nginx反向代理go服务的注意事项>五、Nginx反向代理Go服务的注意事项</h3><p>当Go服务部署于Nginx后，需确保配置正确处理Range请求：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/go-download</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://go-backend:8080/download</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>proxy_set_header</span> <span style=color:#e6db74>Range</span> $http_range;    <span style=color:#75715e># 传递原始Range头
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>proxy_set_header</span> <span style=color:#e6db74>If-Range</span> $http_if_range;
</span></span><span style=display:flex><span>    <span style=color:#f92672>proxy_hide_header</span> <span style=color:#e6db74>Accept-Ranges</span>;      <span style=color:#75715e># 避免与后端冲突
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>proxy_http_version</span> <span style=color:#ae81ff>1</span><span style=color:#e6db74>.1</span>;               <span style=color:#75715e># 支持HTTP/1.1特性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>• 确认Nginx与Go服务对文件有读取权限
• 检查<code>Content-Length</code>是否被意外修改（如Gzip压缩）
• 使用<code>tcpdump</code>或Wireshark抓包验证请求头传递</p><hr><h3 id=六边界问题与优化建议>六、边界问题与优化建议</h3><ol><li><p><strong>多范围请求处理</strong><br>支持形如<code>Range: bytes=0-100,200-300</code>的请求需分段响应，可通过Go的<code>multipart/byteranges</code>实现。</p></li><li><p><strong>速率限制与防滥用</strong><br>Nginx配置限速：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/download</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>limit_rate</span> <span style=color:#ae81ff>1m</span>;  <span style=color:#75715e># 限制下载速度为1MB/s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li><li><p><strong>日志监控</strong><br>监控<code>206</code>状态码频率，识别异常续传行为。</p></li></ol></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://jekyulll.github.io/tags/go/>go</a></span>
<span class=tag><a href=https://jekyulll.github.io/tags/web/>web</a></span>
<span class=tag><a href=https://jekyulll.github.io/tags/backend/>backend</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://jekyulll.github.io/categories/web/>web</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>