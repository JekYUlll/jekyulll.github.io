<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="JekYUlll"><meta name=description content="看到一句话：
std::function 很强大，但是代价也很高，在创建函数对象的时候总是会有 new 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。
于是草草找一下资料，看看有没有隐藏的性能优化。
std::function 的实现 std::function 是一个可变参类模板，是一个通用的函数包装器（Polymorphic function wrapper）。
通过类型擦除（type erasure）机制，将具体类型的可调用对象封装到一个统一的接口中。
其实例可以存储、复制和调用任何可复制构造的可调用目标，包括普通函数、成员函数、类对象（重载了operator()的类的对象）、Lambda表达式等。是对C++现有的可调用实体的一种类型安全的包裹（相比而言，函数指针这种可调用实体，是类型不安全的）。 &ndash; STL源码分析之std::function
template<typename _Res, typename... _ArgTypes> class function<_Res(_ArgTypes...)> : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...> , private _Function_base { private: using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...); _Invoker_type _M_invoker; // ... }; std::function 的内部有两个部分：
一个指向实际存储区域的指针：存储实际的可调用对象（函数对象、lambda、函数指针等）。 一个接口表（vtable 等效机制）：存储操作函数（如调用函数、复制、销毁等）的地址。 其类型擦除通过接口表的方式实现，类似于虚函数机制，但它通常采用静态接口表和手动的动态分配来支持多种类型的可调用对象。
性能分析 关于std function和lambda function的性能调试 &ndash;法号桑菜。
Avoiding The Performance Hazzards of std::function。
There are two performance implications of using std::function that might surprise you:
When calling a std::function, it does a virtual function call. When assigning a lambda with significant captures to a std::function, it will do a dynamic memory allocation! 一是std::function 会使用虚函数调用，有开销。 二是将 lambda 赋给std::function的时候，如果捕获内容较多，会需要额外的动态内存分配。 第二点其实说的就是：
std::function 对小型的可调用对象会使用“小对象优化（Small Object Optimization, SOO）”，避免动态分配堆内存。但如果对象超过了实现中的小对象优化阈值，则会触发堆分配（new 操作）。
"><meta name=keywords content="homepage,blog,cpp,morden cpp"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://jekyulll.github.io/post/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/><title>C++ std::function 之脱裤子放屁的优化 :: Hello Friend NG — A simple theme for Hugo
</title><link rel=stylesheet href=/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css integrity="sha256-JEGDzeGjjgsI+CwReRGBKI+arBzJYYzW9OnncQxXaLo=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="C++ std::function 之脱裤子放屁的优化"><meta itemprop=description content="看到一句话：
std::function 很强大，但是代价也很高，在创建函数对象的时候总是会有 new 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。
于是草草找一下资料，看看有没有隐藏的性能优化。
std::function 的实现 std::function 是一个可变参类模板，是一个通用的函数包装器（Polymorphic function wrapper）。
通过类型擦除（type erasure）机制，将具体类型的可调用对象封装到一个统一的接口中。
其实例可以存储、复制和调用任何可复制构造的可调用目标，包括普通函数、成员函数、类对象（重载了operator()的类的对象）、Lambda表达式等。是对C++现有的可调用实体的一种类型安全的包裹（相比而言，函数指针这种可调用实体，是类型不安全的）。 – STL源码分析之std::function
template<typename _Res, typename... _ArgTypes> class function<_Res(_ArgTypes...)> : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...> , private _Function_base { private: using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...); _Invoker_type _M_invoker; // ... }; std::function 的内部有两个部分：
一个指向实际存储区域的指针：存储实际的可调用对象（函数对象、lambda、函数指针等）。 一个接口表（vtable 等效机制）：存储操作函数（如调用函数、复制、销毁等）的地址。 其类型擦除通过接口表的方式实现，类似于虚函数机制，但它通常采用静态接口表和手动的动态分配来支持多种类型的可调用对象。
性能分析 关于std function和lambda function的性能调试 –法号桑菜。
Avoiding The Performance Hazzards of std::function。
There are two performance implications of using std::function that might surprise you:
When calling a std::function, it does a virtual function call. When assigning a lambda with significant captures to a std::function, it will do a dynamic memory allocation! 一是std::function 会使用虚函数调用，有开销。 二是将 lambda 赋给std::function的时候，如果捕获内容较多，会需要额外的动态内存分配。 第二点其实说的就是：
std::function 对小型的可调用对象会使用“小对象优化（Small Object Optimization, SOO）”，避免动态分配堆内存。但如果对象超过了实现中的小对象优化阈值，则会触发堆分配（new 操作）。"><meta itemprop=datePublished content="2025-01-15T12:05:47+08:00"><meta itemprop=dateModified content="2025-01-15T12:05:47+08:00"><meta itemprop=wordCount content="350"><meta itemprop=image content="https://jekyulll.github.io/"><meta itemprop=keywords content="Cpp,Morden Cpp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jekyulll.github.io/"><meta name=twitter:title content="C++ std::function 之脱裤子放屁的优化"><meta name=twitter:description content="看到一句话：
std::function 很强大，但是代价也很高，在创建函数对象的时候总是会有 new 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。
于是草草找一下资料，看看有没有隐藏的性能优化。
std::function 的实现 std::function 是一个可变参类模板，是一个通用的函数包装器（Polymorphic function wrapper）。
通过类型擦除（type erasure）机制，将具体类型的可调用对象封装到一个统一的接口中。
其实例可以存储、复制和调用任何可复制构造的可调用目标，包括普通函数、成员函数、类对象（重载了operator()的类的对象）、Lambda表达式等。是对C++现有的可调用实体的一种类型安全的包裹（相比而言，函数指针这种可调用实体，是类型不安全的）。 – STL源码分析之std::function
template<typename _Res, typename... _ArgTypes> class function<_Res(_ArgTypes...)> : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...> , private _Function_base { private: using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...); _Invoker_type _M_invoker; // ... }; std::function 的内部有两个部分：
一个指向实际存储区域的指针：存储实际的可调用对象（函数对象、lambda、函数指针等）。 一个接口表（vtable 等效机制）：存储操作函数（如调用函数、复制、销毁等）的地址。 其类型擦除通过接口表的方式实现，类似于虚函数机制，但它通常采用静态接口表和手动的动态分配来支持多种类型的可调用对象。
性能分析 关于std function和lambda function的性能调试 –法号桑菜。
Avoiding The Performance Hazzards of std::function。
There are two performance implications of using std::function that might surprise you:
When calling a std::function, it does a virtual function call. When assigning a lambda with significant captures to a std::function, it will do a dynamic memory allocation! 一是std::function 会使用虚函数调用，有开销。 二是将 lambda 赋给std::function的时候，如果捕获内容较多，会需要额外的动态内存分配。 第二点其实说的就是：
std::function 对小型的可调用对象会使用“小对象优化（Small Object Optimization, SOO）”，避免动态分配堆内存。但如果对象超过了实现中的小对象优化阈值，则会触发堆分配（new 操作）。"><meta property="og:url" content="https://jekyulll.github.io/post/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/"><meta property="og:site_name" content="Hello Friend NG"><meta property="og:title" content="C++ std::function 之脱裤子放屁的优化"><meta property="og:description" content="看到一句话：
std::function 很强大，但是代价也很高，在创建函数对象的时候总是会有 new 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。
于是草草找一下资料，看看有没有隐藏的性能优化。
std::function 的实现 std::function 是一个可变参类模板，是一个通用的函数包装器（Polymorphic function wrapper）。
通过类型擦除（type erasure）机制，将具体类型的可调用对象封装到一个统一的接口中。
其实例可以存储、复制和调用任何可复制构造的可调用目标，包括普通函数、成员函数、类对象（重载了operator()的类的对象）、Lambda表达式等。是对C++现有的可调用实体的一种类型安全的包裹（相比而言，函数指针这种可调用实体，是类型不安全的）。 – STL源码分析之std::function
template<typename _Res, typename... _ArgTypes> class function<_Res(_ArgTypes...)> : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...> , private _Function_base { private: using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...); _Invoker_type _M_invoker; // ... }; std::function 的内部有两个部分：
一个指向实际存储区域的指针：存储实际的可调用对象（函数对象、lambda、函数指针等）。 一个接口表（vtable 等效机制）：存储操作函数（如调用函数、复制、销毁等）的地址。 其类型擦除通过接口表的方式实现，类似于虚函数机制，但它通常采用静态接口表和手动的动态分配来支持多种类型的可调用对象。
性能分析 关于std function和lambda function的性能调试 –法号桑菜。
Avoiding The Performance Hazzards of std::function。
There are two performance implications of using std::function that might surprise you:
When calling a std::function, it does a virtual function call. When assigning a lambda with significant captures to a std::function, it will do a dynamic memory allocation! 一是std::function 会使用虚函数调用，有开销。 二是将 lambda 赋给std::function的时候，如果捕获内容较多，会需要额外的动态内存分配。 第二点其实说的就是：
std::function 对小型的可调用对象会使用“小对象优化（Small Object Optimization, SOO）”，避免动态分配堆内存。但如果对象超过了实现中的小对象优化阈值，则会触发堆分配（new 操作）。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-15T12:05:47+08:00"><meta property="article:modified_time" content="2025-01-15T12:05:47+08:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Morden Cpp"><meta property="og:image" content="https://jekyulll.github.io/"><meta property="article:section" content="cpp"><meta property="article:published_time" content="2025-01-15 12:05:47 +0800 +0800"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello friend ng</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>Blog</a></li><ul class=submenu><li class=dropdown><a href=javascript:void(0) class=dropbtn>en</a><div class=dropdown-content></div></li></ul></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://jekyulll.github.io/post/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/>C++ std::function 之脱裤子放屁的优化</a></h2><div class=post-content><p>看到一句话：</p><blockquote><p><code>std::function</code> 很强大，但是代价也很高，在创建函数对象的时候总是会有 <code>new</code> 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。</p></blockquote><p>于是草草找一下资料，看看有没有隐藏的性能优化。</p><hr><h3 id=stdfunction-的实现><code>std::function</code> 的实现</h3><p><a href=https://zh.cppreference.com/w/cpp/utility/functional/function><code>std::function</code></a> 是一个可变参类模板，是一个通用的函数包装器（Polymorphic function wrapper）。<br>通过类型擦除（type erasure）机制，将具体类型的可调用对象封装到一个统一的接口中。</p><blockquote><p>其实例可以存储、复制和调用任何可复制构造的可调用目标，包括普通函数、成员函数、类对象（重载了operator()的类的对象）、Lambda表达式等。是对C++现有的可调用实体的一种类型安全的包裹（相比而言，函数指针这种可调用实体，是类型不安全的）。 &ndash; <a href=https://zhuanlan.zhihu.com/p/560964284>STL源码分析之std::function</a></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> _Res, <span style=color:#66d9ef>typename</span>... _ArgTypes<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>function</span><span style=color:#f92672>&lt;</span>_Res(_ArgTypes...)<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> _Maybe_unary_or_binary_function<span style=color:#f92672>&lt;</span>_Res, _ArgTypes...<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  , <span style=color:#66d9ef>private</span> _Function_base
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> _Invoker_type <span style=color:#f92672>=</span> _Res (<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>const</span> _Any_data<span style=color:#f92672>&amp;</span>, _ArgTypes<span style=color:#f92672>&amp;&amp;</span>...);
</span></span><span style=display:flex><span>    _Invoker_type _M_invoker;
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p><code>std::function</code> 的内部有两个部分：</p><ul><li>一个指向实际存储区域的指针：存储实际的可调用对象（函数对象、lambda、函数指针等）。</li><li>一个<em>接口表</em>（vtable 等效机制）：存储操作函数（如调用函数、复制、销毁等）的地址。</li></ul><p>其类型擦除通过接口表的方式实现，类似于虚函数机制，但它通常采用静态接口表和手动的动态分配来支持多种类型的可调用对象。</p><hr><h3 id=性能分析>性能分析</h3><p><a href=https://zhuanlan.zhihu.com/p/370563773>关于std function和lambda function的性能调试 &ndash;法号桑菜</a>。<br><a href=https://blog.demofox.org/2015/02/25/avoiding-the-performance-hazzards-of-stdfunction/>Avoiding The Performance Hazzards of std::function</a>。</p><blockquote><p>There are two performance implications of using <code>std::function</code> that might surprise you:</p><ol><li>When calling a <code>std::function</code>, it does a virtual function call.</li><li>When assigning a lambda with significant captures to a <code>std::function</code>, it will do a dynamic memory allocation!</li></ol></blockquote><ul><li>一是<code>std::function</code> 会使用虚函数调用，有开销。</li><li>二是将 lambda 赋给<code>std::function</code>的时候，如果捕获内容较多，会需要额外的动态内存分配。</li></ul><p>第二点其实说的就是：<br><code>std::function</code> 对小型的可调用对象会使用“<strong>小对象优化</strong>（Small Object Optimization, SOO）”，避免动态分配堆内存。但如果对象超过了实现中的小对象优化阈值，则会触发堆分配（<code>new</code> 操作）。</p><hr><h3 id=一些可能有用的优化>一些可能有用的优化</h3><ol><li>手动使用模板代替 <code>std::function</code>：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Callable<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> invoke(Callable f) {
</span></span><span style=display:flex><span>    f();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>直接在编译期确定类型，避免了类型擦除和动态分配。<br>缺点就是使用场景受限于编译期类型，灵活性不如 <code>std::function</code>。</p><ol start=2><li>向 <code>std::function</code> 传递 lambda 的时候使用 <code>std::ref()</code> / <code>std::cref()</code></li></ol><blockquote><p><code>std::ref()</code> and <code>std::cref()</code> return reference wrappers (costant ref wrapper in the cref case) which can hold arbitrary types as references. If you put your large capture lambda into one of these functions and give it to <code>std::function</code>, there’s a <code>std::function</code> constructor which is able to take this reference, and use that instead of allocating more memory.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>array i;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> A <span style=color:#f92672>=</span> [<span style=color:#f92672>=</span>]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (i[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> i[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> i[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>+</span> i[<span style=color:#ae81ff>3</span>]) <span style=color:#f92672>^</span> i[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>// no allocation, std::function stores a reference to A instead of A itself
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>function <span style=color:#a6e22e>fA</span>(ref(A));
</span></span></code></pre></div><ol start=3><li>使用 <code>std::variant</code>：</li></ol><p>通过 <code>std::variant</code> 直接存储无类型擦除的函数对象。似乎有点跑题，在此处作用有限。<br><code>std::variant</code> 的内存是静态分配的：其大小是所有可能存储的类型大小的最大值，避免了堆分配的开销。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PrintHello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>()() <span style=color:#66d9ef>const</span> { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello, Struct!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Callable <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span>(<span style=color:#f92672>*</span>)(), PrintHello<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoke</span>(<span style=color:#66d9ef>const</span> Callable<span style=color:#f92672>&amp;</span> f) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>visit([](<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> func) { func(); }, f);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    invoke([]() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello, Function Pointer!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; });  <span style=color:#75715e>// 函数指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    invoke(PrintHello{});  <span style=color:#75715e>// 自定义的函数对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li><p>Stack Allocation: 给 <code>std::function</code> 一个自定义分配器&mldr;</p></li><li><p>Lambda 的 <code>+</code></p></li></ol><p>一个无捕获的 lambda 表达式不依赖于任何外部状态，可以被隐式转换为函数指针：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> lambda <span style=color:#f92672>=</span> []() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello, Lambda!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>funcPtr)() <span style=color:#f92672>=</span> lambda; <span style=color:#75715e>// 无需显式转换
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>funcPtr(); <span style=color:#75715e>// 调用函数指针，输出 &#34;Hello, Lambda!&#34;
</span></span></span></code></pre></div><p>在 lambda 表达式前使用<code>+</code>，会强制将 lambda 转换为函数指针：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoke</span>(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>func)()) {
</span></span><span style=display:flex><span>    func();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    invoke(<span style=color:#f92672>+</span>[]() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello, Lambda!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }); <span style=color:#75715e>// 显式转换为函数指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><hr><p>All in all:</p><p><img src=/images/stdfunction.png alt=确实></p></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://jekyulll.github.io/tags/cpp/>cpp</a></span>
<span class=tag><a href=https://jekyulll.github.io/tags/morden-cpp/>morden cpp</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://jekyulll.github.io/categories/cpp/>cpp</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>