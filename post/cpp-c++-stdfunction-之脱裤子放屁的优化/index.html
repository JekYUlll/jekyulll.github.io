<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>C++ std::function 之脱裤子放屁的优化 - HOREB EVAN JEKYULLL BLOG</title>
<meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="JekYUlll"><meta name=description content="看到一句话：
std::function 很强大，但是代价也很高，在创建函数对象的时候总是会有 new 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。
于是草草找一下资料，看看有没有隐藏的性能优化。
"><meta name=keywords content="JekYUlll,theme,even"><meta name=generator content="Hugo 0.140.0 with theme even"><link rel=canonical href=https://jekyulll.github.io/post/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:url" content="https://jekyulll.github.io/post/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/"><meta property="og:site_name" content="HOREB EVAN JEKYULLL BLOG"><meta property="og:title" content="C++ std::function 之脱裤子放屁的优化"><meta property="og:description" content="看到一句话：
std::function 很强大，但是代价也很高，在创建函数对象的时候总是会有 new 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。
于是草草找一下资料，看看有没有隐藏的性能优化。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-15T12:05:47+08:00"><meta property="article:modified_time" content="2025-01-15T12:05:47+08:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Morden Cpp"><meta itemprop=name content="C++ std::function 之脱裤子放屁的优化"><meta itemprop=description content="看到一句话：
std::function 很强大，但是代价也很高，在创建函数对象的时候总是会有 new 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。
于是草草找一下资料，看看有没有隐藏的性能优化。"><meta itemprop=datePublished content="2025-01-15T12:05:47+08:00"><meta itemprop=dateModified content="2025-01-15T12:05:47+08:00"><meta itemprop=wordCount content="1331"><meta itemprop=keywords content="Cpp,Morden Cpp"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ std::function 之脱裤子放屁的优化"><meta name=twitter:description content="看到一句话：
std::function 很强大，但是代价也很高，在创建函数对象的时候总是会有 new 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。
于是草草找一下资料，看看有没有隐藏的性能优化。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Horeb</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Horeb</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>C++ std::function 之脱裤子放屁的优化</h1><div class=post-meta><span class=post-time>2025-01-15</span><div class=post-category><a href=/categories/cpp/>cpp</a></div><span class=more-meta>1331 words </span><span class=more-meta>3 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#stdfunction-的实现><code>std::function</code> 的实现</a></li><li><a href=#性能分析>性能分析</a></li><li><a href=#一些可能有用的优化>一些可能有用的优化</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><p>看到一句话：</p><blockquote><p><code>std::function</code> 很强大，但是代价也很高，在创建函数对象的时候总是会有 <code>new</code> 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。</p></blockquote><p>于是草草找一下资料，看看有没有隐藏的性能优化。</p><hr><h3 id=stdfunction-的实现><code>std::function</code> 的实现</h3><p><a href=https://zh.cppreference.com/w/cpp/utility/functional/function><code>std::function</code></a> 是一个可变参类模板，是一个通用的函数包装器（Polymorphic function wrapper）。<br>通过类型擦除（type erasure）机制，将具体类型的可调用对象封装到一个统一的接口中。</p><blockquote><p>其实例可以存储、复制和调用任何可复制构造的可调用目标，包括普通函数、成员函数、类对象（重载了operator()的类的对象）、Lambda表达式等。是对C++现有的可调用实体的一种类型安全的包裹（相比而言，函数指针这种可调用实体，是类型不安全的）。 &ndash; <a href=https://zhuanlan.zhihu.com/p/560964284>STL源码分析之std::function</a></p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>_Res</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>_ArgTypes</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>function</span><span class=o>&lt;</span><span class=n>_Res</span><span class=p>(</span><span class=n>_ArgTypes</span><span class=p>...)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>:</span> <span class=k>public</span> <span class=n>_Maybe_unary_or_binary_function</span><span class=o>&lt;</span><span class=n>_Res</span><span class=p>,</span> <span class=n>_ArgTypes</span><span class=p>...</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>,</span> <span class=k>private</span> <span class=n>_Function_base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>_Invoker_type</span> <span class=o>=</span> <span class=n>_Res</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=k>const</span> <span class=n>_Any_data</span><span class=o>&amp;</span><span class=p>,</span> <span class=n>_ArgTypes</span><span class=o>&amp;&amp;</span><span class=p>...);</span>
</span></span><span class=line><span class=cl>    <span class=n>_Invoker_type</span> <span class=n>_M_invoker</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p><code>std::function</code> 的内部有两个部分：</p><ul><li>一个指向实际存储区域的指针：存储实际的可调用对象（函数对象、lambda、函数指针等）。</li><li>一个<em>接口表</em>（vtable 等效机制）：存储操作函数（如调用函数、复制、销毁等）的地址。</li></ul><p>其类型擦除通过接口表的方式实现，类似于虚函数机制，但它通常采用静态接口表和手动的动态分配来支持多种类型的可调用对象。</p><hr><h3 id=性能分析>性能分析</h3><p><a href=https://zhuanlan.zhihu.com/p/370563773>关于std function和lambda function的性能调试 &ndash;法号桑菜</a>。<br><a href=https://blog.demofox.org/2015/02/25/avoiding-the-performance-hazzards-of-stdfunction/>Avoiding The Performance Hazzards of std::function</a>。</p><blockquote><p>There are two performance implications of using <code>std::function</code> that might surprise you:</p><ol><li>When calling a <code>std::function</code>, it does a virtual function call.</li><li>When assigning a lambda with significant captures to a <code>std::function</code>, it will do a dynamic memory allocation!</li></ol></blockquote><ul><li>一是<code>std::function</code> 会使用虚函数调用，有开销。</li><li>二是将 lambda 赋给<code>std::function</code>的时候，如果捕获内容较多，会需要额外的动态内存分配。</li></ul><p>第二点其实说的就是：<br><code>std::function</code> 对小型的可调用对象会使用“<strong>小对象优化</strong>（Small Object Optimization, SOO）”，避免动态分配堆内存。但如果对象超过了实现中的小对象优化阈值，则会触发堆分配（<code>new</code> 操作）。</p><hr><h3 id=一些可能有用的优化>一些可能有用的优化</h3><ol><li>手动使用模板代替 <code>std::function</code>：</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Callable</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>invoke</span><span class=p>(</span><span class=n>Callable</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>直接在编译期确定类型，避免了类型擦除和动态分配。<br>缺点就是使用场景受限于编译期类型，灵活性不如 <code>std::function</code>。</p><ol start=2><li>向 <code>std::function</code> 传递 lambda 的时候使用 <code>std::ref()</code> / <code>std::cref()</code></li></ol><blockquote><p><code>std::ref()</code> and <code>std::cref()</code> return reference wrappers (costant ref wrapper in the cref case) which can hold arbitrary types as references. If you put your large capture lambda into one of these functions and give it to <code>std::function</code>, there’s a <code>std::function</code> constructor which is able to take this reference, and use that instead of allocating more memory.</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>array</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>A</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>]()</span> <span class=o>-&gt;</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>i</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>i</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>i</span><span class=p>[</span><span class=mi>3</span><span class=p>])</span> <span class=o>^</span> <span class=n>i</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// no allocation, std::function stores a reference to A instead of A itself
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>function</span> <span class=nf>fA</span><span class=p>(</span><span class=n>ref</span><span class=p>(</span><span class=n>A</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><ol start=3><li>使用 <code>std::variant</code>：</li></ol><p>通过 <code>std::variant</code> 直接存储无类型擦除的函数对象。似乎有点跑题，在此处作用有限。<br><code>std::variant</code> 的内存是静态分配的：其大小是所有可能存储的类型大小的最大值，避免了堆分配的开销。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>PrintHello</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>operator</span><span class=p>()()</span> <span class=k>const</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello, Struct!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>Callable</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>variant</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=p>)(),</span> <span class=n>PrintHello</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>invoke</span><span class=p>(</span><span class=k>const</span> <span class=n>Callable</span><span class=o>&amp;</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>visit</span><span class=p>([](</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>func</span><span class=p>)</span> <span class=p>{</span> <span class=n>func</span><span class=p>();</span> <span class=p>},</span> <span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>invoke</span><span class=p>([]()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello, Function Pointer!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>});</span>  <span class=c1>// 函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>invoke</span><span class=p>(</span><span class=n>PrintHello</span><span class=p>{});</span>  <span class=c1>// 自定义的函数对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=4><li><p>Stack Allocation: 给 <code>std::function</code> 一个自定义分配器&mldr;</p></li><li><p>Lambda 的 <code>+</code></p></li></ol><p>一个无捕获的 lambda 表达式不依赖于任何外部状态，可以被隐式转换为函数指针：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>lambda</span> <span class=o>=</span> <span class=p>[]()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello, Lambda!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>funcPtr</span><span class=p>)()</span> <span class=o>=</span> <span class=n>lambda</span><span class=p>;</span> <span class=c1>// 无需显式转换
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>funcPtr</span><span class=p>();</span> <span class=c1>// 调用函数指针，输出 &#34;Hello, Lambda!&#34;
</span></span></span></code></pre></td></tr></table></div></div><p>在 lambda 表达式前使用<code>+</code>，会强制将 lambda 转换为函数指针：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>invoke</span><span class=p>(</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>func</span><span class=p>)())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>invoke</span><span class=p>(</span><span class=o>+</span><span class=p>[]()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello, Lambda!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>});</span> <span class=c1>// 显式转换为函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><p>All in all:</p><p><img src=/images/stdfunction.png alt=确实></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>JekYUlll</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2025-01-15</span></p><p class=copyright-item><span class=item-title>Markdown</span>
<span class=item-content><a class=link-to-markdown href=https://jekyulll.github.io/post/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/index.md target=_blank>The Markdown version »</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/cpp/>cpp</a>
<a href=/tags/morden-cpp/>morden cpp</a></div><nav class=post-nav><a class=prev href=/post/alg-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">扫描线算法计算区间重叠</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/post/cpp-%E7%94%A8-c++-%E5%AE%9E%E7%8E%B0-golang-%E7%9A%84-defer/><span class="next-text nav-default">在 C++ 里实现 Golang 的 defer</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:jekyulll@gmail.com class="iconfont icon-email" title=email></a><a href=https://github.com/JekYUlll class="iconfont icon-github" title=github></a><a href=https://www.zhihu.com/people/yu-bei-28-33 class="iconfont icon-zhihu" title=zhihu></a><a href=https://space.bilibili.com/11060371 class="iconfont icon-bilibili" title=bilibili></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span><span class=copyright-year>&copy;
2024 -
2025<span class=heart><i class="iconfont icon-heart"></i></span><span></span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6473FXND4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q6473FXND4")}</script></body></html>