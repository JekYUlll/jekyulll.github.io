<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="JekYUlll"><meta name=description content="常见MQ的功能，有哪些是用Redis实现不了的？
消息队列（MQ）用于解耦系统、异步处理、削峰填谷等，常见的 MQ 有 RabbitMQ、Kafka、RocketMQ、ActiveMQ 等。而 Redis 也提供了发布/订阅（pub/sub）、List 队列、Stream（流）等机制，看似也能实现部分消息队列的功能。
✅ Redis 能做的 MQ 功能： 功能 Redis 支持方式 简单队列 使用 List 的 LPUSH + BRPOP 实现 发布订阅 使用 Pub/Sub 功能 消息流 使用 Stream 类型（自 Redis 5.0 起） 消息持久化（有限） Redis 有持久化机制（RDB、AOF） ❌ Redis 实现不了或不擅长的 MQ 功能： 功能 原因 消息可靠投递（ACK 确认机制） Redis 的 Pub/Sub 没有消费确认机制，Stream 有但比较弱（如无消费失败自动重试机制） 高吞吐量/分布式日志系统（如 Kafka） Redis 不适合大规模日志或百万 TPS 场景，且不具备分区（partition）机制 消费失败后的重试机制、死信队列（DLQ） Redis 不原生支持，需要手动构建（逻辑复杂且不够健壮） 消费顺序保障（partition+offset） Redis Stream 提供 ID 顺序，但无法如 Kafka 那样做严格的有序分区消费 持久性保证和磁盘容量优化 Redis 为内存数据库，持久性和存储成本远不如 Kafka 等磁盘级 MQ 消息积压处理能力强 Redis 基于内存，积压消息多了容易 OOM，Kafka 之类基于磁盘无此问题 事务性消息支持（如 RocketMQ） Redis 不支持事务性消息逻辑 消费者分组与负载均衡（Consumer Group） Redis Stream 有些类似功能，但不如 Kafka 灵活和成熟 流控和限速、幂等机制支持 Redis 需要自己实现，Kafka 等 MQ 内建支持 总结 Redis 可以用来实现轻量级、简单或低吞吐的消息队列系统； Kafka、RabbitMQ、RocketMQ 等更适合需要高可靠性、分布式、高吞吐、复杂消息模式的场景； Redis 适合“玩具级”或轻量任务队列，不推荐在企业级复杂系统中用作核心 MQ。 "><meta name=keywords content="homepage,blog,redis,mq"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://jekyulll.github.io/post/redis-redis-stream%E5%92%8Cmq/><title>Redis Stream和MQ :: Hello Friend NG — A simple theme for Hugo
</title><link rel=stylesheet href=/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css integrity="sha256-JEGDzeGjjgsI+CwReRGBKI+arBzJYYzW9OnncQxXaLo=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Redis Stream和MQ"><meta itemprop=description content="常见MQ的功能，有哪些是用Redis实现不了的？
消息队列（MQ）用于解耦系统、异步处理、削峰填谷等，常见的 MQ 有 RabbitMQ、Kafka、RocketMQ、ActiveMQ 等。而 Redis 也提供了发布/订阅（pub/sub）、List 队列、Stream（流）等机制，看似也能实现部分消息队列的功能。
✅ Redis 能做的 MQ 功能： 功能 Redis 支持方式 简单队列 使用 List 的 LPUSH + BRPOP 实现 发布订阅 使用 Pub/Sub 功能 消息流 使用 Stream 类型（自 Redis 5.0 起） 消息持久化（有限） Redis 有持久化机制（RDB、AOF） ❌ Redis 实现不了或不擅长的 MQ 功能： 功能 原因 消息可靠投递（ACK 确认机制） Redis 的 Pub/Sub 没有消费确认机制，Stream 有但比较弱（如无消费失败自动重试机制） 高吞吐量/分布式日志系统（如 Kafka） Redis 不适合大规模日志或百万 TPS 场景，且不具备分区（partition）机制 消费失败后的重试机制、死信队列（DLQ） Redis 不原生支持，需要手动构建（逻辑复杂且不够健壮） 消费顺序保障（partition+offset） Redis Stream 提供 ID 顺序，但无法如 Kafka 那样做严格的有序分区消费 持久性保证和磁盘容量优化 Redis 为内存数据库，持久性和存储成本远不如 Kafka 等磁盘级 MQ 消息积压处理能力强 Redis 基于内存，积压消息多了容易 OOM，Kafka 之类基于磁盘无此问题 事务性消息支持（如 RocketMQ） Redis 不支持事务性消息逻辑 消费者分组与负载均衡（Consumer Group） Redis Stream 有些类似功能，但不如 Kafka 灵活和成熟 流控和限速、幂等机制支持 Redis 需要自己实现，Kafka 等 MQ 内建支持 总结 Redis 可以用来实现轻量级、简单或低吞吐的消息队列系统； Kafka、RabbitMQ、RocketMQ 等更适合需要高可靠性、分布式、高吞吐、复杂消息模式的场景； Redis 适合“玩具级”或轻量任务队列，不推荐在企业级复杂系统中用作核心 MQ。"><meta itemprop=datePublished content="2025-05-05T21:05:47+08:00"><meta itemprop=dateModified content="2025-05-05T21:05:47+08:00"><meta itemprop=wordCount content="106"><meta itemprop=image content="https://jekyulll.github.io/"><meta itemprop=keywords content="Redis,Mq"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jekyulll.github.io/"><meta name=twitter:title content="Redis Stream和MQ"><meta name=twitter:description content="常见MQ的功能，有哪些是用Redis实现不了的？
消息队列（MQ）用于解耦系统、异步处理、削峰填谷等，常见的 MQ 有 RabbitMQ、Kafka、RocketMQ、ActiveMQ 等。而 Redis 也提供了发布/订阅（pub/sub）、List 队列、Stream（流）等机制，看似也能实现部分消息队列的功能。
✅ Redis 能做的 MQ 功能： 功能 Redis 支持方式 简单队列 使用 List 的 LPUSH + BRPOP 实现 发布订阅 使用 Pub/Sub 功能 消息流 使用 Stream 类型（自 Redis 5.0 起） 消息持久化（有限） Redis 有持久化机制（RDB、AOF） ❌ Redis 实现不了或不擅长的 MQ 功能： 功能 原因 消息可靠投递（ACK 确认机制） Redis 的 Pub/Sub 没有消费确认机制，Stream 有但比较弱（如无消费失败自动重试机制） 高吞吐量/分布式日志系统（如 Kafka） Redis 不适合大规模日志或百万 TPS 场景，且不具备分区（partition）机制 消费失败后的重试机制、死信队列（DLQ） Redis 不原生支持，需要手动构建（逻辑复杂且不够健壮） 消费顺序保障（partition+offset） Redis Stream 提供 ID 顺序，但无法如 Kafka 那样做严格的有序分区消费 持久性保证和磁盘容量优化 Redis 为内存数据库，持久性和存储成本远不如 Kafka 等磁盘级 MQ 消息积压处理能力强 Redis 基于内存，积压消息多了容易 OOM，Kafka 之类基于磁盘无此问题 事务性消息支持（如 RocketMQ） Redis 不支持事务性消息逻辑 消费者分组与负载均衡（Consumer Group） Redis Stream 有些类似功能，但不如 Kafka 灵活和成熟 流控和限速、幂等机制支持 Redis 需要自己实现，Kafka 等 MQ 内建支持 总结 Redis 可以用来实现轻量级、简单或低吞吐的消息队列系统； Kafka、RabbitMQ、RocketMQ 等更适合需要高可靠性、分布式、高吞吐、复杂消息模式的场景； Redis 适合“玩具级”或轻量任务队列，不推荐在企业级复杂系统中用作核心 MQ。"><meta property="og:url" content="https://jekyulll.github.io/post/redis-redis-stream%E5%92%8Cmq/"><meta property="og:site_name" content="Hello Friend NG"><meta property="og:title" content="Redis Stream和MQ"><meta property="og:description" content="常见MQ的功能，有哪些是用Redis实现不了的？
消息队列（MQ）用于解耦系统、异步处理、削峰填谷等，常见的 MQ 有 RabbitMQ、Kafka、RocketMQ、ActiveMQ 等。而 Redis 也提供了发布/订阅（pub/sub）、List 队列、Stream（流）等机制，看似也能实现部分消息队列的功能。
✅ Redis 能做的 MQ 功能： 功能 Redis 支持方式 简单队列 使用 List 的 LPUSH + BRPOP 实现 发布订阅 使用 Pub/Sub 功能 消息流 使用 Stream 类型（自 Redis 5.0 起） 消息持久化（有限） Redis 有持久化机制（RDB、AOF） ❌ Redis 实现不了或不擅长的 MQ 功能： 功能 原因 消息可靠投递（ACK 确认机制） Redis 的 Pub/Sub 没有消费确认机制，Stream 有但比较弱（如无消费失败自动重试机制） 高吞吐量/分布式日志系统（如 Kafka） Redis 不适合大规模日志或百万 TPS 场景，且不具备分区（partition）机制 消费失败后的重试机制、死信队列（DLQ） Redis 不原生支持，需要手动构建（逻辑复杂且不够健壮） 消费顺序保障（partition+offset） Redis Stream 提供 ID 顺序，但无法如 Kafka 那样做严格的有序分区消费 持久性保证和磁盘容量优化 Redis 为内存数据库，持久性和存储成本远不如 Kafka 等磁盘级 MQ 消息积压处理能力强 Redis 基于内存，积压消息多了容易 OOM，Kafka 之类基于磁盘无此问题 事务性消息支持（如 RocketMQ） Redis 不支持事务性消息逻辑 消费者分组与负载均衡（Consumer Group） Redis Stream 有些类似功能，但不如 Kafka 灵活和成熟 流控和限速、幂等机制支持 Redis 需要自己实现，Kafka 等 MQ 内建支持 总结 Redis 可以用来实现轻量级、简单或低吞吐的消息队列系统； Kafka、RabbitMQ、RocketMQ 等更适合需要高可靠性、分布式、高吞吐、复杂消息模式的场景； Redis 适合“玩具级”或轻量任务队列，不推荐在企业级复杂系统中用作核心 MQ。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-05-05T21:05:47+08:00"><meta property="article:modified_time" content="2025-05-05T21:05:47+08:00"><meta property="article:tag" content="Redis"><meta property="article:tag" content="Mq"><meta property="og:image" content="https://jekyulll.github.io/"><meta property="article:section" content="redis"><meta property="article:published_time" content="2025-05-05 21:05:47 +0800 +0800"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello friend ng</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>Blog</a></li><ul class=submenu><li class=dropdown><a href=javascript:void(0) class=dropbtn>en</a><div class=dropdown-content></div></li></ul></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://jekyulll.github.io/post/redis-redis-stream%E5%92%8Cmq/>Redis Stream和MQ</a></h2><div class=post-content><p>常见MQ的功能，有哪些是用Redis实现不了的？</p><p>消息队列（MQ）用于解耦系统、异步处理、削峰填谷等，常见的 MQ 有 RabbitMQ、Kafka、RocketMQ、ActiveMQ 等。而 Redis 也提供了发布/订阅（pub/sub）、List 队列、Stream（流）等机制，看似也能实现部分消息队列的功能。</p><hr><h3 id=-redis-能做的-mq-功能>✅ Redis 能做的 MQ 功能：</h3><table><thead><tr><th>功能</th><th>Redis 支持方式</th></tr></thead><tbody><tr><td>简单队列</td><td>使用 <code>List</code> 的 <code>LPUSH + BRPOP</code> 实现</td></tr><tr><td>发布订阅</td><td>使用 <code>Pub/Sub</code> 功能</td></tr><tr><td>消息流</td><td>使用 <code>Stream</code> 类型（自 Redis 5.0 起）</td></tr><tr><td>消息持久化（有限）</td><td>Redis 有持久化机制（RDB、AOF）</td></tr></tbody></table><hr><h3 id=-redis-实现不了或不擅长的-mq-功能>❌ Redis 实现不了或不擅长的 MQ 功能：</h3><table><thead><tr><th>功能</th><th>原因</th></tr></thead><tbody><tr><td><strong>消息可靠投递（ACK 确认机制）</strong></td><td>Redis 的 Pub/Sub 没有消费确认机制，Stream 有但比较弱（如无消费失败自动重试机制）</td></tr><tr><td><strong>高吞吐量/分布式日志系统（如 Kafka）</strong></td><td>Redis 不适合大规模日志或百万 TPS 场景，且不具备分区（partition）机制</td></tr><tr><td><strong>消费失败后的重试机制、死信队列（DLQ）</strong></td><td>Redis 不原生支持，需要手动构建（逻辑复杂且不够健壮）</td></tr><tr><td><strong>消费顺序保障（partition+offset）</strong></td><td>Redis Stream 提供 ID 顺序，但无法如 Kafka 那样做严格的有序分区消费</td></tr><tr><td><strong>持久性保证和磁盘容量优化</strong></td><td>Redis 为内存数据库，持久性和存储成本远不如 Kafka 等磁盘级 MQ</td></tr><tr><td><strong>消息积压处理能力强</strong></td><td>Redis 基于内存，积压消息多了容易 OOM，Kafka 之类基于磁盘无此问题</td></tr><tr><td><strong>事务性消息支持（如 RocketMQ）</strong></td><td>Redis 不支持事务性消息逻辑</td></tr><tr><td><strong>消费者分组与负载均衡（Consumer Group）</strong></td><td>Redis Stream 有些类似功能，但不如 Kafka 灵活和成熟</td></tr><tr><td><strong>流控和限速、幂等机制支持</strong></td><td>Redis 需要自己实现，Kafka 等 MQ 内建支持</td></tr></tbody></table><hr><h3 id=总结>总结</h3><ul><li>Redis 可以用来实现轻量级、简单或低吞吐的消息队列系统；</li><li>Kafka、RabbitMQ、RocketMQ 等更适合需要<strong>高可靠性、分布式、高吞吐、复杂消息模式</strong>的场景；</li><li>Redis 适合“玩具级”或轻量任务队列，<strong>不推荐在企业级复杂系统中用作核心 MQ</strong>。</li></ul></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://jekyulll.github.io/tags/redis/>redis</a></span>
<span class=tag><a href=https://jekyulll.github.io/tags/mq/>mq</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://jekyulll.github.io/categories/redis/>redis</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>