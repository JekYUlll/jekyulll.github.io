<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Horeb's Blog ⬆️</title><link>https://jekyulll.github.io/</link><description>Recent content on Horeb's Blog ⬆️</description><generator>Hugo</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sat, 18 Oct 2025 21:05:47 +0800</lastBuildDate><atom:link href="https://jekyulll.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>实验室服务器使用教程</title><link>https://jekyulll.github.io/posts/normal-%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link><pubDate>Sat, 18 Oct 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/normal-%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid><description>&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>&lt;span style="color: red;">&lt;strong>校外访问请通过校园 VPN&lt;/strong>&lt;/span>&lt;/p>
&lt;p>实验室近期新购置了一台深度学习服务器，供成员进行模型训练、仿真和计算任务。为了帮助大家快速上手、规范使用、避免资源浪费或系统损坏，特编写此教程。&lt;/p>
&lt;hr>
&lt;h2 id="二什么是深度学习服务器">二、什么是“深度学习服务器”&lt;/h2>
&lt;p>深度学习服务器是一台高性能计算机，通常配备多块 GPU（图形处理器）、大容量显存、内存和高速存储。
通常安装Linux系统 ，一般&lt;strong>不直接接显示器&lt;/strong>，而是通过网络远程访问（SSH 或远程桌面）。&lt;/p>
&lt;h3 id="主要用途">主要用途&lt;/h3>
&lt;ul>
&lt;li>深度学习训练（如 PyTorch、TensorFlow）；&lt;/li>
&lt;li>大规模有限元仿真（Abaqus、ANSYS、COMSOL）；&lt;/li>
&lt;li>数据分析、图像识别、模型优化等。&lt;/li>
&lt;/ul>
&lt;h3 id="系统与软件环境">系统与软件环境&lt;/h3>
&lt;ul>
&lt;li>操作系统：Ubuntu 22.04 LTS&lt;/li>
&lt;li>已安装软件：Anaconda、Python、JupyterLab&lt;/li>
&lt;/ul>
&lt;p>为避免cuda版本导致的问题，此处仅保证显卡驱动版本，cuda请根据需求自行安装。&lt;/p>
&lt;hr>
&lt;h2 id="三账户与登录信息">三、账户与登录信息&lt;/h2>
&lt;h3 id="账户申请">账户申请&lt;/h3>
&lt;p>新用户请联系实验室管理员开通。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>账户命名规则&lt;/strong>
实验室统一以&lt;em>姓名全拼&lt;/em>作为用户名，例如：&lt;/p>
&lt;ul>
&lt;li>张三 → &lt;em>zhangsan&lt;/em>&lt;/li>
&lt;li>李四 → &lt;em>lisi&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>初始密码&lt;/strong>
所有新账户的初始密码为：&lt;code>123456&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="手动修改密码重要">手动修改密码（重要）&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>登录服务器后（见后续教程），在终端输入：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>passwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>系统会提示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Changing password &lt;span style="color:#66d9ef">for&lt;/span> user zhangsan.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>current&lt;span style="color:#f92672">)&lt;/span> UNIX password:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输入当前密码（即 &lt;code>123456&lt;/code>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接着输入新密码两次（系统不会显示输入内容，但实际上输进去了）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Enter new UNIX password:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Retype new UNIX password:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>如果两次输入一致，会显示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>password updated successfully
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表示修改成功。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="四连接方式">四、连接方式&lt;/h2>
&lt;h3 id="一windows-用户">（一）Windows 用户&lt;/h3>
&lt;p>此处推荐三个用于连接的终端工具（就是黑窗口，理论上使用cmd即可，但不够易用）：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mobaxterm.mobatek.net/">MobaXterm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.netsarang.com/en/xshell/">XShell&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://termius.com/">Terminus&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>此处仅演示MobaXterm。&lt;/p></description></item><item><title>容器化技术之 Linux namespace</title><link>https://jekyulll.github.io/posts/linux-%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B9%8B-linux-namespace/</link><pubDate>Sun, 08 Jun 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B9%8B-linux-namespace/</guid><description>&lt;p>Linux namespace做一层资源隔离，使里面的进程/进程组看起来拥有自己的独立资源。&lt;/p>
&lt;p>PID namespace 中的 &lt;code>init&lt;/code> 进程（PID=1）需要正确处理子进程的僵尸状态，否则会导致资源泄漏。&lt;/p>
&lt;p>有多种namespace:&lt;/p>
&lt;ul>
&lt;li>PID Namespace（CLONE_NEWPID）：不同 namespace 中的进程可以拥有相同的 PID&lt;/li>
&lt;li>Network Namespace（CLONE_NEWNET）：隔离网络栈，包括网络设备、IP 地址、端口、路由表以及防火墙规则&lt;/li>
&lt;li>Mount Namespace（CLONE_NEWNS）：隔离文件系统挂载点&lt;/li>
&lt;li>User Namespace（CLONE_NEWUSER）：隔离用户和组 ID 空间，允许同一个用户在不同 namespace 中拥有不同的权限&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>Docker 容器默认会使用以下 namespace：&lt;/p>
&lt;ul>
&lt;li>PID：隔离进程树。&lt;/li>
&lt;li>NET：提供独立的网络栈。&lt;/li>
&lt;li>IPC：隔离进程间通信。&lt;/li>
&lt;li>UTS：设置独立的主机名。&lt;/li>
&lt;li>MOUNT：隔离文件系统挂载点。&lt;/li>
&lt;li>USER：用于映射容器内的 root 用户到宿主机的普通用户。&lt;/li>
&lt;/ul>
&lt;p>每个进程的 namespace 信息都存储在/proc/[pid]/ns目录下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ls -l /proc/self/ns
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 cgroup -&amp;gt; &amp;#39;cgroup:[4026531835]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 ipc -&amp;gt; &amp;#39;ipc:[4026531839]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 mnt -&amp;gt; &amp;#39;mnt:[4026531840]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 net -&amp;gt; &amp;#39;net:[4026531956]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 pid -&amp;gt; &amp;#39;pid:[4026531836]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 pid_for_children -&amp;gt; &amp;#39;pid:[4026531836]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 user -&amp;gt; &amp;#39;user:[4026531837]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># lrwxrwxrwx 1 user user 0 Jun 10 12:00 uts -&amp;gt; &amp;#39;uts:[4026531838]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="如何创建">如何创建？&lt;/h3>
&lt;ol>
&lt;li>使用&lt;code>unshare&lt;/code>命令创建 namespace：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建新的挂载点和PID namespace，并在其中启动bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>unshare --mount --pid --fork bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在新的namespace中查看PID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $$ &lt;span style="color:#75715e"># 输出通常为1，表示当前bash是新namespace中的第一个进程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看当前namespace中的进程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ps aux
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>使用&lt;code>clone()&lt;/code>系统调用&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define _GNU_SOURCE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sched.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/wait.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 子进程执行的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">child_func&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>arg) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在新的UTS namespace中设置主机名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> sethostname(&lt;span style="color:#e6db74">&amp;#34;container&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 输出当前进程ID和主机名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;子进程PID: %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, getpid());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;主机名: %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;container&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> execlp(&lt;span style="color:#e6db74">&amp;#34;/bin/bash&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;bash&amp;#34;&lt;/span>, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> STACK_SIZE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">65536&lt;/span>; &lt;span style="color:#75715e">// 为子进程分配栈空间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>stack &lt;span style="color:#f92672">=&lt;/span> malloc(STACK_SIZE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>stack) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;内存分配失败&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置栈顶（栈是向下增长的）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>stack_top &lt;span style="color:#f92672">=&lt;/span> stack &lt;span style="color:#f92672">+&lt;/span> STACK_SIZE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建新的UTS和PID namespace，并启动子进程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pid_t pid &lt;span style="color:#f92672">=&lt;/span> clone(child_func, stack_top, 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CLONE_NEWUTS &lt;span style="color:#f92672">|&lt;/span> CLONE_NEWPID &lt;span style="color:#f92672">|&lt;/span> SIGCHLD, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pid &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;clone失败&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 等待子进程结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> waitpid(pid, NULL, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(stack);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>使用&lt;code>setns()&lt;/code>加入现有 namespace&lt;br>
加入另一个进程的网络 namespace：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define _GNU_SOURCE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;fcntl.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sched.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 打开目标进程的网络namespace文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;/proc/1234/ns/net&amp;#34;&lt;/span>, O_RDONLY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fd &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;打开namespace文件失败&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 加入目标namespace
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (setns(fd, CLONE_NEWNET) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;加入namespace失败&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(fd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行需要在目标namespace中运行的命令
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> execlp(&lt;span style="color:#e6db74">&amp;#34;ip&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ip&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;addr&amp;#34;&lt;/span>, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>使用&lt;code>nsenter&lt;/code>命令（简化版&lt;code>setns()&lt;/code>）&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo nsenter --target &lt;span style="color:#ae81ff">1234&lt;/span> --net ip addr
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>【仅源码】C语言通过getaddrinfo函数获取域名的IP地址</title><link>https://jekyulll.github.io/posts/cppc%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87getaddrinfo%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%9F%9F%E5%90%8D%E7%9A%84ip%E5%9C%B0%E5%9D%80/</link><pubDate>Thu, 08 May 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cppc%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87getaddrinfo%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%9F%9F%E5%90%8D%E7%9A%84ip%E5%9C%B0%E5%9D%80/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/socket.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;netdb.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;arpa/inet.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2025/05/08
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// C语言通过getaddrinfo函数获取域名的IP地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">addrinfo&lt;/span> hints, &lt;span style="color:#f92672">*&lt;/span>res, &lt;span style="color:#f92672">*&lt;/span>p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> status;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> ipstr[INET6_ADDRSTRLEN];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 初始化hints结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>hints, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span> hints);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hints.ai_family &lt;span style="color:#f92672">=&lt;/span> AF_UNSPEC; &lt;span style="color:#75715e">// IPv4 或者 IPv6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> hints.ai_socktype &lt;span style="color:#f92672">=&lt;/span> SOCK_STREAM; &lt;span style="color:#75715e">// TCP 套接字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取地址信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> ((status &lt;span style="color:#f92672">=&lt;/span> getaddrinfo(&lt;span style="color:#e6db74">&amp;#34;www.baidu.com&amp;#34;&lt;/span>, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>hints, &lt;span style="color:#f92672">&amp;amp;&lt;/span>res)) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fprintf(stderr, &lt;span style="color:#e6db74">&amp;#34;getaddrinfo error: %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, gai_strerror(status));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 遍历地址列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(p &lt;span style="color:#f92672">=&lt;/span> res; p &lt;span style="color:#f92672">!=&lt;/span> NULL; p &lt;span style="color:#f92672">=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ipver;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取 IP 地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_family &lt;span style="color:#f92672">==&lt;/span> AF_INET) { &lt;span style="color:#75715e">// IPv4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ipv4 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>(ipv4&lt;span style="color:#f92672">-&amp;gt;&lt;/span>sin_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ipver &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;IPv4&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#75715e">// IPv6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in6&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ipv6 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in6&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>(ipv6&lt;span style="color:#f92672">-&amp;gt;&lt;/span>sin6_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ipver &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;IPv6&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将二进制 IP 地址转换为文本格式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> inet_ntop(p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ai_family, addr, ipstr, &lt;span style="color:#66d9ef">sizeof&lt;/span> ipstr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%s: %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, ipver, ipstr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 释放地址信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> freeaddrinfo(res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Redis Stream和MQ</title><link>https://jekyulll.github.io/posts/redis-redis-stream%E5%92%8Cmq/</link><pubDate>Mon, 05 May 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/redis-redis-stream%E5%92%8Cmq/</guid><description>&lt;p>常见MQ的功能，有哪些是用Redis实现不了的？&lt;/p>
&lt;p>消息队列（MQ）用于解耦系统、异步处理、削峰填谷等，常见的 MQ 有 RabbitMQ、Kafka、RocketMQ、ActiveMQ 等。而 Redis 也提供了发布/订阅（pub/sub）、List 队列、Stream（流）等机制，看似也能实现部分消息队列的功能。&lt;/p>
&lt;hr>
&lt;h3 id="-redis-能做的-mq-功能">✅ Redis 能做的 MQ 功能：&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>功能&lt;/th>
 &lt;th>Redis 支持方式&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>简单队列&lt;/td>
 &lt;td>使用 &lt;code>List&lt;/code> 的 &lt;code>LPUSH + BRPOP&lt;/code> 实现&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>发布订阅&lt;/td>
 &lt;td>使用 &lt;code>Pub/Sub&lt;/code> 功能&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>消息流&lt;/td>
 &lt;td>使用 &lt;code>Stream&lt;/code> 类型（自 Redis 5.0 起）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>消息持久化（有限）&lt;/td>
 &lt;td>Redis 有持久化机制（RDB、AOF）&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="-redis-实现不了或不擅长的-mq-功能">❌ Redis 实现不了或不擅长的 MQ 功能：&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>功能&lt;/th>
 &lt;th>原因&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>消息可靠投递（ACK 确认机制）&lt;/strong>&lt;/td>
 &lt;td>Redis 的 Pub/Sub 没有消费确认机制，Stream 有但比较弱（如无消费失败自动重试机制）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>高吞吐量/分布式日志系统（如 Kafka）&lt;/strong>&lt;/td>
 &lt;td>Redis 不适合大规模日志或百万 TPS 场景，且不具备分区（partition）机制&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>消费失败后的重试机制、死信队列（DLQ）&lt;/strong>&lt;/td>
 &lt;td>Redis 不原生支持，需要手动构建（逻辑复杂且不够健壮）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>消费顺序保障（partition+offset）&lt;/strong>&lt;/td>
 &lt;td>Redis Stream 提供 ID 顺序，但无法如 Kafka 那样做严格的有序分区消费&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>持久性保证和磁盘容量优化&lt;/strong>&lt;/td>
 &lt;td>Redis 为内存数据库，持久性和存储成本远不如 Kafka 等磁盘级 MQ&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>消息积压处理能力强&lt;/strong>&lt;/td>
 &lt;td>Redis 基于内存，积压消息多了容易 OOM，Kafka 之类基于磁盘无此问题&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>事务性消息支持（如 RocketMQ）&lt;/strong>&lt;/td>
 &lt;td>Redis 不支持事务性消息逻辑&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>消费者分组与负载均衡（Consumer Group）&lt;/strong>&lt;/td>
 &lt;td>Redis Stream 有些类似功能，但不如 Kafka 灵活和成熟&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>流控和限速、幂等机制支持&lt;/strong>&lt;/td>
 &lt;td>Redis 需要自己实现，Kafka 等 MQ 内建支持&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;ul>
&lt;li>Redis 可以用来实现轻量级、简单或低吞吐的消息队列系统；&lt;/li>
&lt;li>Kafka、RabbitMQ、RocketMQ 等更适合需要&lt;strong>高可靠性、分布式、高吞吐、复杂消息模式&lt;/strong>的场景；&lt;/li>
&lt;li>Redis 适合“玩具级”或轻量任务队列，&lt;strong>不推荐在企业级复杂系统中用作核心 MQ&lt;/strong>。&lt;/li>
&lt;/ul></description></item><item><title>[linux] TODO 守护进程，setsid，Linux三个id，权限</title><link>https://jekyulll.github.io/posts/linux-todo-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8Bsetsidlinux%E4%B8%89%E4%B8%AAid%E6%9D%83%E9%99%90/</link><pubDate>Tue, 29 Apr 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-todo-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8Bsetsidlinux%E4%B8%89%E4%B8%AAid%E6%9D%83%E9%99%90/</guid><description>&lt;p>复习：&lt;a href="https://blog.csdn.net/JMW1407/article/details/108412836">【Linux】守护进程（ Daemon）的定义，作用，创建流程&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/liaowenxiong/article/details/116401524">Linux 命令之 &lt;code>locale&lt;/code> &amp;ndash; 设置和显示程序运行的语言环境&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>使用 &lt;code>locale&lt;/code> 命令来设置和显示程序运行的语言环境，&lt;code>locale&lt;/code> 会根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统定义一个软件运行时的语言环境。&lt;br>
&lt;code>locale&lt;/code> 由ANSI C提供支持。&lt;code>locale&lt;/code> 的命名规则为&lt;code>&amp;lt;语言&amp;gt;_&amp;lt;地区&amp;gt;.&amp;lt;字符集编码&amp;gt;&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://blog.csdn.net/fmeng23/article/details/23115989">深刻理解——real user id, effective user id, saved user id in Linux&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/ybxuwei/article/details/23563423">Linux进程权限的研究——real user id, effective user id, saved set-user-id&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo $UID
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[linux] 在wezterm里使用tmux实现history restore 保存历史会话</title><link>https://jekyulll.github.io/posts/linux-tmux%E5%AE%9E%E7%8E%B0wezterm%E4%BF%9D%E5%AD%98%E4%BC%9A%E8%AF%9D/</link><pubDate>Tue, 29 Apr 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-tmux%E5%AE%9E%E7%8E%B0wezterm%E4%BF%9D%E5%AD%98%E4%BC%9A%E8%AF%9D/</guid><description>&lt;hr>
&lt;p>知乎链接：https://zhuanlan.zhihu.com/p/1961547067106259944&lt;/p>
&lt;p>wezterm在打开主进程、或者ctrl+alt+t新建tab的时候默认是空的shell会话，有时候不够方便。&lt;/p>
&lt;p>tmux可以轻松解决痛点，但是如果设置wezterm的default_prog为tmux（即每次会话都启动）：在wezterm里新建tab，你会发现和之前共享同一个tmux，相当于wezterm自带的tab功能没用了。&lt;/p>
&lt;pre>&lt;code>config.default_prog = { &amp;quot;/usr/bin/tmux&amp;quot;, &amp;quot;new-session&amp;quot;, &amp;quot;-A&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;main&amp;quot; }
&lt;/code>&lt;/pre>
&lt;p>于是：能否只让wezterm的第一个tab始终开启一个tmux来保存会话，其他tab则使用默认的新建shell功能？&lt;/p>
&lt;p>具体实现：&lt;/p>
&lt;pre>&lt;code>-- 第一个tab打开tmux，之后的为空的shell
local tmux_started = false
wezterm.on(&amp;quot;gui-startup&amp;quot;, function(cmd)
	-- 启动 wezterm 时自动打开一个 window
	local tab, pane, window = wezterm.mux.spawn_window(cmd or {})
	if not tmux_started then
		tmux_started = true
		-- 启动 tmux
		pane:send_text(&amp;quot;tmux -u new-session -A -s main\n&amp;quot;)
	end
end)
&lt;/code>&lt;/pre>
&lt;p>加在wezterm配置合适的位置即可。&lt;/p></description></item><item><title>Linux 守护进程</title><link>https://jekyulll.github.io/posts/linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link><pubDate>Tue, 29 Apr 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</guid><description>&lt;p>复习：&lt;a href="https://blog.csdn.net/JMW1407/article/details/108412836">【Linux】守护进程（ Daemon）的定义，作用，创建流程&lt;/a>。&lt;/p>
&lt;p>编写守护进程的一般步骤步骤：&lt;/p>
&lt;ol>
&lt;li>在父进程中执行&lt;code>fork&lt;/code>并&lt;code>exit&lt;/code>退出；&lt;/li>
&lt;li>在子进程中调用&lt;code>setsid&lt;/code>函数创建新的会话；&lt;/li>
&lt;li>在子进程中调用&lt;code>chdir&lt;/code>函数，让根目录&lt;code>/&lt;/code>成为子进程的工作目录；&lt;/li>
&lt;li>在子进程中调用&lt;code>umask&lt;/code>函数，设置进程的&lt;code>umask&lt;/code>为&lt;code>0&lt;/code>；&lt;/li>
&lt;li>在子进程中关闭任何不需要的文件描述符。&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://blog.csdn.net/Change_Improve/article/details/106107317">Linux—umask（创建文件时的掩码）用法详解&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/fmeng23/article/details/23115989">深刻理解——real user id, effective user id, saved user id in Linux&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/ybxuwei/article/details/23563423">Linux进程权限的研究——real user id, effective user id, saved set-user-id&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。&lt;/p>
&lt;/blockquote></description></item><item><title>【1】Blender学习日记-入门</title><link>https://jekyulll.github.io/posts/game-1blender%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%85%A5%E9%97%A8/</link><pubDate>Fri, 25 Apr 2025 06:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/game-1blender%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%85%A5%E9%97%A8/</guid><description>&lt;p>半夜学一下blender。&lt;/p>
&lt;!-- 在Mint上也装了一下。 -->
&lt;p>&lt;a href="https://www.bilibili.com/video/BV14u41147YH">【Kurt】Blender零基础入门教程 | Blender中文区新手必刷教程(已完结)&lt;/a>。第四课著名的珍珠耳环少女，感觉一节课就差不多学会基础操作了，不错。&lt;/p>
&lt;p>&lt;code>N&lt;/code>是变换，&lt;code>S&lt;/code>是size（也可以结合方向轴，在轴向伸缩），&lt;code>R&lt;/code>是旋转（可以输数字，例如&lt;code>R&lt;/code> &lt;code>Z&lt;/code> &lt;code>90&lt;/code>就是在Z轴旋转90度），&lt;code>G&lt;/code>是移动。&lt;br>
新建内容是&lt;code>SHIFT&lt;/code>+&lt;code>A&lt;/code>，&lt;code>F9&lt;/code>可以改段数。&lt;code>SHIFT&lt;/code>+&lt;code>D&lt;/code>复制，移动的时候可以例如按&lt;code>Z&lt;/code>锁定在Z轴上移动。按两下方向轴（例如移动的时候），可以从世界坐标系切换到局部坐标系。&lt;br>
按&lt;code>/&lt;/code>可以单独显示该物体。&lt;br>
在窗口左上角拉一下，能拉出新窗口。新窗口的右上角，可以拉回去。&lt;br>
摄像机模式也可以按&lt;code>N&lt;/code>，在&amp;quot;视图&amp;quot;里把摄像机&amp;quot;锁定到视图方位&amp;quot;，方便调整。&lt;/p>
&lt;p>blender有两个渲染引擎：&lt;em>EEVEE&lt;/em>（快、实时）、&lt;em>CYCLES&lt;/em>（物理写实）。
渲染快捷键F12。&lt;br>
右键物体，平滑着色。右边物体数据属性（绿色三角）-&amp;gt; 法向 -&amp;gt; 自动光滑。&lt;/p>
&lt;p>编辑-&amp;gt;偏好设置里能调整CUDA设置。&lt;br>
发现用CYCLES的时候，切换成GPU渲染不出东西。显示&lt;code>Error CUDA kernel for this graphics card compute capability(8.6) not found&lt;/code>，可能是因为显卡驱动太新——毕竟我用的 2.83 的远古Blender（以前转mmd格式的时候，插件比较老，所以下的老版本）。&lt;/p>
&lt;p>多选之后-&amp;gt;&lt;code>CTRL&lt;/code>+&lt;code>L&lt;/code>-&amp;gt;关联材质。&lt;/p></description></item><item><title>实现服务端断点续传：Go与Nginx</title><link>https://jekyulll.github.io/posts/web-%E5%88%A4%E6%96%ADhttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</link><pubDate>Wed, 23 Apr 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-%E5%88%A4%E6%96%ADhttp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</guid><description>&lt;h3 id="一http协议基础">一、HTTP协议基础&lt;/h3>
&lt;p>HTTP协议通过&lt;strong>Range请求&lt;/strong>实现断点续传：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>客户端请求指定范围&lt;/strong>&lt;br>
客户端在请求头中携带&lt;code>Range&lt;/code>字段，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">GET&lt;/span> /file.zip &lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Range&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">bytes=500-1000&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>服务端响应部分内容&lt;/strong>&lt;br>
若支持范围请求，服务端返回状态码&lt;code>206 Partial Content&lt;/code>及对应数据片段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span> &lt;span style="color:#ae81ff">206&lt;/span> &lt;span style="color:#a6e22e">Partial Content&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Content-Range&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">bytes 500-1000/5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Content-Length&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">501&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>完整性校验机制&lt;/strong>&lt;br>
通过&lt;code>ETag&lt;/code>或&lt;code>Last-Modified&lt;/code>头确保文件未变更，避免续传数据不一致。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二nginx静态资源断点续传">二、Nginx静态资源断点续传&lt;/h3>
&lt;p>Nginx默认支持静态文件的断点续传。需要有以下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">root&lt;/span> &lt;span style="color:#e6db74">/data/files&lt;/span>; &lt;span style="color:#75715e"># 文件存储路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">add_header&lt;/span> &lt;span style="color:#e6db74">Accept-Ranges&lt;/span> &lt;span style="color:#e6db74">bytes&lt;/span>; &lt;span style="color:#75715e"># 声明支持字节范围请求
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>验证方法&lt;/strong>：&lt;br>
使用&lt;code>curl&lt;/code>检测响应头：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -I http://your-domain/static/large-file.iso
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>若输出包含&lt;code>Accept-Ranges: bytes&lt;/code>与&lt;code>Content-Length&lt;/code>，则表明支持续传。&lt;/p>
&lt;hr>
&lt;h3 id="三go实现">三、Go实现&lt;/h3>
&lt;p>对于动态生成的文件（如需鉴权的资源），需手动处理&lt;code>Range&lt;/code>请求。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;net/http&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;strconv&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;strings&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleDownload&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ResponseWriter&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">filePath&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/data/dynamic-file.bin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">file&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Open&lt;/span>(&lt;span style="color:#a6e22e">filePath&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;File not found&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusNotFound&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">file&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fileInfo&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">file&lt;/span>.&lt;span style="color:#a6e22e">Stat&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fileSize&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">Size&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>().&lt;span style="color:#a6e22e">Set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-Length&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">FormatInt&lt;/span>(&lt;span style="color:#a6e22e">fileSize&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>().&lt;span style="color:#a6e22e">Set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ETag&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;\&amp;#34;%x\&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">ModTime&lt;/span>().&lt;span style="color:#a6e22e">UnixNano&lt;/span>()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rangeHeader&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Range&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">rangeHeader&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ServeContent&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>(), &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">ModTime&lt;/span>(), &lt;span style="color:#a6e22e">file&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ranges&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">strings&lt;/span>.&lt;span style="color:#a6e22e">Split&lt;/span>(&lt;span style="color:#a6e22e">rangeHeader&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;=&amp;#34;&lt;/span>)[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">parts&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">strings&lt;/span>.&lt;span style="color:#a6e22e">Split&lt;/span>(&lt;span style="color:#a6e22e">ranges&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">ParseInt&lt;/span>(&lt;span style="color:#a6e22e">parts&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>], &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">64&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">end&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">fileSize&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">parts&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">end&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> = &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">ParseInt&lt;/span>(&lt;span style="color:#a6e22e">parts&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">64&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">start&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">fileSize&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">end&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">fileSize&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Requested range not satisfiable&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusRequestedRangeNotSatisfiable&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>().&lt;span style="color:#a6e22e">Set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-Range&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;bytes %d-%d/%d&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">end&lt;/span>, &lt;span style="color:#a6e22e">fileSize&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>().&lt;span style="color:#a6e22e">Set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-Length&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">FormatInt&lt;/span>(&lt;span style="color:#a6e22e">end&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">WriteHeader&lt;/span>(&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusPartialContent&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">file&lt;/span>.&lt;span style="color:#a6e22e">Seek&lt;/span>(&lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ServeContent&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>(), &lt;span style="color:#a6e22e">fileInfo&lt;/span>.&lt;span style="color:#a6e22e">ModTime&lt;/span>(), &lt;span style="color:#a6e22e">file&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">HandleFunc&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/download&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">handleDownload&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ListenAndServe&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;:8080&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>• 解析&lt;code>Range&lt;/code>请求头并验证范围有效性
• 使用&lt;code>Seek&lt;/code>定位文件指针，返回部分内容
• 通过&lt;code>ETag&lt;/code>实现文件一致性校验&lt;/p></description></item><item><title>C++ 中的乐观锁和悲观锁</title><link>https://jekyulll.github.io/posts/cpp-c++-%E4%B8%AD%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</link><pubDate>Mon, 21 Apr 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E4%B8%AD%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>悲观锁&lt;/strong>（Pessimistic Lock）是一种假设冲突会频繁发生的锁机制。每次数据访问时，都会先加锁，直到操作完成后才释放锁，这样可以确保在锁持有期间，其他线程无法访问这段数据，从而避免了并发冲突。
&lt;strong>乐观锁&lt;/strong>（Optimistic Lock）是一种假设冲突不会频繁发生的锁机制。每次数据访问时，不会加锁，而是在更新数据时检查是否有其他线程修改过数据。如果检测到冲突（数据被其他线程修改过），则重试操作或报错。适用于读多写少的场景。&lt;/p>
&lt;/blockquote>
&lt;p>乐观锁通常实现方式有以下两种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>版本号机制&lt;/strong>：每次读取数据时，读取一个版本号，更新数据时，检查版本号是否变化，如果没有变化，则更新成功，否则重试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>时间戳机制&lt;/strong>：类似版本号机制，通过时间戳来检测数据是否被修改。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>悲观锁性能较低，因为每次操作都需要加锁和解锁。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>乐观锁性能较高，但在高并发写操作下可能会频繁重试，影响性能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>悲观锁适用于并发冲突高、数据一致性要求严格的场景。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>乐观锁适用于并发冲突低、读多写少的场景。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>C++乐观锁实现方式：使用 &lt;strong>CAS（Compare-And-Swap）&lt;/strong> 或 &lt;code>std::atomic&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;thread&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;atomic&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> sharedData(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">optimisticTask&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> oldValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> newValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> oldValue &lt;span style="color:#f92672">=&lt;/span> sharedData.load(); &lt;span style="color:#75715e">// 读取当前值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> newValue &lt;span style="color:#f92672">=&lt;/span> oldValue &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 本地计算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>sharedData.compare_exchange_weak(oldValue, newValue));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Thread &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> id &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; updated sharedData to &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> newValue &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t1(optimisticTask, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t2(optimisticTask, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t1.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t2.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Final sharedData: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> sharedData &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>compare_exchange_weak&lt;/code> 可能会在无冲突时也失败（为性能优化），可以换成 &lt;code>compare_exchange_strong&lt;/code> 更稳定。&lt;/p></description></item><item><title>304 Not Modified 是怎么检测的？</title><link>https://jekyulll.github.io/posts/web-304-not-modified-%E6%98%AF%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E7%9A%84/</link><pubDate>Thu, 17 Apr 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-304-not-modified-%E6%98%AF%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E7%9A%84/</guid><description>&lt;p>&lt;strong>最终判断逻辑由服务端完成&lt;/strong>。&lt;/p>
&lt;p>• &lt;strong>浏览器行为&lt;/strong>（客户端）：&lt;br>
• 浏览器会缓存资源（如 HTML、图片、CSS 等），并根据服务端之前返回的响应头（如 &lt;code>Cache-Control&lt;/code>、&lt;code>Expires&lt;/code>、&lt;code>ETag&lt;/code>、&lt;code>Last-Modified&lt;/code>）决定是否发起&lt;strong>条件请求&lt;/strong>。&lt;br>
• 当缓存过期或页面刷新（非强制刷新）时，浏览器会向服务端发送一个带有&lt;strong>验证头&lt;/strong>的请求，例如：&lt;br>
◦ &lt;code>If-None-Match&lt;/code>（对应服务端之前返回的 &lt;code>ETag&lt;/code>）&lt;br>
◦ &lt;code>If-Modified-Since&lt;/code>（对应服务端之前返回的 &lt;code>Last-Modified&lt;/code>）&lt;/p>
&lt;p>• &lt;strong>服务端行为&lt;/strong>：&lt;br>
• 服务端收到请求后，根据客户端的验证头（&lt;code>If-None-Match&lt;/code> 或 &lt;code>If-Modified-Since&lt;/code>）检查资源是否已修改。&lt;br>
• &lt;strong>如果资源未修改&lt;/strong>，返回 &lt;strong>304 Not Modified&lt;/strong>，且不返回资源内容，仅返回响应头。&lt;br>
• &lt;strong>如果资源已修改&lt;/strong>，返回 &lt;strong>200 OK&lt;/strong> 并附带新内容。&lt;/p>
&lt;p>• &lt;strong>浏览器&lt;/strong>：负责发起条件请求（携带验证头），并根据响应状态码决定是否使用缓存。&lt;br>
• &lt;strong>服务端&lt;/strong>：负责验证资源是否修改，并决定返回 304 或 200。&lt;/p>
&lt;ol>
&lt;li>用户首次访问网页，服务端返回资源，响应头包含：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#a6e22e">OK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ETag&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">&amp;#34;abc123&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Last-Modified&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">Wed, 01 Jan 2024 00:00:00 GMT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cache-Control&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">max-age=3600&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>用户再次访问时，浏览器缓存未过期（&lt;code>max-age=3600&lt;/code> 内）：&lt;br>
• 直接使用缓存，无需请求服务端。&lt;/li>
&lt;li>缓存过期后，浏览器发起条件请求：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">GET&lt;/span> /example.html &lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>If-None-Match&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">&amp;#34;abc123&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>If-Modified-Since&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">Wed, 01 Jan 2024 00:00:00 GMT&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>服务端验证资源未修改，返回：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-http" data-lang="http">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span> &lt;span style="color:#ae81ff">304&lt;/span> &lt;span style="color:#a6e22e">Not Modified&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ETag&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">&amp;#34;abc123&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Last-Modified&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">Wed, 01 Jan 2024 00:00:00 GMT&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>浏览器收到 304 后，继续使用本地缓存。&lt;/li>
&lt;/ol></description></item><item><title>Linux 的CPU保护环，三环和零环</title><link>https://jekyulll.github.io/posts/linux-linux-%E7%9A%84cpu%E4%BF%9D%E6%8A%A4%E7%8E%AF%E4%B8%89%E7%8E%AF%E5%92%8C%E9%9B%B6%E7%8E%AF/</link><pubDate>Sun, 30 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-linux-%E7%9A%84cpu%E4%BF%9D%E6%8A%A4%E7%8E%AF%E4%B8%89%E7%8E%AF%E5%92%8C%E9%9B%B6%E7%8E%AF/</guid><description>&lt;p>Linux系统中的“三环”和“零环”概念源自CPU的&lt;strong>保护环&lt;/strong>（Protection Rings）机制，是操作系统实现权限隔离和安全保护的核心设计。&lt;/p>
&lt;p>x86保护环的完整结构为四层，但实际仅Ring 0和Ring 3被广泛使用：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>零环&lt;/strong>（Ring 0）：
&lt;ul>
&lt;li>又称内核态，是CPU权限最高的运行模式。操作系统内核运行于此环，可直接访问硬件资源（如CPU、内存、I/O设备），执行特权指令（如修改内存映射、中断处理等）。例如，Linux内核的进程调度、内存管理和设备驱动均在此层级运行。&lt;/li>
&lt;li>零环可直接控制硬件，而三环的代码若试图执行特权指令（如直接读写磁盘），CPU会触发异常（如General Protection Fault），强制终止非法操作。这种设计避免了用户程序破坏系统稳定性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>三环&lt;/strong>（Ring 3）：
&lt;ul>
&lt;li>又称用户态，是权限最低的层级。普通应用程序运行于此环，仅能通过系统调用（Syscall）请求内核服务，无法直接操作硬件。例如，用户启动的文本编辑器、浏览器等程序均受此限制。&lt;/li>
&lt;li>用户程序通过系统调用或硬件中断从三环切换到零环。例如，当程序调用&lt;code>open()&lt;/code>函数打开文件时，会触发软中断（如&lt;code>int 0x80&lt;/code>或&lt;code>syscall&lt;/code>指令），内核接管执行文件操作，完成后返回用户态。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.csdn.net/youyou1543724847/article/details/85048490">CPU的运行环, 特权级与保护&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/farmwang/article/details/50094959">原文 ——CPU的运行环, 特权级与保护&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/qq_26962739/article/details/133133574">Linux内核开发之hook系统调用&lt;/a>。&lt;br>
&lt;a href="https://www.cnblogs.com/onetrainee/p/11707130.html">三环进入零环的细节（KiFastCallEntry函数分析）&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/wxy_xx1/article/details/142953401">系统调用之_KUSER_SHARED_DATA&lt;/a>。&lt;/p></description></item><item><title>fork出的子进程是否继承文件描述符表？</title><link>https://jekyulll.github.io/posts/linux-fork%E5%87%BA%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/</link><pubDate>Sat, 29 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-fork%E5%87%BA%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/</guid><description>&lt;p>当通过 &lt;code>fork()&lt;/code> 创建子进程时，子进程会获得父进程文件描述符表的&lt;u>完整副本&lt;/u>。这意味着子进程的文件描述符表中每个条目指向的 系统级文件表项（File Table Entry）与父进程相同。
父子进程共享文件表项中的文件偏移量（Offset）、打开模式（Read/Write Flags）、文件状态标志等信息。例如，如果父进程写入文件后移动了偏移量，子进程会从新的偏移位置继续操作。&lt;/p>
&lt;ul>
&lt;li>修改文件描述符表本身（如关闭 &lt;code>fd&lt;/code>）：子进程的操作不会影响父进程。例如，子进程关闭 fd=3，父进程的 fd=3 仍然有效。&lt;/li>
&lt;li>修改共享的文件表项（如偏移量、状态标志）：子进程的操作会直接影响父进程，因为它们共享同一文件表项。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.csdn.net/DLUTBruceZhang/article/details/8802156">&lt;code>fork()&lt;/code>子进程与父进程之间的文件描述符问题&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/m0_73209194/article/details/130165449">【Linux】进程间通信&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>文件描述符相当于一个逻辑句柄，而&lt;code>open&lt;/code>，&lt;code>close&lt;/code>等函数则是将文件或者物理设备与句柄相关联。&lt;/p>
&lt;/blockquote>
&lt;p>三张表：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>文件描述符表&lt;/strong>：用户区的一部分，除非通过使用文件描述符的函数，否则程序无法对其进行访问。对进程中每个打开的文件，文件描述符表都包含一个条目。&lt;/li>
&lt;li>&lt;strong>系统文件表&lt;/strong>：为系统中所有的进程共享。对每个活动的open, 它都包含一个条目。每个系统文件表的条目都包含文件偏移量、访问模式（读、写、or 读-写）以及指向它的文件描述符表的条目计数。&lt;/li>
&lt;li>&lt;strong>内存索引节点表&lt;/strong>: 对系统中的每个活动的文件（被某个进程打开了），内存中索引节点表都包含一个条目。几个系统文件表条目可能对应于同一个内存索引节点表（不同进程打开同一个文件）。&lt;/li>
&lt;/ul></description></item><item><title>Linux里fork出子进程的时候，哪些内容是共享的？</title><link>https://jekyulll.github.io/posts/linux-linux%E9%87%8Cfork%E5%87%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84/</link><pubDate>Thu, 27 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-linux%E9%87%8Cfork%E5%87%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84/</guid><description>&lt;h3 id="一共享的内容">&lt;strong>一、共享的内容&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>文件描述符与文件状态&lt;/strong>&lt;br>
子进程会继承父进程已打开的文件描述符表，包括文件偏移量、打开模式（如读写权限）和文件状态标志（如&lt;code>O_APPEND&lt;/code>）。例如，若父进程打开了一个文件并写入数据，子进程可通过相同的文件描述符继续操作，且两者的写入位置（偏移量）会相互影响。&lt;br>
• &lt;strong>示例场景&lt;/strong>：父进程向文件写入“Parent”，子进程写入“Child”，最终文件内容会按操作顺序合并（如“ParentChild”或“ChildParent”），具体取决于调度顺序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>信号处理设置&lt;/strong>&lt;br>
子进程继承父进程的信号处理函数（如&lt;code>SIG_IGN&lt;/code>或自定义处理程序）和信号屏蔽集（&lt;code>sigprocmask&lt;/code>的设置）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>用户身份与环境变量&lt;/strong>&lt;br>
子进程继承父进程的用户ID、组ID、环境变量、当前工作目录等身份信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>写时复制（Copy-On-Write）的内存初始状态&lt;/strong>&lt;br>
在未发生写入操作前，父子进程的代码段（&lt;code>.text&lt;/code>）、数据段（&lt;code>.data&lt;/code>、&lt;code>.bss&lt;/code>）、堆、栈等内存区域共享同一物理内存页。一旦某一方尝试修改数据，则会触发写时复制，生成独立的副本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>文件锁&lt;/strong>&lt;br>
通过&lt;code>fcntl&lt;/code>或&lt;code>flock&lt;/code>设置的文件锁会被子进程继承，父子进程对同一文件的锁定操作会相互影响。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二不共享的内容">&lt;strong>二、不共享的内容&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>进程独立属性&lt;/strong>&lt;br>
子进程拥有独立的进程ID（PID）、父进程ID（PPID）、运行时间统计、未决信号队列等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>多线程环境中的线程资源&lt;/strong>&lt;br>
若父进程包含多个线程，子进程仅复制执行&lt;code>fork()&lt;/code>的线程，其他线程不会被继承。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>独立的内存修改&lt;/strong>&lt;br>
通过写时复制机制，父子进程对内存的修改会各自独立。例如，全局变量初始值相同，但修改后互不影响。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>独立的文件描述符关闭操作&lt;/strong>&lt;br>
子进程关闭某个文件描述符不会影响父进程的同名描述符，反之亦然。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="三关键机制写时复制cow">&lt;strong>三、关键机制：写时复制（COW）&lt;/strong>&lt;/h3>
&lt;p>内核通过写时复制技术优化性能：&lt;br>
• &lt;strong>原理&lt;/strong>：&lt;code>fork()&lt;/code>后，父子进程的页表项指向相同的物理内存页，并将这些页标记为只读。当某一进程尝试写入时，触发页错误，内核复制该页并修改权限为可写。&lt;br>
• &lt;strong>优点&lt;/strong>：避免不必要的内存复制，提高资源利用率。&lt;/p>
&lt;hr>
&lt;h3 id="四应用注意事项">&lt;strong>四、应用注意事项&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>文件操作同步&lt;/strong>：父子进程对同一文件描述符的并发写入需通过锁（如&lt;code>flock()&lt;/code>）或原子操作避免竞争。&lt;/li>
&lt;li>&lt;strong>内存共享限制&lt;/strong>：若需主动共享内存，需使用&lt;code>mmap()&lt;/code>或共享内存API（如&lt;code>shmget()&lt;/code>）。&lt;/li>
&lt;li>&lt;strong>僵尸进程处理&lt;/strong>：父进程需通过&lt;code>wait()&lt;/code>回收子进程资源，或注册&lt;code>SIGCHLD&lt;/code>信号处理函数。&lt;/li>
&lt;/ol></description></item><item><title>文件锁（FileLock）的本质与价值</title><link>https://jekyulll.github.io/posts/cpp-%E6%96%87%E4%BB%B6%E9%94%81filelock%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BB%B7%E5%80%BC/</link><pubDate>Wed, 26 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E6%96%87%E4%BB%B6%E9%94%81filelock%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BB%B7%E5%80%BC/</guid><description>&lt;p>在多进程/多线程环境中，Mutex针对的是程序内部的内存数据结构（如链表、哈希表），无法直接控制外部资源（如磁盘文件）。例如，线程A通过Mutex保护一个缓存队列，但若另一个进程直接修改磁盘上的对应文件，Mutex无法拦截。此时可以用文件锁来解决。&lt;/p>
&lt;p>文件锁的核心逻辑是通过独占标记协调资源访问。&lt;/p>
&lt;p>&lt;strong>典型应用场景&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>配置文件的原子性更新&lt;/strong>&lt;br>
多个服务实例同时修改同一配置文件时，未加锁会导致最后的写入覆盖先前内容（例如Nginx配置热更新）&lt;/li>
&lt;li>&lt;strong>日志文件的顺序写入&lt;/strong>&lt;br>
多线程日志系统中，不加锁可能引发日志行交错（如Apache日志滚动的并发问题）&lt;/li>
&lt;li>&lt;strong>分布式系统的资源协调&lt;/strong>&lt;br>
在无中心化锁服务时，通过共享存储（如NFS）的文件锁实现分布式锁（类似ZooKeeper的临时节点机制）&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="c实现文件锁的三种范式">C++实现文件锁的三种范式&lt;/h3>
&lt;h4 id="方案一操作系统原生api工业级方案">&lt;strong>方案一：操作系统原生API（工业级方案）&lt;/strong>&lt;/h4>
&lt;p>&lt;strong>适用场景&lt;/strong>：需要高可靠性、跨平台兼容的生产环境&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;fcntl.h&amp;gt;&lt;/span>&lt;span style="color:#75715e"> &lt;/span>&lt;span style="color:#75715e">// Linux
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;windows.h&amp;gt;&lt;/span>&lt;span style="color:#75715e"> &lt;/span>&lt;span style="color:#75715e">// Windows
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">NativeFileLock&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">explicit&lt;/span> NativeFileLock(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> path) &lt;span style="color:#f92672">:&lt;/span> lock_path(path) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">acquire&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef _WIN32
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Windows通过独占模式创建文件实现锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> h_file &lt;span style="color:#f92672">=&lt;/span> CreateFileA(lock_path.c_str(), GENERIC_WRITE, &lt;span style="color:#ae81ff">0&lt;/span>, 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">nullptr&lt;/span>, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, &lt;span style="color:#66d9ef">nullptr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> h_file &lt;span style="color:#f92672">!=&lt;/span> INVALID_HANDLE_VALUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Linux使用fcntl记录锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(lock_path.c_str(), O_RDWR &lt;span style="color:#f92672">|&lt;/span> O_CREAT, &lt;span style="color:#ae81ff">0644&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fd &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flock lock_struct{};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock_struct.l_type &lt;span style="color:#f92672">=&lt;/span> F_WRLCK; &lt;span style="color:#75715e">// 排他锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> lock_struct.l_whence &lt;span style="color:#f92672">=&lt;/span> SEEK_SET;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> fcntl(fd, F_SETLK, &lt;span style="color:#f92672">&amp;amp;&lt;/span>lock_struct) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">release&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef _WIN32
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> CloseHandle(h_file);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DeleteFileA(lock_path.c_str());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> close(fd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unlink(lock_path.c_str());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef _WIN32
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HANDLE h_file &lt;span style="color:#f92672">=&lt;/span> INVALID_HANDLE_VALUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string lock_path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>技术要点&lt;/strong>：&lt;br>
• Windows通过&lt;code>CREATE_ALWAYS&lt;/code>+隐藏属性实现原子创建&lt;br>
• Linux使用&lt;code>fcntl&lt;/code>的记录锁，支持对文件部分区域加锁&lt;br>
• 必须处理进程崩溃后的锁残留（通过&lt;code>unlink/DeleteFile&lt;/code>物理删除锁文件）&lt;/p></description></item><item><title>更新的二进制差异算法</title><link>https://jekyulll.github.io/posts/alg-%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B7%AE%E5%BC%82%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 26 Mar 2025 04:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/alg-%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B7%AE%E5%BC%82%E7%AE%97%E6%B3%95/</guid><description>&lt;p>替换一个二进制文件有以下两个思路：&lt;/p>
&lt;p>使用完整的一个新文件直接覆盖旧的文件。
只替换新旧文件之间的差异。通过算法去计算新旧文件之间的差异，然后将差异部分移动到目标机器上。
其中方法一制作的更新就叫做全量更新（Full Update）。而方法二就是二进制差分方式，即增量更新（Delta Update）。&lt;/p>
&lt;hr>
&lt;h2 id="增量更新">增量更新&lt;/h2>
&lt;p>增量更新有两个方式：&lt;strong>文件差量更新&lt;/strong>、&lt;strong>二进制差量更新&lt;/strong>。&lt;br>
大部分的大软件，如 QQ 等，都会在自动更新的时候都会使用文件差量更新和二进制差量更新一起使用的策略。&lt;/p>
&lt;p>二进制差分更新对于就文件的状态有严格的要求，这是因为不同版本之间的二进制差异不同。&lt;br>
举个例子：某个新的文件A的版本是3，需要更新到用户的机器上。但是部分用户机器上安装的文件A版本是1，部分用户的文件A是版本2。这种情况下，就需要分别计算版本3和版本1的差异，以及版本3和版本2的差异。然后根据不同用户的情况分别发送不同的二进制差异文件。&lt;br>
想要进行增量更新，需要构建模块支持才能实现。确定性构建就是在代码没有变更的时候，构建输出的 DLL 或 Exe 一定是不变的。对应的，还应加入确定性混淆的支持，有一些代码接入了混淆过程，要求在代码没有变更的时候，最后混淆输出的文件也没有变更。&lt;/p>
&lt;p>增量更新不能热更新，需要重启才能生效。&lt;/p>
&lt;p>用到的算法主要有&lt;a href="https://www.daemonology.net/bsdiff/">bsdiff&lt;/a>，&lt;a href="https://github.com/OctopusDeploy/Octodiff">octodiff&lt;/a>，xdelta。&lt;/p>
&lt;p>bsdiff 算法的时间复杂度和空间复杂度都很高。但优点是更新文件大小比较小。&lt;/p>
&lt;blockquote>
&lt;p>处理大文件选择Octodiff，处理小文件选择bsdiff.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="正向逆向差分技术">正向/逆向差分技术&lt;/h2>
&lt;p>在此之前，为了解决Windows累积更新体积过大的问题，微软使用的是Express Update技术。Express技术确实减小了累积更新的体积，但是却极大的增加了Window更新服务器的计算压力与存储压力。Express更新文件在更新服务器上通常会有大于10GB的体积。Express Update正是使用的增量更新方式，并且把所有文件的所有版本差异都存储到了更新服务器上（海量的文件）。&lt;/p>
&lt;p>Windows 10 1809版本之后引入了基于二进制的正向/逆向差分技术。&lt;/p>
&lt;p>二进制差分是需要严格比对文件的版本信息的。如果被替换文件的版本不确定，那么就无法应用二进制差分。如果本替换文件的版本非常多，那么就需要针对每一个版本分别计算二进制差分，这样一来，不同版本的二进制差分的总和体积也必然不会小，因此就抵消掉差分带来的体积优势。&lt;/p>
&lt;p>正向/逆向差分技术的核心思路是：将被替换文件的版本固定，这样就能唯一确定一个二进制差分了。那么，将被替换的文件版本固定成什么版本呢？&lt;br>
Windows更新用的方法是，将所有需要被更新的文件版本回到Windows 10 基线版本 。然后，从基线版本安装二进制差分，完成文件的更新。&lt;br>
这里，从当前的文件版本回退到基线版本的过程被称为&lt;strong>逆向&lt;/strong>，从基线版本更新到最新的版本的过程称为&lt;strong>正向&lt;/strong>，也被称为&lt;strong>注水&lt;/strong>（hydration）。制作差分二进制叫做&lt;strong>脱水&lt;/strong>（dehydration）。&lt;br>
这两次文件更新的行为都使用差分二进制来完成，因此这就是正向/逆向二进制差分技术。&lt;/p>
&lt;p>核心逻辑在于通过固定基线版本（RTM）作为唯一中间状态，规避多版本组合带来的差分数爆炸问题。&lt;br>
这样只需要存储一个当前版本到基线版本的二进制差分，然后统一从基线版本升级到新版本。&lt;br>
（&lt;em>eg&lt;/em>. 例如有0、1、2、3、4版本。如果用老办法，需要存储0-&amp;gt;1，0-&amp;gt;2，0-&amp;gt;3，0-&amp;gt;4，1-&amp;gt;2，1-&amp;gt;3，1-&amp;gt;4，2-&amp;gt;3，2-&amp;gt;4，3-&amp;gt;4的差分包，多了之后数量爆炸，因为&lt;u>增加新版本的时候需要存储之前所有版本到新版本的差分包&lt;/u>。&lt;br>
如果采用正向/逆向差分，要存储1-&amp;gt;0，2-&amp;gt;0，3-&amp;gt;0，4-&amp;gt;0，然后存储0-&amp;gt;1，0-&amp;gt;2，0-&amp;gt;3，0-&amp;gt;4。增加新版本的时候，只需要增加5-&amp;gt;0和0-&amp;gt;5，从n的累加优化到了n的线性关系的差分包数量。&lt;br>
）&lt;/p>
&lt;p>基于正向/逆向二进制差分的Windows累积更新内部包含以下内容：&lt;/p>
&lt;ul>
&lt;li>从基线版本到最新版本N的正向二进制差分文件&lt;/li>
&lt;li>回退到基线版本所需的逆向二进制差分文件&lt;/li>
&lt;li>更新文件清单（Manifest）&lt;/li>
&lt;li>更新文件Metadata&lt;/li>
&lt;/ul>
&lt;p>如果是离线更新MSU，还会多一些版本以及操作系统适应性判断的内容。&lt;/p>
&lt;hr>
&lt;h3 id="source--reference">Source &amp;amp;&amp;amp; Reference&lt;/h3>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/13382743061">二进制差异文件算法&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://github.com/Squirrel/Squirrel.Windows">Squirrel.Windows: An installation and update framework for Windows desktop apps&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://zhuyie.github.io/posts/bsdiff-annotated/">bsdiff源码解析&lt;/a>。&lt;/p>
&lt;p>这段时间看到的最牛逼的文章：&lt;a href="https://jishuzhan.net/article/1874273746852777985#google_vignette">Windows 客户端软件自动更新服务的开发有哪些需求？&lt;/a>。&lt;/p>
&lt;p>微软官方对正向/逆向二进制差分Updates的介绍：&lt;a href="https://learn.microsoft.com/en-us/windows/deployment/update/forward-reverse-differentials">Windows Updates using forward and reverse differentials&lt;/a>。&lt;/p></description></item><item><title>Nginx 的多进程模型</title><link>https://jekyulll.github.io/posts/web-nginx-%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Fri, 21 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-nginx-%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>在Web服务器领域，Nginx凭借其高并发、低资源消耗的特点脱颖而出。其核心设计选择之一便是&lt;strong>多进程模型&lt;/strong>。这一设计看似与传统多线程模型背道而驰，却恰恰成就了Nginx的卓越性能。本文将从技术原理、场景适配、架构权衡等角度，深度解析Nginx偏爱多进程的底层逻辑。&lt;/p>
&lt;hr>
&lt;h4 id="一多进程模型的核心架构">一、多进程模型的核心架构&lt;/h4>
&lt;p>Nginx采用经典的&lt;strong>Master-Worker多进程架构&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Master进程&lt;/strong>：负责全局管理，包括配置加载、信号处理、Worker进程监控与重启。&lt;/li>
&lt;li>&lt;strong>Worker进程&lt;/strong>：实际处理请求的“战斗单元”，每个Worker独立运行且绑定到特定CPU核心，通过&lt;strong>异步非阻塞事件驱动模型&lt;/strong>处理成千上万的并发连接。&lt;br>
这种设计实现了&lt;strong>资源隔离&lt;/strong>与&lt;strong>职责分离&lt;/strong>，Master的稳定性不受Worker业务逻辑影响，Worker的崩溃也不会导致服务中断。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="二选择多进程的五大核心原因">二、选择多进程的五大核心原因&lt;/h4>
&lt;h5 id="1-最大化多核cpu利用率">1. &lt;strong>最大化多核CPU利用率&lt;/strong>&lt;/h5>
&lt;p>现代服务器普遍采用多核架构，Nginx通过为每个Worker进程绑定独立CPU核心，避免了线程上下文切换的开销，使硬件资源被充分调度。例如，8核服务器可启动8个Worker，每个进程独占一核执行无锁化任务处理。&lt;/p>
&lt;h5 id="2-规避多线程锁竞争">2. &lt;strong>规避多线程锁竞争&lt;/strong>&lt;/h5>
&lt;p>多线程模型中，共享内存的访问需通过锁机制同步，而锁竞争会导致性能急剧下降。Nginx的多进程模型天然隔离了内存空间，Worker之间无需加锁，消除了这一性能瓶颈。&lt;/p>
&lt;h5 id="3-故障隔离与高可用性">3. &lt;strong>故障隔离与高可用性&lt;/strong>&lt;/h5>
&lt;p>若某个Worker进程因代码缺陷崩溃，Master进程可立即重启新Worker，其他进程仍正常服务。这种“单点故障不影响全局”的特性，显著提升了系统的容错能力。相比之下，多线程模型中线程崩溃可能导致整个进程宕机。&lt;/p>
&lt;h5 id="4-简化开发与维护">4. &lt;strong>简化开发与维护&lt;/strong>&lt;/h5>
&lt;p>多进程模型的代码结构更清晰：&lt;br>
• Worker之间无共享状态，避免复杂的线程同步逻辑&lt;br>
• 调试时可通过&lt;code>gdb&lt;/code>单独附加到某个Worker进程，无需处理线程交织问题&lt;/p>
&lt;h5 id="5-与事件驱动模型的完美契合">5. &lt;strong>与事件驱动模型的完美契合&lt;/strong>&lt;/h5>
&lt;p>Nginx的&lt;strong>异步非阻塞I/O多路复用&lt;/strong>（如Linux的epoll）是其高并发的另一基石。每个Worker进程通过单线程循环处理事件，避免了传统多进程模型中“一请求一进程”的资源浪费。这种组合使得单个Worker即可高效管理数万连接。&lt;/p>
&lt;hr>
&lt;h4 id="三多进程模型的局限性">三、多进程模型的局限性&lt;/h4>
&lt;p>尽管优势显著，该模型也存在以下挑战：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>内存占用较高&lt;/strong>：每个Worker需独立的内存空间，连接数极高时可能产生冗余开销。&lt;/li>
&lt;li>&lt;strong>进程间通信复杂&lt;/strong>：共享数据需通过IPC（如共享内存），开发复杂度高于线程模型。&lt;/li>
&lt;li>&lt;strong>计算密集型场景劣势&lt;/strong>：若请求涉及大量CPU运算（如加密解密），多线程模型可能更高效。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="四与其他模型的对比分析">四、与其他模型的对比分析&lt;/h4>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>模型类型&lt;/th>
 &lt;th>典型代表&lt;/th>
 &lt;th>适用场景&lt;/th>
 &lt;th>Nginx的选择依据&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>多进程单线程&lt;/strong>&lt;/td>
 &lt;td>Nginx&lt;/td>
 &lt;td>I/O密集型高并发&lt;/td>
 &lt;td>规避锁竞争，隔离故障&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>单进程多线程&lt;/strong>&lt;/td>
 &lt;td>Apache&lt;/td>
 &lt;td>计算密集型任务&lt;/td>
 &lt;td>线程崩溃风险高，调试复杂&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>协程模型&lt;/strong>&lt;/td>
 &lt;td>Go&lt;/td>
 &lt;td>高并发微服务&lt;/td>
 &lt;td>需语言运行时支持，生态差异&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h4 id="五设计启示如何选择并发模型">五、设计启示：如何选择并发模型？&lt;/h4>
&lt;p>Nginx的实践为高并发系统设计提供了重要参考：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>区分任务类型&lt;/strong>：I/O密集型首选事件驱动+多进程，计算密集型可考虑多线程。&lt;/li>
&lt;li>&lt;strong>权衡开发成本&lt;/strong>：多进程模型更易实现稳定性，但需额外处理IPC；多线程开发门槛更高。&lt;/li>
&lt;li>&lt;strong>利用操作系统特性&lt;/strong>：如Linux的CPU亲和性（affinity）可优化多进程绑定。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="结语">结语&lt;/h4>
&lt;p>Nginx的多进程模型并非偶然，而是针对Web服务器&lt;strong>高并发、低延迟、强稳定&lt;/strong>的核心需求做出的理性权衡。它通过资源隔离、无锁架构与事件驱动的三重设计，在I/O密集型场景中展现了无可替代的优势。正如其作者Igor Sysoev所言：“简单性是可扩展性的基石”——多进程模型正是这一哲学的最佳实践。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>参考资料&lt;/strong>：&lt;br>
[1] 其其网《Nginx为何偏爱多进程模型》&lt;br>
[4][6] CSDN博客《nginx为什么是多进程单线程》&lt;br>
[2][3] CSDN博客《Nginx工作原理》&lt;/p>
&lt;/blockquote></description></item><item><title>流计算中的反向压力模型与 Reactive Streams --C++实现</title><link>https://jekyulll.github.io/posts/web-%E6%B5%81%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E5%8E%8B%E5%8A%9B%E6%A8%A1%E5%9E%8B%E4%B8%8E-reactive-streams---c++%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 21 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-%E6%B5%81%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E5%8E%8B%E5%8A%9B%E6%A8%A1%E5%9E%8B%E4%B8%8E-reactive-streams---c++%E5%AE%9E%E7%8E%B0/</guid><description>&lt;h2 id="一反向压力backpressure的核心意义">一、反向压力（Backpressure）的核心意义&lt;/h2>
&lt;p>在流式计算中，数据生产者的生成速率与消费者的处理速率往往不匹配。若生产者速度远高于消费者，无限制的缓冲会导致&lt;strong>内存溢出&lt;/strong>或&lt;strong>系统崩溃&lt;/strong>。反向压力（Backpressure）机制通过动态调节数据流速，实现生产者与消费者的&lt;strong>速率适配&lt;/strong>，从而保证系统的稳定性与资源可控性。&lt;/p>
&lt;h3 id="11-背压的两种实现模式">1.1 背压的两种实现模式&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>阻塞式反馈&lt;/strong>：通过队列容量限制直接阻塞生产者（如线程等待）。&lt;/li>
&lt;li>&lt;strong>非阻塞式协商&lt;/strong>：通过异步信号（如请求量协商）动态调整生产者速率（Reactive Streams的核心机制）。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="二reactive-streams规范与c映射">二、Reactive Streams规范与C++映射&lt;/h2>
&lt;p>Reactive Streams是异步流处理的&lt;strong>标准化规范&lt;/strong>，定义了四个核心组件：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>组件&lt;/th>
 &lt;th>职责&lt;/th>
 &lt;th>C++类设计示例（伪代码）&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>Publisher&lt;/strong>&lt;/td>
 &lt;td>数据生产者（如传感器、文件读取）&lt;/td>
 &lt;td>&lt;code>class Publisher&amp;lt;T&amp;gt; { virtual void subscribe(Subscriber&amp;lt;T&amp;gt;&amp;amp;) = 0; };&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Subscriber&lt;/strong>&lt;/td>
 &lt;td>数据消费者（如数据库写入、网络发送）&lt;/td>
 &lt;td>&lt;code>class Subscriber&amp;lt;T&amp;gt; { virtual void onNext(const T&amp;amp;) = 0; };&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Subscription&lt;/strong>&lt;/td>
 &lt;td>订阅上下文（背压协商）&lt;/td>
 &lt;td>&lt;code>class Subscription { virtual void request(int n) = 0; };&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Processor&lt;/strong>&lt;/td>
 &lt;td>中间处理节点（如数据过滤、转换）&lt;/td>
 &lt;td>&lt;code>class Processor&amp;lt;T, R&amp;gt; : public Subscriber&amp;lt;T&amp;gt;, Publisher&amp;lt;R&amp;gt; {};&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="21-c实现的核心逻辑">2.1 C++实现的核心逻辑&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 基于条件变量的背压队列（简化版） 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BoundedQueue&lt;/span> { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> buffer; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>mutex mtx; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>condition_variable not_full; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>condition_variable not_empty; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t capacity; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> push(&lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> item) { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(mtx); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> not_full.wait(lock, [&lt;span style="color:#66d9ef">this&lt;/span>] { &lt;span style="color:#66d9ef">return&lt;/span> buffer.size() &lt;span style="color:#f92672">&amp;lt;&lt;/span> capacity; }); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.push(item); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> not_empty.notify_one(); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T &lt;span style="color:#a6e22e">pop&lt;/span>() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(mtx); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> not_empty.wait(lock, [&lt;span style="color:#66d9ef">this&lt;/span>] { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>buffer.empty(); }); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T val &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>move(buffer.front()); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.pop(); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> not_full.notify_one(); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> val; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}; 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明&lt;/strong>：队列满时阻塞&lt;code>push&lt;/code>，空时阻塞&lt;code>pop&lt;/code>，通过条件变量实现生产者-消费者的速率同步。&lt;/p></description></item><item><title>【01】Flet 学习笔记 --Flutter原理</title><link>https://jekyulll.github.io/posts/frontend-01flet-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---flutter%E5%8E%9F%E7%90%86/</link><pubDate>Tue, 18 Mar 2025 06:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/frontend-01flet-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---flutter%E5%8E%9F%E7%90%86/</guid><description>&lt;p>Flutter为何能摆脱浏览器依赖？&lt;/p>
&lt;hr>
&lt;h3 id="一flutter的三层架构从操作系统到界面渲染">一、Flutter的三层架构：从操作系统到界面渲染&lt;/h3>
&lt;p>&lt;strong>1. 嵌入层（Embedder）&lt;/strong>&lt;br>
嵌入层是Flutter与操作系统对话的&amp;quot;翻译官&amp;quot;，负责将Flutter引擎安装到目标平台。例如在Android上，它通过Java/C++与Activity生命周期交互；在iOS上则通过Objective-C桥接UIKit事件。这一层的关键任务是创建绘图表面（Surface）并管理线程模型（如UI线程、GPU线程），为上层渲染提供稳定的运行环境。&lt;/p>
&lt;p>&lt;strong>2. 引擎层（Engine）&lt;/strong>&lt;br>
引擎层是Flutter的心脏，由C++编写，包含三大核心模块：&lt;br>
• &lt;strong>Skia图形引擎&lt;/strong>：Google开源的2D绘图库，直接操控GPU进行像素绘制，无需经过系统原生控件&lt;br>
• &lt;strong>Dart运行时&lt;/strong>：支持JIT（开发热重载）与AOT（发布高性能）双模式编译&lt;br>
• &lt;strong>文本渲染引擎&lt;/strong>：独立处理复杂文字排版（如阿拉伯语从右向左排列）&lt;br>
这些组件共同构建了跨平台的绘图能力，例如滑动列表时，Skia会将图层数据直接提交给GPU渲染管线。&lt;/p>
&lt;p>&lt;strong>3. 框架层（Framework）&lt;/strong>&lt;br>
开发者直接接触的Dart语言层，提供声明式UI组件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-dart" data-lang="dart">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 典型Flutter组件树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Scaffold(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appBar: AppBar(title: Text(&lt;span style="color:#e6db74">&amp;#39;Demo&amp;#39;&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body: ListView.builder(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> itemBuilder: (context, index) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> ListTile(title: Text(&lt;span style="color:#e6db74">&amp;#39;Item &lt;/span>&lt;span style="color:#e6db74">$&lt;/span>index&lt;span style="color:#e6db74">&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>框架层将Widget转化为渲染指令，通过深度优先遍历完成布局计算，最终生成供Skia处理的图层数据。&lt;/p>
&lt;hr>
&lt;h3 id="二自渲染机制">二、自渲染机制&lt;/h3>
&lt;p>传统跨平台方案如React Native需要将JavaScript控件映射为原生组件。Flutter不同：&lt;/p>
&lt;p>&lt;strong>1. 像素级控制&lt;/strong>&lt;br>
通过Skia直接向GPU提交绘图指令，绕过了浏览器渲染流程中的HTML解析、CSS计算、合成层处理等环节。例如在实现渐变色动画时，Flutter引擎直接操作着色器，而Web方案需要处理复杂的CSS动画性能优化。&lt;/p>
&lt;p>&lt;strong>2. 线程模型优化&lt;/strong>&lt;br>
• &lt;strong>UI线程&lt;/strong>：执行Dart代码，构建图层树&lt;br>
• &lt;strong>GPU线程&lt;/strong>：调用Skia生成GL指令&lt;br>
• &lt;strong>IO线程&lt;/strong>：异步加载资源&lt;br>
三线程通过VSync信号同步，确保60FPS流畅渲染。相比之下，浏览器受限于单线程JavaScript和样式重计算，容易出现卡顿。&lt;/p>
&lt;p>&lt;strong>3. 跨平台一致性保障&lt;/strong>&lt;br>
自研渲染引擎避免了不同平台WebView的差异问题。例如在实现Material Design的波纹效果时，Android和iOS会呈现完全相同的动画细节，而传统方案需要分别适配各平台原生控件。&lt;/p>
&lt;hr>
&lt;h3 id="三与浏览器方案的对比">三、与浏览器方案的对比&lt;/h3>
&lt;p>通过实际场景对比传统Web技术与Flutter的差异：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>场景&lt;/th>
 &lt;th>浏览器方案&lt;/th>
 &lt;th>Flutter方案&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>列表滚动&lt;/td>
 &lt;td>依赖DOM更新，易卡顿&lt;/td>
 &lt;td>图层复用，GPU直接合成&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>交互动画&lt;/td>
 &lt;td>CSS过渡可能丢帧&lt;/td>
 &lt;td>基于物理的动画曲线&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>首屏加载&lt;/td>
 &lt;td>需下载完整HTML/CSS/JS&lt;/td>
 &lt;td>预编译Dart代码快速启动&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>内存占用&lt;/td>
 &lt;td>WebView常驻内存较高&lt;/td>
 &lt;td>原生线程管理更高效&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>以电商商品列表为例，Flutter可稳定保持120FPS滚动帧率，而基于Web的方案在快速滑动时容易出现白屏。&lt;/p></description></item><item><title>如何限制C++对象只能在堆或栈上创建？heap only 和 stack only</title><link>https://jekyulll.github.io/posts/cpp-heap-only-%E5%92%8C-stack-only-%E7%9A%84-c++-%E5%AF%B9%E8%B1%A1/</link><pubDate>Sun, 16 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-heap-only-%E5%92%8C-stack-only-%E7%9A%84-c++-%E5%AF%B9%E8%B1%A1/</guid><description>&lt;h2 id="为什么需要限制对象的创建位置">为什么需要限制对象的创建位置？&lt;/h2>
&lt;p>例如一个需要&lt;strong>手动控制生命周期&lt;/strong>的数据库连接池，不希望随便在栈上创建一个然后自动销毁。又或者写了一个轻量级的临时计算工具类，如果每次都在堆上创建，性能反而会下降。&lt;/p>
&lt;p>• ✅ 明确生命周期管理
• ✅ 避免资源泄漏
• ✅ 提升关键路径性能
• ✅ 强制使用最佳实践&lt;/p>
&lt;hr>
&lt;h2 id="一heap-only必须用new创建">一、Heap Only：必须用new创建&lt;/h2>
&lt;h4 id="方法1私有化析构函数">方法1：私有化析构函数&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HeapOnly&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> HeapOnly&lt;span style="color:#f92672">*&lt;/span> Create() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">HeapOnly&lt;/span>(); &lt;span style="color:#75715e">// 工厂方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Suicide&lt;/span>() { &lt;span style="color:#66d9ef">delete&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>; } &lt;span style="color:#75715e">// 起个中二的名字提醒要手动释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>HeapOnly() {} &lt;span style="color:#75715e">// 关键！栈对象无法自动调用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HeapOnly() {} &lt;span style="color:#75715e">// 私有构造
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>原理&lt;/strong>：栈对象在离开作用域时会自动调用析构函数，如果析构是私有的，编译器直接报错。必须通过&lt;code>new&lt;/code>创建，手动调用释放。&lt;/p>
&lt;h4 id="方法2c11用-delete">方法2：C++11，用&lt;code>= delete&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HeapOnly&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> HeapOnly&lt;span style="color:#f92672">*&lt;/span> Create() { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HeapOnly; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 直接禁用拷贝构造和赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HeapOnly(&lt;span style="color:#66d9ef">const&lt;/span> HeapOnly&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HeapOnly&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> HeapOnly&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HeapOnly() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="应用场景">应用场景&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>单例模式&lt;/strong>（比如全局配置管理器）&lt;/li>
&lt;li>&lt;strong>需要多态的对象&lt;/strong>（比如动物基类派生出猫狗子类）&lt;/li>
&lt;li>&lt;strong>重量级资源&lt;/strong>（比如线程池、网络连接池）&lt;/li>
&lt;li>&lt;strong>延迟初始化&lt;/strong>的对象（按需创建）&lt;/li>
&lt;/ol>
&lt;p>eg. 游戏引擎中的资源管理器，所有贴图、模型都通过&lt;code>ResourceManager::LoadTexture()&lt;/code>这类工厂方法创建，确保统一管理。&lt;/p></description></item><item><title>解析LRU与LFU算法及C++实现</title><link>https://jekyulll.github.io/posts/web-%E8%A7%A3%E6%9E%90lru%E4%B8%8Elfu%E7%AE%97%E6%B3%95%E5%8F%8Ac++%E5%AE%9E%E7%8E%B0/</link><pubDate>Sun, 16 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-%E8%A7%A3%E6%9E%90lru%E4%B8%8Elfu%E7%AE%97%E6%B3%95%E5%8F%8Ac++%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>在计算机系统中，缓存是提升性能的核心技术之一。当内存资源有限时，如何高效淘汰无用数据、保留热点数据？**LRU（最近最少使用）&lt;strong>和&lt;/strong>LFU（最不频繁使用）**算法为此提供了经典解决方案。本文将从原理到实践，详解这两种算法，并附完整C++实现代码。&lt;/p>
&lt;ul>
&lt;li>​LRU（Least Recently Used）​
&lt;ul>
&lt;li>基于时间维度，淘汰最久未被访问的数据。例如，若缓存容量为3，依次访问A→B→C→A，则再次插入新数据时，最久未访问的B会被淘汰。其核心假设是：最近被访问的数据未来更可能被使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>​LFU（Least Frequently Used）​
&lt;ul>
&lt;li>基于频率维度，淘汰访问次数最少的数据。例如，若数据A被访问5次，B被访问3次，则优先淘汰B。LFU通过计数器记录访问频次，并可能结合时间衰减机制避免旧高频数据长期占用缓存。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一lru算法时间维度淘汰策略">&lt;strong>一、LRU算法：时间维度淘汰策略&lt;/strong>&lt;/h3>
&lt;h4 id="核心原理">&lt;strong>核心原理&lt;/strong>&lt;/h4>
&lt;p>LRU基于“时间局部性”假设：&lt;strong>最近被访问的数据更可能被再次使用&lt;/strong>。其淘汰策略简单直接——移除最久未访问的数据。例如，若缓存容量为3，访问顺序为A→B→C→A，则新数据插入时淘汰最旧的B。&lt;/p>
&lt;h4 id="c实现">&lt;strong>C++实现&lt;/strong>&lt;/h4>
&lt;p>LRU需高效支持两种操作：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>快速查询&lt;/strong>（哈希表，O(1)）&lt;/li>
&lt;li>&lt;strong>顺序维护&lt;/strong>（双向链表，O(1)调整顺序）&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>数据结构设计&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> key, value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node &lt;span style="color:#f92672">*&lt;/span>prev, &lt;span style="color:#f92672">*&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node(&lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> v) &lt;span style="color:#f92672">:&lt;/span> key(k), value(v), prev(&lt;span style="color:#66d9ef">nullptr&lt;/span>), next(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LRUCache&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> capacity;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, Node&lt;span style="color:#f92672">*&amp;gt;&lt;/span> cache; &lt;span style="color:#75715e">// 哈希表：键到节点映射
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Node &lt;span style="color:#f92672">*&lt;/span>head, &lt;span style="color:#f92672">*&lt;/span>tail; &lt;span style="color:#75715e">// 双向链表头尾哨兵节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">moveToHead&lt;/span>(Node&lt;span style="color:#f92672">*&lt;/span> node) { &lt;span style="color:#75715e">// 将节点移至头部
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> removeNode(node);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addToHead(node);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">removeNode&lt;/span>(Node&lt;span style="color:#f92672">*&lt;/span> node) { &lt;span style="color:#75715e">// 移除节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addToHead&lt;/span>(Node&lt;span style="color:#f92672">*&lt;/span> node) { &lt;span style="color:#75715e">// 头部插入节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev &lt;span style="color:#f92672">=&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LRUCache(&lt;span style="color:#66d9ef">int&lt;/span> cap) &lt;span style="color:#f92672">:&lt;/span> capacity(cap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>); &lt;span style="color:#75715e">// 初始化哨兵节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> tail &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> tail;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> key) { &lt;span style="color:#75715e">// 查询操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> cache.find(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (it &lt;span style="color:#f92672">==&lt;/span> cache.end()) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> moveToHead(it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>second); &lt;span style="color:#75715e">// 更新为最近访问
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>second&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> key, &lt;span style="color:#66d9ef">int&lt;/span> value) { &lt;span style="color:#75715e">// 插入/更新操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (cache.find(key) &lt;span style="color:#f92672">!=&lt;/span> cache.end()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache[key]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> moveToHead(cache[key]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#f92672">*&lt;/span> newNode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node(key, value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache[key] &lt;span style="color:#f92672">=&lt;/span> newNode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addToHead(newNode);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cache.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> capacity) { &lt;span style="color:#75715e">// 触发淘汰
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Node&lt;span style="color:#f92672">*&lt;/span> toDelete &lt;span style="color:#f92672">=&lt;/span> tail&lt;span style="color:#f92672">-&amp;gt;&lt;/span>prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache.erase(toDelete&lt;span style="color:#f92672">-&amp;gt;&lt;/span>key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> removeNode(toDelete);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> toDelete;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>关键点&lt;/strong>：&lt;br>
• 使用&lt;strong>哈希表+双向链表&lt;/strong>实现O(1)操作复杂度&lt;br>
• 头节点存放最新访问数据，尾节点为待淘汰数据&lt;/p></description></item><item><title>【AI】半衰期算法在后端的应用</title><link>https://jekyulll.github.io/posts/web-%E5%8D%8A%E8%A1%B0%E6%9C%9F%E7%AE%97%E6%B3%95%E5%9C%A8%E5%90%8E%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8/</link><pubDate>Mon, 10 Mar 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-%E5%8D%8A%E8%A1%B0%E6%9C%9F%E7%AE%97%E6%B3%95%E5%9C%A8%E5%90%8E%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8/</guid><description>&lt;p>在后端开发中，半衰期算法常用于动态调整数据权重的场景，其核心是通过时间衰减机制平衡实时性与历史价值。以下是其典型应用及实现逻辑：&lt;/p>
&lt;h3 id="一算法原理与公式">一、算法原理与公式&lt;/h3>
&lt;p>半衰期算法基于放射性衰变公式：&lt;strong>M * (1/2)^(t/T)&lt;/strong>，其中：
• &lt;strong>M&lt;/strong>：初始值（如点击量）
• &lt;strong>t&lt;/strong>：时间间隔（如天数）
• &lt;strong>T&lt;/strong>：半衰期周期（如7天）
该公式使数据权重随时间呈指数衰减，例如7天半衰期意味着权重每天减少约10%。&lt;/p>
&lt;h3 id="二核心应用场景">二、核心应用场景&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>热搜排序&lt;/strong>（如微博、腾讯平台）
• 动态平衡点击量与时间衰减：新事件点击量高但衰减快，旧事件点击量低但衰减慢。例如：
◦ 电影类半衰期设为7天（T=7），初始权重1000，单日点击量20000时，2天后权重为 &lt;code>(1000+20000) * (1/2)^(2/7) * 0.8 ≈ 17474.56&lt;/code>。
◦ 小说类半衰期15天（T=15），汽车类30天（T=30），体现不同内容时效性差异。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>推荐系统冷启动&lt;/strong>
• 新内容通过初始权重（如1000）获得曝光机会，同时随时间自然衰减，避免长期占据推荐位。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>动态排行榜&lt;/strong>
• 结合实时数据与历史表现：例如游戏活动榜单，近期活跃玩家通过半衰期快速提升排名，老玩家贡献逐步降低。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="三后端实现要点">三、后端实现要点&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>数据模型设计&lt;/strong>
• 数据库需存储&lt;strong>原始点击量&lt;/strong>和&lt;strong>计算后的排序权重字段&lt;/strong>（如&lt;code>sort_info&lt;/code>），通过定时任务（如每小时）更新权重值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>参数可配置化&lt;/strong>
• 不同业务类型设置独立参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">filmHalfLife&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span>; &lt;span style="color:#75715e">//半衰期周期
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">weight&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.8&lt;/span>; &lt;span style="color:#75715e">//类型权重
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过接口&lt;code>halfLifeFactory&lt;/code>实现多态，支持扩展新类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>防作弊机制&lt;/strong>
• 引入&lt;strong>类型权重系数&lt;/strong>（如电影0.8、汽车0.85），降低刷量对排序的影响。
• 结合IP频率限制、异常点击检测等补充措施。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="四扩展优化方向">四、扩展优化方向&lt;/h3>
&lt;p>• &lt;strong>时间粒度细化&lt;/strong>：将天级计算改为小时级，适应高实时性场景（如突发新闻）。
• &lt;strong>复合衰减策略&lt;/strong>：叠加多个半衰期公式，处理复杂业务逻辑（如短视频热度需同时考虑播放、点赞、分享）。
• &lt;strong>动态调整半衰期&lt;/strong>：通过机器学习根据历史数据自动优化T值。&lt;/p>
&lt;blockquote>
&lt;p>该算法已在实际工程中验证可行性，例如某博客示例中，电影类内容在7天内权重从1000衰减至约400，而汽车类内容30天后仍保留约300权重。开发者可根据业务需求调整公式参数，平衡时效性与长尾效应。&lt;/p>
&lt;/blockquote></description></item><item><title>【AI】C++八股：main函数之前执行了什么？</title><link>https://jekyulll.github.io/posts/cpp-c++%E5%85%AB%E8%82%A1main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BA%86%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 10 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++%E5%85%AB%E8%82%A1main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BA%86%E4%BB%80%E4%B9%88/</guid><description>&lt;h3 id="一_start与__libc_start_call_main的作用">一、&lt;code>_start&lt;/code>与&lt;code>__libc_start_call_main&lt;/code>的作用&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;code>_start&lt;/code>：程序的入口点&lt;/strong>&lt;br>
&lt;u>&lt;code>_start&lt;/code>是Linux环境下C/C++程序的&lt;strong>实际入口函数&lt;/strong>，由链接器自动添加到可执行文件中，负责初始化运行时环境并调用&lt;code>__libc_start_main&lt;/code>。&lt;/u>&lt;br>
它的核心任务包括：&lt;br>
• 设置栈指针（&lt;code>%ebp&lt;/code>清零）、传递参数（如&lt;code>argc&lt;/code>和&lt;code>argv&lt;/code>）到寄存器。&lt;br>
• 加载全局初始化函数（如&lt;code>__libc_csu_init&lt;/code>）和清理函数（如&lt;code>__libc_csu_fini&lt;/code>）。&lt;br>
• 调用&lt;code>__libc_start_main&lt;/code>，并将&lt;code>main&lt;/code>函数地址作为参数传递。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>__libc_start_call_main&lt;/code>：非托管入口的桥梁&lt;/strong>&lt;br>
该函数位于&lt;code>libc.so&lt;/code>中，是&lt;code>__libc_start_main&lt;/code>内部调用的关键步骤，负责&lt;strong>直接触发非托管&lt;code>main&lt;/code>函数的执行&lt;/strong>（例如C++中的全局构造函数完成后，最终调用用户编写的&lt;code>main&lt;/code>函数）。在Linux下，它与&lt;code>__libc_start_main_impl&lt;/code>共同完成用户态到程序主逻辑的过渡。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二c程序在main函数前的执行流程">二、C++程序在&lt;code>main&lt;/code>函数前的执行流程&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>操作系统加载与内存分配&lt;/strong>&lt;br>
• 可执行文件被加载到内存，操作系统分配栈、堆空间，并初始化&lt;code>.data&lt;/code>（已初始化全局变量）和&lt;code>.bss&lt;/code>（未初始化全局变量）段。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>全局变量与静态对象的初始化&lt;/strong>&lt;br>
• &lt;strong>&lt;code>.data&lt;/code>段变量&lt;/strong>：直接赋初值（如&lt;code>float global_float = 3.14&lt;/code>）。&lt;br>
• &lt;strong>&lt;code>.bss&lt;/code>段变量&lt;/strong>：数值类型初始化为0，指针初始化为&lt;code>NULL&lt;/code>。&lt;br>
• &lt;strong>全局对象构造函数&lt;/strong>：在&lt;code>main&lt;/code>前按定义顺序调用（例如&lt;code>AnotherClass another_global_object&lt;/code>的构造函数）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>运行时库的初始化&lt;/strong>&lt;br>
• C++运行时库（如&lt;code>libstdc++&lt;/code>）执行初始化，包括堆管理、异常处理框架等。&lt;br>
• 静态成员变量的初始化（如&lt;code>AnotherClass::static_double = 2.718&lt;/code>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>参数传递与入口跳转&lt;/strong>&lt;br>
• &lt;code>_start&lt;/code>通过&lt;code>__libc_start_main&lt;/code>将&lt;code>argc&lt;/code>、&lt;code>argv&lt;/code>和&lt;code>envp&lt;/code>传递给&lt;code>main&lt;/code>函数，最终通过&lt;code>__libc_start_call_main&lt;/code>触发&lt;code>main&lt;/code>的执行。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="三关键差异与注意事项">三、关键差异与注意事项&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>与Windows的对比&lt;/strong>&lt;br>
• &lt;strong>Linux&lt;/strong>：入口链为&lt;code>_start → __libc_start_main → __libc_start_call_main → main&lt;/code>。&lt;br>
• &lt;strong>Windows&lt;/strong>：入口函数为&lt;code>RtlUserThreadStart&lt;/code>（&lt;code>ntdll.dll&lt;/code>），非托管入口通过&lt;code>BaseThreadInitThunk&lt;/code>（&lt;code>kernel32.dll&lt;/code>）调用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>初始化顺序的潜在问题&lt;/strong>&lt;br>
若全局对象之间存在依赖（如A依赖B），需通过&lt;strong>编译单元顺序控制&lt;/strong>或&lt;code>__attribute__((init_priority))&lt;/code>（GCC扩展）强制指定初始化顺序，避免未定义行为。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>C++程序的启动过程远不止&lt;code>main&lt;/code>函数的执行，其核心在于操作系统和运行时库的协作初始化。理解&lt;code>_start&lt;/code>与&lt;code>__libc_start_call_main&lt;/code>的作用，以及全局对象的构造顺序，对于调试启动崩溃、优化资源初始化至关重要。例如，若程序在&lt;code>main&lt;/code>前崩溃，需优先排查全局对象的构造函数或静态变量初始化逻辑。&lt;/p></description></item><item><title>【AI】使用普通的互斥锁实现读写锁</title><link>https://jekyulll.github.io/posts/cpp-%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 10 Mar 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>&lt;p>核心在于通过&lt;strong>状态管理&lt;/strong>和&lt;strong>锁的组合&lt;/strong>来模拟读写锁的“读共享、写独占”特性。以下是实现思路和具体方法：&lt;/p>
&lt;hr>
&lt;h3 id="一实现原理">一、实现原理&lt;/h3>
&lt;p>读写锁的核心规则是：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>读读共享&lt;/strong>：允许多个读线程并发访问。&lt;/li>
&lt;li>&lt;strong>读写互斥&lt;/strong>：读线程和写线程不能同时访问。&lt;/li>
&lt;li>&lt;strong>写写互斥&lt;/strong>：同一时间只能有一个写线程访问。&lt;/li>
&lt;/ol>
&lt;p>使用普通互斥锁（&lt;code>std::mutex&lt;/code>）和计数器可以实现这一逻辑：&lt;br>
• &lt;strong>读计数器&lt;/strong>：统计当前活跃的读线程数量。&lt;br>
• &lt;strong>写互斥锁&lt;/strong>：确保写操作的独占性。&lt;br>
• &lt;strong>状态保护锁&lt;/strong>：保护读计数器和写锁状态的原子性。&lt;/p>
&lt;hr>
&lt;h3 id="二实现步骤">二、实现步骤&lt;/h3>
&lt;h4 id="1-定义关键成员变量">1. 定义关键成员变量&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;condition_variable&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ReadWriteLock&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>mutex counter_mutex; &lt;span style="color:#75715e">// 保护读计数器和写标志
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>mutex write_mutex; &lt;span style="color:#75715e">// 写操作的独占锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> reader_count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// 当前活跃的读线程数量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> write_pending &lt;span style="color:#f92672">=&lt;/span> false; &lt;span style="color:#75715e">// 是否有写线程在等待
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>condition_variable read_cv, write_cv;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-读锁的获取与释放">2. 读锁的获取与释放&lt;/h4>
&lt;p>• &lt;strong>获取读锁&lt;/strong>：&lt;br>
当无写线程运行时，允许读线程进入；若存在写线程等待，则阻塞新读线程（避免写饥饿）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">read_lock&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(counter_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 等待直到没有写线程在等待或运行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> read_cv.wait(lock, [&lt;span style="color:#66d9ef">this&lt;/span>] { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>write_pending; });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reader_count&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (reader_count &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write_mutex.lock(); &lt;span style="color:#75715e">// 第一个读线程获取写锁，阻止写操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>• &lt;strong>释放读锁&lt;/strong>：&lt;br>
减少读计数器，若最后一个读线程退出，则释放写锁并通知可能的等待写线程。&lt;/p></description></item><item><title>【AI】mmap 和零拷贝</title><link>https://jekyulll.github.io/posts/linux-mmap-%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link><pubDate>Fri, 07 Mar 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-mmap-%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid><description>&lt;p>mmap（Memory Mapping）是Unix/Linux系统中的一种重要机制，它允许将文件或设备直接映射到进程的虚拟地址空间，从而将文件操作与内存操作高效结合。以下从核心机制、与IO的关系、与内存分配的关系三个方面详细解析：&lt;/p>
&lt;hr>
&lt;h3 id="一mmap的核心机制">一、mmap的核心机制&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>系统调用与映射方式&lt;/strong>：
• &lt;strong>函数原型&lt;/strong>：&lt;code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);&lt;/code>
• &lt;strong>关键参数&lt;/strong>：
◦ &lt;code>prot&lt;/code>：控制读写权限（如&lt;code>PROT_READ&lt;/code>、&lt;code>PROT_WRITE&lt;/code>）。
◦ &lt;code>flags&lt;/code>：决定映射类型（&lt;code>MAP_SHARED&lt;/code>、&lt;code>MAP_PRIVATE&lt;/code>、&lt;code>MAP_ANONYMOUS&lt;/code>）。
• &lt;strong>两种主要映射&lt;/strong>：
◦ &lt;strong>文件映射&lt;/strong>：将文件映射到内存，修改可同步到文件（&lt;code>MAP_SHARED&lt;/code>）或仅进程可见（&lt;code>MAP_PRIVATE&lt;/code>）。
◦ &lt;strong>匿名映射&lt;/strong>：不关联文件，用于进程间共享内存或动态内存分配（&lt;code>MAP_ANONYMOUS&lt;/code>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>实现原理&lt;/strong>：
• &lt;strong>虚拟内存管理&lt;/strong>：mmap在进程的虚拟地址空间中划分一段区域（通常位于堆与栈之间），通过页表映射到物理内存或文件的页缓存。
• &lt;strong>按需加载（Demand Paging）&lt;/strong>：访问映射内存时触发缺页中断，内核自动将文件数据加载到物理内存，减少一次性加载开销。
• &lt;strong>同步机制&lt;/strong>：修改后的数据由内核异步写回文件，也可通过&lt;code>msync()&lt;/code>强制同步。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二mmap与io的关系">二、mmap与IO的关系&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>传统IO的瓶颈&lt;/strong>：
• &lt;strong>数据拷贝开销&lt;/strong>：&lt;code>read()&lt;/code>/&lt;code>write()&lt;/code>需要在内核缓冲区（页缓存）与用户空间之间复制数据，频繁系统调用和拷贝降低性能。
• &lt;strong>小文件问题&lt;/strong>：多次系统调用对小文件不友好，增加上下文切换开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>mmap的优势&lt;/strong>：
• &lt;strong>零拷贝（Zero-Copy）&lt;/strong>：直接操作映射内存，省去用户态与内核态的数据拷贝。
• &lt;strong>减少系统调用&lt;/strong>：通过内存访问隐式完成文件读写，无需显式调用&lt;code>read()&lt;/code>/&lt;code>write()&lt;/code>。
• &lt;strong>高效大文件处理&lt;/strong>：按需加载，避免一次性加载大文件的延迟和内存浪费。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能对比&lt;/strong>：
• &lt;strong>顺序访问&lt;/strong>：mmap与&lt;code>read()&lt;/code>性能接近，但省去拷贝时间。
• &lt;strong>随机访问&lt;/strong>：mmap显著优于传统IO，减少多次&lt;code>lseek()&lt;/code>和&lt;code>read()&lt;/code>的开销。
• &lt;strong>适用场景&lt;/strong>：适合频繁读写或需要随机访问的大文件（如数据库、图像处理）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="三mmap与内存分配的关系">三、mmap与内存分配的关系&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>动态内存分配&lt;/strong>：
• &lt;strong>glibc的malloc策略&lt;/strong>：
◦ 小块内存（如&amp;lt;128KB）使用&lt;code>brk()&lt;/code>扩展堆内存。
◦ 大块内存使用&lt;code>mmap(MAP_ANONYMOUS)&lt;/code>独立映射，避免内存碎片。
• &lt;strong>优势&lt;/strong>：&lt;code>mmap&lt;/code>分配的内存可独立释放（&lt;code>munmap()&lt;/code>），而&lt;code>brk()&lt;/code>释放需依赖堆顶内存释放顺序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>匿名映射的应用&lt;/strong>：
• &lt;strong>进程间共享内存&lt;/strong>：通过&lt;code>MAP_SHARED&lt;/code>标志，多个进程可共享同一物理内存，高效通信。
• &lt;strong>自定义内存管理&lt;/strong>：替代&lt;code>malloc&lt;/code>，用于需要精细控制的大内存分配（如内存池）。&lt;/p></description></item><item><title>内核的用户态和内核态</title><link>https://jekyulll.github.io/posts/linux-%E5%86%85%E6%A0%B8%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</link><pubDate>Fri, 07 Mar 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E5%86%85%E6%A0%B8%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</guid><description>&lt;p>线程的管理和调度涉及用户态与内核态的协作，不同编程语言和操作系统对线程的处理方式也有所差异。&lt;/p>
&lt;hr>
&lt;h3 id="一线程概念的双重性用户态与内核态的交织">一、线程概念的双重性：用户态与内核态的交织&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>用户态线程（用户级线程）&lt;/strong>&lt;br>
用户态线程由用户空间的线程库直接管理，内核对其无感知。这类线程的创建、调度、同步等操作完全在用户空间完成，无需内核介入。&lt;br>
存在明显局限性：&lt;br>
• &lt;strong>阻塞问题&lt;/strong>：若一个用户态线程因系统调用阻塞（如I/O操作），整个进程的所有线程都会被阻塞；
• &lt;strong>多核利用率低&lt;/strong>：内核无法将用户态线程调度到多个CPU核心上运行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>内核态线程（内核级线程）&lt;/strong>&lt;br>
内核直接管理线程的创建、调度和销毁，每个线程对应一个内核线程（如Linux的轻量级进程LWP）。&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>轻量级进程&lt;/em>（Light Weight Process, LWP）作为用户线程与内核线程的桥梁，负责处理系统调用、资源分配和CPU映射。当用户线程发起系统调用时，LWP接管请求，避免因单个用户线程阻塞导致整个进程挂起。&lt;/p>
&lt;/blockquote>
&lt;p>• &lt;strong>多核并行&lt;/strong>：内核可将不同线程分配到多个CPU核心；
• &lt;strong>独立阻塞&lt;/strong>：单个线程阻塞不会影响其他线程；
• &lt;strong>切换开销大&lt;/strong>：线程切换需通过内核态，涉及用户栈和内核栈的切换、寄存器保存与恢复等操作。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="二内核如何处理线程">二、内核如何处理线程？&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>线程模型的映射关系&lt;/strong>&lt;br>
现代操作系统（如Linux）通常采用&lt;strong>混合型线程模型&lt;/strong>。内核通过以下机制管理线程：&lt;br>
• &lt;strong>TCB（线程控制块）&lt;/strong>：存储线程的内核栈指针、状态、优先级等信息（进程控制块是PCB）；
• &lt;strong>调度器&lt;/strong>：基于时间片轮转或优先级策略分配CPU资源，触发上下文切换。&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>混合型线程模型&lt;/em>（Hybrid Thread Model）是一种结合用户级线程（ULT）和内核级线程（KLT）优势的线程实现方式。通过N:M映射实现用户线程与内核线程的关联，即多个用户线程（N）动态绑定到少量内核线程（M）。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>用户态与内核态的切换机制&lt;/strong>&lt;br>
当线程执行系统调用、发生异常或中断时，会触发用户态到内核态的切换：&lt;br>
• &lt;strong>系统调用流程&lt;/strong>：用户线程通过中断（如Linux的&lt;code>int 80h&lt;/code>）进入内核态，内核完成操作后恢复用户态执行；
• &lt;strong>上下文保存&lt;/strong>：切换时需要保存用户栈的寄存器状态（如程序计数器、栈指针）到内存，并加载内核栈信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能优化策略&lt;/strong>&lt;br>
内核通过以下方式减少切换开销：&lt;br>
• &lt;strong>避免频繁切换&lt;/strong>：采用无锁编程、CAS算法等减少线程竞争；
• &lt;strong>轻量级进程（LWP）&lt;/strong>：通过线程池复用内核线程，降低创建销毁成本。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="三语言案例">三、语言案例&lt;/h3>
&lt;p>Java线程在JDK1.2之后采用&lt;em>1:1模型&lt;/em>，每个Java线程对应一个内核线程。
支持多核并行、避免单线程阻塞影响整体进程；线程创建和切换需要内核介入。&lt;/p>
&lt;p>C++11及之后的标准库（如&lt;code>&amp;lt;thread&amp;gt;&lt;/code>）通过&lt;code>std::thread&lt;/code>直接调用操作系统线程（如Linux的POSIX线程或Windows线程），采用&lt;em>1:1线程模型&lt;/em>。&lt;/p>
&lt;p>Go未直接使用操作系统线程，而是通过Goroutine实现并发。Goroutine由Go运行时调度，采用M:N线程模型​（多个Goroutine映射到少量内核线程），由运行时动态分配CPU时间片。&lt;/p></description></item><item><title>进程、线程、协程的资源消耗简述</title><link>https://jekyulll.github.io/posts/linux-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%E7%AE%80%E8%BF%B0/</link><pubDate>Fri, 07 Mar 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%E7%AE%80%E8%BF%B0/</guid><description>&lt;p>&lt;strong>一、线程切换 vs 进程切换&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>地址空间与页表&lt;/strong>&lt;br>
进程拥有独立的虚拟地址空间和页表，切换进程时需更新页表并刷新 &lt;strong>TLB（地址转换缓存）&lt;/strong>，导致内存访问速度下降。而线程共享进程的地址空间和页表，切换时无需此操作，TLB 缓存保持有效。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>上下文保存的内容&lt;/strong>&lt;br>
• &lt;strong>进程切换&lt;/strong>：需保存完整的上下文，包括寄存器、程序计数器、栈指针、内存映射、文件描述符等。&lt;br>
• &lt;strong>线程切换&lt;/strong>：仅需保存线程私有的寄存器、栈和程序计数器，共享资源（如代码段、文件）无需处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缓存利用率&lt;/strong>&lt;br>
进程切换会导致 CPU 缓存（如 L1/L2/L3）失效，需重新加载数据，降低性能。线程切换时，缓存因共享地址空间仍有效，减少了数据重载的开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>资源分配&lt;/strong>&lt;br>
进程是资源分配的基本单位（如内存、文件），切换时需重新分配资源；线程共享进程资源，切换仅涉及执行流调度。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>二、协程切换 vs 线程切换&lt;/strong>&lt;/p>
&lt;p>协程的切换开销更小，原因在于其 &lt;strong>用户态调度&lt;/strong> 和 &lt;strong>轻量级设计&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>用户态调度&lt;/strong>&lt;br>
协程切换完全由用户态代码控制，无需陷入内核态，避免了 &lt;strong>用户态-内核态切换&lt;/strong> 的开销。而线程切换需操作系统介入，涉及模式切换和内核调度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>上下文信息更少&lt;/strong>&lt;br>
协程只需保存少量寄存器（如 PC、SP）和栈指针，且栈空间通常仅需 KB 级别（线程栈为 MB 级别）。例如，Go 协程的初始栈仅 2KB，而 Java 线程默认为 1MB。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>非阻塞与协作式调度&lt;/strong>&lt;br>
协程通过主动让出（如 &lt;code>yield&lt;/code> 或 &lt;code>await&lt;/code>）实现协作式调度，减少抢占式调度的竞争和锁需求。线程通常依赖操作系统的抢占式调度，可能因频繁切换导致性能损耗。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>内存与并发效率&lt;/strong>&lt;br>
单线程可运行数万协程（如 Go 的 Goroutine），而同等数量线程会因内存和调度开销过大而崩溃。协程的轻量级特性尤其适合高并发 I/O 密集型任务。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;strong>维度&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>进程切换&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>线程切换&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>协程切换&lt;/strong>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>地址空间&lt;/strong>&lt;/td>
 &lt;td>切换（独立）&lt;/td>
 &lt;td>不切换（共享）&lt;/td>
 &lt;td>不切换（共享）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>上下文大小&lt;/strong>&lt;/td>
 &lt;td>大（含全部资源）&lt;/td>
 &lt;td>较小（仅寄存器）&lt;/td>
 &lt;td>极小（仅关键寄存器）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>调度模式&lt;/strong>&lt;/td>
 &lt;td>内核抢占式&lt;/td>
 &lt;td>内核抢占式&lt;/td>
 &lt;td>用户协作式&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>内存开销&lt;/strong>&lt;/td>
 &lt;td>高（独立资源）&lt;/td>
 &lt;td>中（共享资源）&lt;/td>
 &lt;td>极低（KB 级栈）&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;u>线程通过共享资源减少开销，协程通过用户态轻量级调度进一步优化，两者均通过减少内核参与和资源复用来提升性能&lt;/u>&amp;gt;。&lt;/p></description></item><item><title>在运行的时候，修改并且覆盖该二进制文件会如何？</title><link>https://jekyulll.github.io/posts/linux-%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E4%BF%AE%E6%94%B9%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E8%AF%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BC%9A%E5%A6%82%E4%BD%95/</link><pubDate>Thu, 06 Mar 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E4%BF%AE%E6%94%B9%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E8%AF%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BC%9A%E5%A6%82%E4%BD%95/</guid><description>&lt;blockquote>
&lt;p>Linux上有个二进制程序一直在运行，修改代码后重新编译把原来的二进制程序覆盖了，会怎么样？
该问题来自一道天美后台开发面试题：&lt;a href="https://zhuanlan.zhihu.com/p/677307438">天美一面 后台开发（凉） - 牛客面经的文章 - 知乎&lt;/a>。此处尝试进行回答。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>第一想法一般是：“原程序被操作系统加载进内存，不会受到影响。”&lt;br>
系统会创建一个新的&lt;code>inode&lt;/code>指向新文件，而正在运行的进程仍会继续使用旧的&lt;code>inode&lt;/code>对应的代码段。&lt;/p>
&lt;p>但实际上拓展到一个问题：“二进制文件会全部加载到内存吗？”&lt;/p>
&lt;p>ELF二进制文件在加载时，操作系统通常采用按需分页的机制，只将当前需要的部分加载到物理内存，而不是一次性加载整个文件。虚拟内存映射允许文件的部分内容驻留在磁盘，直到被访问时才调入内存。&lt;br>
同时，动态链接库的延迟加载和内存映射文件技术（&lt;code>mmap&lt;/code>）也帮助减少实际内存占用。因此，如果二进制文件很大，不会全部加载到物理内存中，而是按需加载，利用虚拟内存管理技术优化资源使用。&lt;/p>
&lt;p>但是：真的会在运行时加载新的内容吗？&lt;/p>
&lt;p>ELF文件在启动时如何决定哪些内容加载到内存？主要依赖于其&lt;strong>程序头表&lt;/strong>（Program Header Table）​中定义的段（Segment）信息。程序头表由多个&lt;code>Elf64_Phdr&lt;/code>结构体组成，每个结构体描述了一个需要加载到内存的段（如代码段、数据段、动态链接信息段等）。这些段通常包含多个&lt;em>节&lt;/em>（Section）的集合。&lt;/p>
&lt;p>覆盖原文件后，旧文件的磁盘空间不会被立即释放，需等待所有关联进程结束后才能回收（通过&lt;code>lsof&lt;/code>可查看占用进程）。&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>：&lt;br>
​已运行的进程不受影响：Linux通过&lt;code>inode&lt;/code>标识文件，旧进程继续执行内存中已加载的旧代码，与原磁盘文件解耦。&lt;/p>
&lt;hr>
&lt;h3 id="1-elf文件的按需加载机制">1. &lt;strong>ELF文件的按需加载机制&lt;/strong>&lt;/h3>
&lt;p>ELF二进制文件通过&lt;strong>程序头表（Program Header Table）&lt;strong>中的&lt;code>PT_LOAD&lt;/code>段描述需要加载的代码和数据区域。内核的&lt;code>load_elf_binary()&lt;/code>函数会将这些段映射到进程的虚拟地址空间，但实际物理内存的占用是&lt;/strong>按需分页&lt;/strong>的：
• 仅当程序访问某个页（通常4KB大小）时，才会触发缺页异常，将对应内容从磁盘加载到物理内存。
• 未使用的代码或数据（如未执行的函数）可能永远不会被加载到物理内存中。&lt;/p>
&lt;h3 id="2-虚拟内存映射与内存优化">2. &lt;strong>虚拟内存映射与内存优化&lt;/strong>&lt;/h3>
&lt;p>• &lt;strong>虚拟内存优势&lt;/strong>：ELF文件通过&lt;code>mmap()&lt;/code>系统调用映射到虚拟地址空间，此时文件内容并不直接占用物理内存，而是由内核通过页表管理。
• &lt;strong>写时复制（Copy-on-Write）&lt;/strong>：对于只读段（如代码段），多个进程可以共享同一物理内存页；对于可写段，修改时才会复制新页。&lt;/p>
&lt;h3 id="3-动态链接与延迟加载">3. &lt;strong>动态链接与延迟加载&lt;/strong>&lt;/h3>
&lt;p>动态链接库（如&lt;code>.so&lt;/code>文件）在程序运行时通过&lt;code>ld-linux&lt;/code>动态加载器按需载入。例如：
• 首次调用某个库函数时，动态链接器才会加载对应的代码段到内存。
• 部分库可能仅在特定条件下被使用，从而减少初始内存占用。&lt;/p>
&lt;h3 id="4-大文件的实际内存占用">4. &lt;strong>大文件的实际内存占用&lt;/strong>&lt;/h3>
&lt;p>• &lt;strong>物理内存限制&lt;/strong>：若二进制文件极大（如8GB），但程序实际执行的代码路径有限，物理内存占用可能远小于文件大小。
• &lt;strong>交换空间（Swap）&lt;/strong>：当物理内存不足时，操作系统会将不活跃的内存页交换到磁盘，腾出空间供当前进程使用。&lt;/p></description></item><item><title>线程池调度：动态优先级老化（Aging）+ 双队列混合轮询</title><link>https://jekyulll.github.io/posts/cpp-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E5%BA%A6%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E8%80%81%E5%8C%96aging+-%E5%8F%8C%E9%98%9F%E5%88%97%E6%B7%B7%E5%90%88%E8%BD%AE%E8%AF%A2/</link><pubDate>Tue, 25 Feb 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E5%BA%A6%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E8%80%81%E5%8C%96aging+-%E5%8F%8C%E9%98%9F%E5%88%97%E6%B7%B7%E5%90%88%E8%BD%AE%E8%AF%A2/</guid><description>&lt;p>C++中线程池一般使用队列（&lt;code>std::queue&lt;/code>）配合外部的&lt;code>std::condition_variable&lt;/code>，或者手动构建阻塞队列（BlockQueue）来设计。&lt;/p>
&lt;p>而需要使用任务优先级的时候，一般使用大根堆/小根堆的优先级队列&lt;code>std::priority_queue&lt;/code>来实现。&lt;/p>
&lt;p>那么问题来了，在任务优先级比较不均的时候，怎么避免低优先级任务的长时间饥饿呢？&lt;/p>
&lt;p>为了实现动态公平调度：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>动态优先级老化（Aging）：优先级动态调整&lt;/strong>：任务在队列中等待时间越长，其有效优先级逐渐升高。&lt;/li>
&lt;li>&lt;strong>双队列混合轮询&lt;/strong>：每处理一定数量的高优先级任务后，强制处理低优先级任务。&lt;/li>
&lt;/ul>
&lt;p>首先抽象出一个&lt;code>Task&lt;/code>用于记录任务的初始优先级和入队时间：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;chrono&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Task&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> base_priority; &lt;span style="color:#75715e">// 初始优先级
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>steady_clock&lt;span style="color:#f92672">::&lt;/span>time_point enqueue_time;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> job;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 计算动态优先级（等待时间越长，优先级越高）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">dynamic_priority&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> now &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>steady_clock&lt;span style="color:#f92672">::&lt;/span>now();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> wait_time &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>duration_cast&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>seconds&lt;span style="color:#f92672">&amp;gt;&lt;/span>(now &lt;span style="color:#f92672">-&lt;/span> enqueue_time).count();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> base_priority &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(wait_time &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0.1&lt;/span>); &lt;span style="color:#75715e">// 老化系数可调
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 重载比较运算符（实际比较动态优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Task&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dynamic_priority() &lt;span style="color:#f92672">&amp;lt;&lt;/span> other.dynamic_priority(); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>整体的线程池类设计：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;thread&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;condition_variable&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadPool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadPool(size_t threads, size_t high_freq &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> high_processing_count(&lt;span style="color:#ae81ff">0&lt;/span>), high_freq_(high_freq) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(size_t i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> threads; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workers.emplace_back([&lt;span style="color:#66d9ef">this&lt;/span>] { worker_loop(); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_task&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> priority, std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(queue_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue.emplace(Task{priority, std&lt;span style="color:#f92672">::&lt;/span>chrono&lt;span style="color:#f92672">::&lt;/span>steady_clock&lt;span style="color:#f92672">::&lt;/span>now(), task});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> condition.notify_one();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>ThreadPool() { &lt;span style="color:#75715e">/* ... 省略资源回收代码 ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>mutex queue_mutex;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>condition_variable condition;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Task&lt;span style="color:#f92672">&amp;gt;&lt;/span> queue; &lt;span style="color:#75715e">// 主队列（动态优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> low_priority_queue; &lt;span style="color:#75715e">// 辅助队列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> workers;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 轮询控制
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> high_processing_count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> high_freq_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">worker_loop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(true) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(queue_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> condition.wait(lock, [&lt;span style="color:#66d9ef">this&lt;/span>] { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>queue.empty(); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 动态老化：每处理high_freq_个高优任务后强制处理低优
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">++&lt;/span>high_processing_count &lt;span style="color:#f92672">%&lt;/span> high_freq_ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">!&lt;/span>low_priority_queue.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="color:#f92672">=&lt;/span> low_priority_queue.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low_priority_queue.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="color:#f92672">=&lt;/span> queue.top().job;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(task) task();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>&lt;strong>拓展&lt;/strong>：&lt;/p></description></item><item><title>计时器 timer 的设计</title><link>https://jekyulll.github.io/posts/cpp-%E8%AE%A1%E6%97%B6%E5%99%A8-timer-%E7%9A%84%E8%AE%BE%E8%AE%A1/</link><pubDate>Tue, 25 Feb 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E8%AE%A1%E6%97%B6%E5%99%A8-timer-%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid><description>&lt;p>三种经典算法：小顶堆、红黑树、时间轮。&lt;br>
Linux内核多采用时间轮处理中断定时器，而Nginx使用红黑树管理定时事件。&lt;/p>
&lt;ul>
&lt;li>&lt;em>Redis&lt;/em>:		&lt;code>usUntilEarliestTimer()&lt;/code>&lt;/li>
&lt;li>&lt;em>Nginx&lt;/em>: 		&lt;code>ngx_event_find_timer()&lt;/code> 红黑树&lt;/li>
&lt;li>&lt;em>Skynet&lt;/em>:&lt;/li>
&lt;li>&lt;em>Netty&lt;/em>: 		时间轮&lt;/li>
&lt;li>&lt;em>Libevent&lt;/em>: 	最小堆&lt;/li>
&lt;li>&lt;em>Linux&lt;/em>: 		时间轮&lt;/li>
&lt;/ul>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;strong>算法&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>插入&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>删除&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>触发效率&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>适用场景&lt;/strong>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>小顶堆&lt;/td>
 &lt;td>&lt;code>O(log n)&lt;/code>&lt;/td>
 &lt;td>&lt;code>O(n)&lt;/code>&lt;/td>
 &lt;td>高（仅处理堆顶）&lt;/td>
 &lt;td>任务量大，无需频繁取消非堆顶任务&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>红黑树&lt;/td>
 &lt;td>&lt;code>O(log n)&lt;/code>&lt;/td>
 &lt;td>&lt;code>O(log n)&lt;/code>&lt;/td>
 &lt;td>中（遍历有序数据）&lt;/td>
 &lt;td>需动态增删改任务&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>时间轮&lt;/td>
 &lt;td>&lt;code>O(1)&lt;/code>&lt;/td>
 &lt;td>&lt;code>O(1)&lt;/code>&lt;/td>
 &lt;td>高（批量处理槽）&lt;/td>
 &lt;td>海量短周期任务，固定时间精度&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="一小顶堆">一、小顶堆&lt;/h3>
&lt;ul>
&lt;li>​优先级队列结构，堆顶元素始终是最小的（即最近的到期时间）。&lt;/li>
&lt;li>​插入和删除堆顶操作效率高，但删除任意节点效率低。&lt;/li>
&lt;/ul>
&lt;h4 id="复杂度">复杂度&lt;/h4>
&lt;ul>
&lt;li>插入：&lt;code>O(log n)&lt;/code>&lt;/li>
&lt;li>删除堆顶：&lt;code>O(log n)&lt;/code>&lt;/li>
&lt;li>删除任意节点：&lt;code>O(n)&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="适用场景">适用场景&lt;/h4>
&lt;ul>
&lt;li>定时任务数量大，且&lt;strong>频繁触发最近任务&lt;/strong>的场景。&lt;/li>
&lt;li>不适用于需要频繁取消或修改非堆顶任务的场景。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Timer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int64_t&lt;/span> expire; &lt;span style="color:#75715e">// 到期时间戳
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 小顶堆比较函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Compare&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">operator&lt;/span>()(&lt;span style="color:#66d9ef">const&lt;/span> Timer&lt;span style="color:#f92672">&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">const&lt;/span> Timer&lt;span style="color:#f92672">&amp;amp;&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a.expire &lt;span style="color:#f92672">&amp;gt;&lt;/span> b.expire;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Timer, std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Timer&lt;span style="color:#f92672">&amp;gt;&lt;/span>, Compare&lt;span style="color:#f92672">&amp;gt;&lt;/span> min_heap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 添加定时任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_timer&lt;/span>(&lt;span style="color:#66d9ef">int64_t&lt;/span> expire, std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min_heap.push({expire, task});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 驱动逻辑（在事件循环中调用）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">check_expire&lt;/span>(&lt;span style="color:#66d9ef">int64_t&lt;/span> current_time) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>min_heap.empty() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> min_heap.top().expire &lt;span style="color:#f92672">&amp;lt;=&lt;/span> current_time) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> task &lt;span style="color:#f92672">=&lt;/span> min_heap.top().task;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min_heap.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task(); &lt;span style="color:#75715e">// 执行任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="二红黑树">二、红黑树&lt;/h3>
&lt;ul>
&lt;li>使用&lt;strong>有序容器&lt;/strong>（如 &lt;code>std::multimap&lt;/code>）管理定时任务，键为到期时间。&lt;/li>
&lt;li>支持高效的&lt;strong>插入&lt;/strong>、&lt;strong>删除&lt;/strong>和&lt;strong>查找&lt;/strong>操作。&lt;/li>
&lt;/ul>
&lt;h4 id="复杂度-1">复杂度&lt;/h4>
&lt;ul>
&lt;li>插入、删除、查找：&lt;code>O(log n)&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="适用场景-1">适用场景&lt;/h4>
&lt;ul>
&lt;li>需要频繁&lt;strong>取消或修改定时任务&lt;/strong>的场景。&lt;/li>
&lt;li>适合时间跨度大或需要动态调整任务的场景。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Timer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> id; &lt;span style="color:#75715e">// 唯一标识符，用于取消任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>multimap&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int64_t&lt;/span>, Timer&lt;span style="color:#f92672">&amp;gt;&lt;/span> timer_map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 添加定时任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_timer&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> id, &lt;span style="color:#66d9ef">int64_t&lt;/span> expire, std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> task) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timer_map.insert({expire, {id, task}});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 取消定时任务（需遍历）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cancel_timer&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> timer_map.begin(); it &lt;span style="color:#f92672">!=&lt;/span> timer_map.end();) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>second.id &lt;span style="color:#f92672">==&lt;/span> id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it &lt;span style="color:#f92672">=&lt;/span> timer_map.erase(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>it;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 驱动逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">check_expire&lt;/span>(&lt;span style="color:#66d9ef">int64_t&lt;/span> current_time) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> timer_map.begin();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (it &lt;span style="color:#f92672">!=&lt;/span> timer_map.end() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first &lt;span style="color:#f92672">&amp;lt;=&lt;/span> current_time) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>second.task(); &lt;span style="color:#75715e">// 执行任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> timer_map.erase(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="三时间轮">三、时间轮&lt;/h3>
&lt;blockquote>
&lt;p>其实可以理解为一种变相的哈希表。&lt;/p></description></item><item><title>如何让函数安全返回 std::string 的 c_str</title><link>https://jekyulll.github.io/posts/cpp-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAc_str%E7%9A%84%E5%B0%8F%E5%9D%91/</link><pubDate>Sun, 23 Feb 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAc_str%E7%9A%84%E5%B0%8F%E5%9D%91/</guid><description>&lt;p>观察以下这段明显错误的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">get_c&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> s.c_str();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;danger : %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, get_c());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>字符串&lt;code>s&lt;/code>是一个函数内部的临时对象，返回的&lt;code>const char*&lt;/code>实际上是一个指针。函数结束后&lt;code>s&lt;/code>会析构，而指针理论上会变成悬空的。&lt;br>
实际上正确打印出了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>danger : hello world
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(实际上只是因为该段内存没有被立刻覆盖，理论上是不安全的)&lt;/p>
&lt;p>查看一下汇编：&lt;/p>
&lt;ol>
&lt;li>构造 &lt;code>s&lt;/code>：&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code class="language-ass" data-lang="ass">leaq .LC0(%rip), %rcx ; 加载 &amp;#34;hello world&amp;#34; 地址到 %rcx
leaq -64(%rbp), %rax ; 栈上分配 s 的内存
call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_ ; 调用构造函数
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>字符串 &lt;code>&amp;quot;hello world&amp;quot;&lt;/code> 存储在 &lt;code>.rodata&lt;/code> 只读数据段（.LC0）。&lt;/li>
&lt;li>s 在栈上构造，通过 SSO 直接存储字符串内容。&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>获取 &lt;code>c_str()&lt;/code>：&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code class="language-ass" data-lang="ass">leaq -64(%rbp), %rax
call _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv@PLT
movq %rax, %rbx ; 将 c_str() 指针保存到 %rbx
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>析构 &lt;code>s&lt;/code>：&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code class="language-ass" data-lang="ass">leaq -64(%rbp), %rax
movq %rax, %rdi
call _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@PLT ; 调用析构函数
&lt;/code>&lt;/pre>&lt;p>对于较短的字符串（如 &amp;ldquo;&lt;code>hello world&lt;/code>&amp;quot;），&lt;code>std::string&lt;/code> 可能使用 短字符串优化（SSO），将数据直接存储在对象内部的栈空间中，而非堆内存。&lt;br>
在&lt;code>get_c&lt;/code>中，&lt;code>s&lt;/code>是在栈上分配的，当函数返回时，栈空间可能未被其他数据覆盖，所以字符串内容仍然保留。此时调用printf，可能仍然能读取到原来的数据，但这只是巧合，属于未定义行为的表现。&lt;/p></description></item><item><title>Linux 内核中 C 语言的面向对象</title><link>https://jekyulll.github.io/posts/cpp-linux-%E5%86%85%E6%A0%B8%E4%B8%AD-c-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Fri, 21 Feb 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-linux-%E5%86%85%E6%A0%B8%E4%B8%AD-c-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>&lt;p>Linux 内核使用 &lt;strong>结构体&lt;/strong> 和 &lt;strong>函数指针&lt;/strong> 的组合模拟面向对象（OO）编程范式。&lt;/p>
&lt;hr>
&lt;h3 id="1-结构体封装数据与行为">1. &lt;strong>结构体封装数据与行为&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>数据抽象&lt;/strong>：将相关属性和状态封装在一个 &lt;code>struct&lt;/code> 中。&lt;/li>
&lt;li>&lt;strong>行为绑定&lt;/strong>：通过函数指针将操作绑定到结构体上，实现动态调用。&lt;/li>
&lt;/ul>
&lt;h4 id="示例struct-file_operations">示例：&lt;code>struct file_operations&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 定义文件操作的函数指针表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> file_operations {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ssize_t&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>read)(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">char&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">size_t&lt;/span>, &lt;span style="color:#66d9ef">loff_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ssize_t&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>write)(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> __user &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">size_t&lt;/span>, &lt;span style="color:#66d9ef">loff_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 其他方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 具体文件系统的实现（如 ext4）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations ext4_fops &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .read &lt;span style="color:#f92672">=&lt;/span> ext4_read,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .write &lt;span style="color:#f92672">=&lt;/span> ext4_write,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 初始化其他方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 注册到 VFS 层时关联 fops
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode &lt;span style="color:#f92672">=&lt;/span> ...;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>inode&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i_fop &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>ext4_fops; &lt;span style="color:#75715e">// 绑定特定方法集
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="2-多态与继承">2. &lt;strong>多态与继承&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>父子结构体&lt;/strong>：子结构体嵌入父结构体以继承接口。&lt;/li>
&lt;li>&lt;strong>类型安全转换&lt;/strong>：通过 &lt;code>container_of&lt;/code> 宏从父指针获取子结构体。&lt;/li>
&lt;/ul>
&lt;h4 id="示例struct-kobject-与自定义对象">示例：&lt;code>struct kobject&lt;/code> 与自定义对象&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 父结构体（类似抽象基类）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> kobject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> kset &lt;span style="color:#f92672">*&lt;/span>kset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 公共方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>release)(&lt;span style="color:#66d9ef">struct&lt;/span> kobject &lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 子结构体（具体实现）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> my_device {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> kobject kobj; &lt;span style="color:#75715e">// 继承 kobject
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 实现父类的方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">my_device_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> kobject &lt;span style="color:#f92672">*&lt;/span>kobj) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> my_device &lt;span style="color:#f92672">*&lt;/span>dev &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">container_of&lt;/span>(kobj, &lt;span style="color:#66d9ef">struct&lt;/span> my_device, kobj);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 清理资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 初始化时绑定方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> my_device &lt;span style="color:#f92672">*&lt;/span>dev &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">kzalloc&lt;/span>(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>dev), GFP_KERNEL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>kobj.release &lt;span style="color:#f92672">=&lt;/span> my_device_release;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kobject_init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>dev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>kobj, &lt;span style="color:#f92672">&amp;amp;&lt;/span>my_device_ktype); &lt;span style="color:#75715e">// 注册类型
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="3-组合与接口分离">3. &lt;strong>组合与接口分离&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>模块化设计&lt;/strong>：通过组合而非继承复用代码。&lt;/li>
&lt;li>&lt;strong>统一接口&lt;/strong>：顶层结构体定义标准接口，底层实现差异化逻辑。&lt;/li>
&lt;/ul>
&lt;h4 id="示例struct-block_device">示例：&lt;code>struct block_device&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 通用块设备接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> block_device {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> gendisk &lt;span style="color:#f92672">*&lt;/span>disk;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通用方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>ioctl)(&lt;span style="color:#66d9ef">struct&lt;/span> block_device &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 桌面硬盘驱动实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> my_disk {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> block_device bdev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 私有数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 实现接口方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">my_disk_ioctl&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> block_device &lt;span style="color:#f92672">*&lt;/span>bdev, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> cmd, ...) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> my_disk &lt;span style="color:#f92672">*&lt;/span>disk &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">container_of&lt;/span>(bdev, &lt;span style="color:#66d9ef">struct&lt;/span> my_disk, bdev);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">custom_ioctl&lt;/span>(disk, cmd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="4-运行时多态">4. &lt;strong>运行时多态&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>函数指针作为虚函数表（vtable），根据对象类型动态调用不同实现。&lt;/li>
&lt;/ul>
&lt;h4 id="示例struct-net_device_ops">示例：&lt;code>struct net_device_ops&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 网络设备操作接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> net_device_ops {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>ndo_open)(&lt;span style="color:#66d9ef">struct&lt;/span> net_device &lt;span style="color:#f92672">*&lt;/span>dev);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>ndo_stop)(&lt;span style="color:#66d9ef">struct&lt;/span> net_device &lt;span style="color:#f92672">*&lt;/span>dev);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 以太网驱动实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> net_device_ops eth_ops &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ndo_open &lt;span style="color:#f92672">=&lt;/span> eth_open,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ndo_stop &lt;span style="color:#f92672">=&lt;/span> eth_stop,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 注册网络设备时绑定 ops
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> net_device &lt;span style="color:#f92672">*&lt;/span>netdev &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">alloc_etherdev&lt;/span>(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> priv_data));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>netdev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>netdev_ops &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>eth_ops;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="5-关键技巧">5. &lt;strong>关键技巧&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>自引用结构体&lt;/strong>：通过指针成员隐式关联自身。&lt;/li>
&lt;li>&lt;strong>宏简化代码&lt;/strong>：如 &lt;code>container_of&lt;/code> 用于反向查找结构体。&lt;/li>
&lt;li>&lt;strong>模块化加载&lt;/strong>：通过 &lt;code>struct module&lt;/code> 动态注册/卸载驱动。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>Linux 内核通过 &lt;strong>结构体+函数指针&lt;/strong> 实现了以下 OO 特性：&lt;/p></description></item><item><title>web 访问认证机制</title><link>https://jekyulll.github.io/posts/web-web-%E8%AE%BF%E9%97%AE%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 17 Feb 2025 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/web-web-%E8%AE%BF%E9%97%AE%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</guid><description>&lt;p>&lt;a href="https://time.geekbang.org/column/article/398410">25 | 认证机制：应用程序如何进行访问认证？&lt;/a>讲得非常好，图文结合。&lt;/p>
&lt;p>&lt;strong>IAM&lt;/strong>：身份识别与访问管理（Identity and Access Management）。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>认证&lt;/strong>（Authentication，英文缩写 &lt;strong>authn&lt;/strong>）：用来验证某个用户是否具有访问系统的权限。如果认证通过，该用户就可以访问系统，从而创建、修改、删除、查询平台支持的资源。&lt;/li>
&lt;li>&lt;strong>授权&lt;/strong>（Authorization，英文缩写 &lt;strong>authz&lt;/strong>）：用来验证某个用户是否具有访问某个资源的权限，如果授权通过，该用户就能对资源做增删改查等操作。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>认证证明了你是谁，授权决定了你能做什么。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;u>四种基本的认证方式：&lt;em>Basic&lt;/em>、&lt;em>Digest&lt;/em>、&lt;em>OAuth&lt;/em>、&lt;em>Bearer&lt;/em>&lt;/u>。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Basic&lt;/strong> 基础认证&lt;br>
Basic 认证（基础认证），是最简单的认证方式。它简单地将用户名:密码进行 &lt;code>base64&lt;/code> 编码后，放到 HTTP Authorization Header 中。HTTP 请求到达后端服务后，后端服务会解析出 Authorization Header 中的 &lt;code>base64&lt;/code> 字符串，解码获取用户名和密码，并将用户名和密码跟数据库中记录的值进行比较，如果匹配则认证通过。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Digest&lt;/strong> 摘要认证&lt;br>
Digest 认证（摘要认证）与基本认证兼容，但修复了基本认证的严重缺陷。&lt;br>
Digest 具有如下特点：&lt;/p>
&lt;ul>
&lt;li>绝不会用明文方式在网络上发送密码。&lt;/li>
&lt;li>可以有效防止恶意用户进行重放攻击。&lt;/li>
&lt;li>可以有选择地防止对报文内容的篡改。
四步：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>客户端请求服务端的资源。&lt;/li>
&lt;li>在客户端能够证明它知道密码从而确认其身份之前，服务端认证失败，返回&lt;code>401 Unauthorized&lt;/code>，并返回&lt;code>WWW-Authenticate&lt;/code>头，里面包含认证需要的信息。&lt;/li>
&lt;li>客户端根据&lt;code>WWW-Authenticate&lt;/code>头中的信息，选择加密算法，并使用密码随机数 &lt;code>nonce&lt;/code>(防止&lt;em>重放攻击&lt;/em>)，计算出密码摘要 &lt;code>response&lt;/code>，并再次请求服务端。&lt;/li>
&lt;li>服务器将客户端提供的密码摘要与服务器内部计算出的摘要进行对比。如果匹配，就说明客户端知道密码，认证通过，并返回一些与授权会话相关的附加信息，放在 &lt;code>Authorization-Info&lt;/code> 中。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>OAuth&lt;/strong> 开放授权&lt;br>
OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一 Web 服务上存储的私密资源（例如照片、视频、音频等），而无需将用户名和密码提供给第三方应用。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>OAuth2.0 一共分为四种授权方式，分别为&lt;em>密码式&lt;/em>、&lt;em>隐藏式&lt;/em>、&lt;em>凭借式&lt;/em>和&lt;em>授权码&lt;/em>模式。&lt;/p>
&lt;/blockquote>
&lt;ol start="4">
&lt;li>&lt;strong>Bearer&lt;/strong> 令牌认证&lt;br>
Bearer 认证是一种 HTTP 身份验证方法。Bearer 认证的核心是 &lt;code>bearer token&lt;/code>。&lt;code>bearer token&lt;/code> 是一个加密字符串，通常由服务端根据密钥生成。客户端在请求服务端时，必须在请求头中包含&lt;code>Authorization: Bearer&lt;/code> 。服务端收到请求后，解析出&lt;code>&amp;lt;token&amp;gt;&lt;/code>，并校验&lt;code>&amp;lt;token&amp;gt;&lt;/code>的合法性，如果校验通过，则认证通过。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>跟基本认证一样，Bearer 认证需要配合 HTTPS 一起使用，来保证认证安全性。&lt;/p></description></item><item><title>扫描线算法计算区间重叠</title><link>https://jekyulll.github.io/posts/alg-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/</link><pubDate>Sat, 15 Feb 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/alg-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0/</guid><description>&lt;p>题目来源：&lt;a href="https://www.marscode.cn/practice/jn1075jrp7j47d?problem_id=7424418560930611244">Marscode&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>小C和小U有一个从&lt;code>0&lt;/code>开始的数组&lt;code>nums&lt;/code>，以及一个非负整数&lt;code>k&lt;/code>。每次操作中，小C可以选择一个尚未选择的下标&lt;code>i&lt;/code>（范围在 &lt;code>[0, nums.length - 1]&lt;/code>），然后将&lt;code>nums[i]&lt;/code>替换为&lt;code>[nums[i] - k, nums[i] + k]&lt;/code>之间的任意整数（包含边界）。&lt;br>
在应用任意次数的操作后，返回数组&lt;code>nums&lt;/code>可能达到的最大分数。数组的分数被定义为数组中最多重复的元素个数。注意，每个下标只能被操作一次。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h3 id="暴力解超时-onk">暴力解（超时） &lt;code>O(n²k)&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">solution&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maxCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 至少有一个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 遍历每个数作为可能的目标值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以nums[i]为中心，考虑范围[nums[i]-k, nums[i]+k]内的所有可能值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> nums[i]&lt;span style="color:#f92672">-&lt;/span>k; target &lt;span style="color:#f92672">&amp;lt;=&lt;/span> nums[i]&lt;span style="color:#f92672">+&lt;/span>k; target&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 检查每个位置的数是否能变成target
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (abs(nums[j] &lt;span style="color:#f92672">-&lt;/span> target) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxCount &lt;span style="color:#f92672">=&lt;/span> max(maxCount, count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> maxCount;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="优化暴力解-on">优化暴力解 &lt;code>O(n²)&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">solution&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maxCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 只需要考虑将某些数变成数组中已有的数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> nums[i]; &lt;span style="color:#75715e">// 以当前数作为目标值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (abs(nums[j] &lt;span style="color:#f92672">-&lt;/span> target) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxCount &lt;span style="color:#f92672">=&lt;/span> max(maxCount, count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> maxCount;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="扫描线算法-onlogn">扫描线算法 &lt;code>O(nlogn)&lt;/code>&lt;/h3>
&lt;p>像是在数某个时刻有多少个区间重叠。一条水平线从左向右扫过，每个起点让重叠数+1，每个终点让重叠数-1，过程中的最大重叠数就是答案。&lt;/p></description></item><item><title>C++ 同一进程的线程之间共享哪些资源？</title><link>https://jekyulll.github.io/posts/cpp-c++-%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</link><pubDate>Sat, 08 Feb 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90/</guid><description>&lt;p>同一进程内的线程共享的资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>代码段&lt;/strong>：存放程序的可执行指令，所有线程共享相同的代码段，因此任何线程都可以执行程序中的函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据段&lt;/strong>：包含全局变量和静态变量，这些变量在程序运行期间只有一个实例，所有线程都可以访问和修改它们。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>堆&lt;/strong>：用于动态内存分配，线程可以在堆上分配和释放内存，因此堆上的数据对所有线程可见。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>打开的文件&lt;/strong>：如果程序在运行过程中打开了文件，文件描述符等信息在进程地址空间中保存，所有线程都可以访问这些打开的文件。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>每个线程的私有资源：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>栈&lt;/strong>：每个线程都有自己的栈空间，用于存储函数的局部变量、返回地址等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>寄存器&lt;/strong>：线程在执行过程中使用的寄存器集是独立的，包括程序计数器（PC）等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>线程局部存储（Thread Local Storage）&lt;/strong>：存放线程私有的全局变量，即使变量名相同，不同线程访问的也是各自独立的副本。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;em>注意&lt;/em>：虽然栈是线程私有的，但由于线程间没有严格的内存隔离机制，一个线程可以通过指针访问和修改另一个线程的栈数据。&lt;/p></description></item><item><title>运行时是把整个动态库都加载到内存中吗？</title><link>https://jekyulll.github.io/posts/cpp-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%98%AF%E6%8A%8A%E6%95%B4%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93%E9%83%BD%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%90%97/</link><pubDate>Sat, 08 Feb 2025 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%98%AF%E6%8A%8A%E6%95%B4%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93%E9%83%BD%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%90%97/</guid><description>&lt;p>在 C++ 中，动态库（如 &lt;code>.dll&lt;/code> 或 &lt;code>.so&lt;/code> 文件）在加载时，操作系统会将整个库文件映射到进程的地址空间中。
&lt;u>具体的函数和数据只有在被实际使用时才会被加载到内存中。&lt;/u>
(动态库作为一个整体被映射，但其中的各个部分仅在需要时才占用物理内存。)&lt;/p>
&lt;p>另外：&lt;br>
C++ 提供了&lt;strong>显式运行时链接&lt;/strong>的机制，程序可以在运行时根据需要动态加载库的特定部分。(&lt;code>dlopen&lt;/code>、&lt;code>dlsym&lt;/code> 等函数)程序可以在运行时按需加载特定的符号（函数或变量）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;dlfcn.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">dlopen&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>filename, &lt;span style="color:#66d9ef">int&lt;/span> flag);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>flag&lt;/code>：指定加载选项：
- &lt;code>RTLD_LAZY&lt;/code>：延迟解析符号，即在实际使用时才解析。&lt;br>
- &lt;code>RTLD_NOW&lt;/code>：立即解析所有未定义的符号。如果无法解析，&lt;code>dlopen&lt;/code> 将返回 &lt;code>NULL&lt;/code>。&lt;br>
- &lt;code>RTLD_GLOBAL&lt;/code>：使加载的库中的符号在后续加载的其他库中可见。&lt;br>
- &lt;code>RTLD_LOCAL&lt;/code>：与 &lt;code>RTLD_GLOBAL&lt;/code> 相反，加载的库中的符号对后续加载的库不可见（这是默认行为）。&lt;/p></description></item><item><title>检查字符串是否是另一个的子串</title><link>https://jekyulll.github.io/posts/cpp-%E6%A3%80%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9A%84%E5%AD%90%E4%B8%B2/</link><pubDate>Wed, 29 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E6%A3%80%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9A%84%E5%AD%90%E4%B8%B2/</guid><description>&lt;h2 id="常见-cc-api">常见 C/C++ API&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;code>std::string&lt;/code>的 &lt;code>string::find&lt;/code> 成员函数&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isSubstring&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> mainStr, &lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> subStr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mainStr.find(subStr) &lt;span style="color:#f92672">!=&lt;/span> string&lt;span style="color:#f92672">::&lt;/span>npos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>大多数标准库的 &lt;code>strstr&lt;/code>（如Glibc）和 &lt;code>string::find&lt;/code>（如MSVC、libc++）已针对子串搜索优化。&lt;br>
实现中可能直接调用 &lt;code>memmem&lt;/code> 或 &lt;code>strstr&lt;/code>，性能与 &lt;code>strstr&lt;/code> 相当。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>C标准库的 &lt;code>strstr&lt;/code> 函数&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isSubstring&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> mainStr, &lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> subStr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> strstr(mainStr.c_str(), subStr.c_str()) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要将 &lt;code>std::string&lt;/code> 转换为C风格字符串，可能引入额外开销。&lt;/p>
&lt;blockquote>
&lt;p>Glibc的 &lt;code>strstr&lt;/code> 使用Two-Way算法，适合长文本和模式。时间复杂度接近&lt;code>O(n)&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>STL &lt;code>std::search&lt;/code>&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isSubstring&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> mainStr, &lt;span style="color:#66d9ef">const&lt;/span> string&lt;span style="color:#f92672">&amp;amp;&lt;/span> subStr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>search(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mainStr.begin(), mainStr.end(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> subStr.begin(), subStr.end()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) &lt;span style="color:#f92672">!=&lt;/span> mainStr.end();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="算法">算法&lt;/h2>
&lt;h3 id="1-暴力法brute-force">&lt;strong>1. 暴力法（Brute Force）&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isSubstringBruteForce&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> mainStr, &lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> subStr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (subStr.empty()) &lt;span style="color:#66d9ef">return&lt;/span> true; &lt;span style="color:#75715e">// 空子串是任何字符串的子串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> mainStr.length(), n &lt;span style="color:#f92672">=&lt;/span> subStr.length();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (m &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m &lt;span style="color:#f92672">-&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> j;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (mainStr[i &lt;span style="color:#f92672">+&lt;/span> j] &lt;span style="color:#f92672">!=&lt;/span> subStr[j]) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (j &lt;span style="color:#f92672">==&lt;/span> n) &lt;span style="color:#66d9ef">return&lt;/span> true; &lt;span style="color:#75715e">// 完全匹配
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>时间复杂度&lt;/strong>：最坏情况为 (O(m \times n))（如主串为&lt;code>AAAAAAB&lt;/code>，子串为&lt;code>AAAB&lt;/code>）。&lt;/li>
&lt;li>&lt;strong>空间复杂度&lt;/strong>：(O(1))。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-kmp算法knuth-morris-pratt">&lt;strong>2. KMP算法（Knuth-Morris-Pratt）&lt;/strong>&lt;/h3>
&lt;p>通过预处理子串生成部分匹配表（Longest Prefix Suffix, LPS），利用已匹配的信息跳过不必要的比较。&lt;/p></description></item><item><title>写个相对现代的 C++ 二叉搜索树</title><link>https://jekyulll.github.io/posts/cpp-%E5%86%99%E4%B8%AA%E7%9B%B8%E5%AF%B9%E7%8E%B0%E4%BB%A3%E7%9A%84-c++-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Tue, 21 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E5%86%99%E4%B8%AA%E7%9B%B8%E5%AF%B9%E7%8E%B0%E4%BB%A3%E7%9A%84-c++-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;optional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">concept&lt;/span> Comparable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">requires&lt;/span>(T a, T b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { a &lt;span style="color:#f92672">&amp;lt;&lt;/span> b } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>convertible_to&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { a &lt;span style="color:#f92672">&amp;gt;&lt;/span> b } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>convertible_to&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { a &lt;span style="color:#f92672">==&lt;/span> b } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>convertible_to&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">concept&lt;/span> Streamable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">requires&lt;/span>(T a, std&lt;span style="color:#f92672">::&lt;/span>ostream&lt;span style="color:#f92672">&amp;amp;&lt;/span> os) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { os &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> a } &lt;span style="color:#f92672">-&amp;gt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>same_as&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>ostream&lt;span style="color:#f92672">&amp;amp;&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>Comparable K, Streamable V&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PairBSTree&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> Pair &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair _pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> _left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> _right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> _pair(pair), _left(&lt;span style="color:#66d9ef">nullptr&lt;/span>), _right(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode(Pair&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> pair)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> _pair(std&lt;span style="color:#f92672">::&lt;/span>move(pair)), _left(&lt;span style="color:#66d9ef">nullptr&lt;/span>), _right(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>TreeNode() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> _root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">build_&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair : nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Insert(pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">build_&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&amp;amp;&lt;/span> nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair : nodes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Insert(std&lt;span style="color:#f92672">::&lt;/span>move(pair));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">destroy_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destroy_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destroy_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> search_(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node, K key) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node &lt;span style="color:#f92672">||&lt;/span> key &lt;span style="color:#f92672">==&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (key &lt;span style="color:#f92672">&amp;lt;&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">search_&lt;/span>(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">search_&lt;/span>(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">insert_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node, &lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TreeNode(pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> key &lt;span style="color:#f92672">=&lt;/span> pair.first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (key &lt;span style="color:#f92672">==&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair &lt;span style="color:#f92672">=&lt;/span> pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (key &lt;span style="color:#f92672">&amp;lt;&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> insert_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left, pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> insert_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right, pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> go_to_max_(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> go_to_min_(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">delete_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&amp;amp;&lt;/span> node, K key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> search_(node, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TreeNode&lt;span style="color:#f92672">*&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> max_in_left &lt;span style="color:#f92672">=&lt;/span> go_to_max_(target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair &lt;span style="color:#f92672">=&lt;/span> max_in_left&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 常规的递归，把整个左子树当做新的树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// delete_(target-&amp;gt;_left, max_in_left-&amp;gt;_pair.first);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 2. 直接传入 max_in_left 即可
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// delete_(max_in_left, max_in_left-&amp;gt;_pair.first);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 3. 实际上不需要递归，因为 max_in_left 是左边最大的值，一定没有右子树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> TreeNode&lt;span style="color:#f92672">*&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> max_in_left&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> max_in_left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_in_left &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 我开始时候的代码（有误）：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// auto&amp;amp; max_in_left = go_to_max_(node-&amp;gt;_left); // 应该是
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// current-&amp;gt;_left current-&amp;gt;_pair = max_in_left-&amp;gt;_pair; delete
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// (max_in_left); max_in_left = nullptr;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 第三种和我开始时候的逻辑类似
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 但我当时忘了保留 max_in_left 的左子树（如果存在）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">normal_print_func_&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pair.second &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; | &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">in_order_&lt;/span>(TreeNode&lt;span style="color:#f92672">*&lt;/span> node, std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span>)&lt;span style="color:#f92672">&amp;gt;&lt;/span> func) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in_order_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_left, func);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in_order_(node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_right, func);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree() &lt;span style="color:#f92672">:&lt;/span> _root(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> pairs) &lt;span style="color:#f92672">:&lt;/span> _root(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build_(pairs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree(std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;amp;&amp;amp;&lt;/span> pairs) &lt;span style="color:#f92672">:&lt;/span> _root(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build_(std&lt;span style="color:#f92672">::&lt;/span>move(pairs));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>PairBSTree() { destroy_(_root); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>V&lt;span style="color:#f92672">&amp;gt;&lt;/span> Search(K key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> node &lt;span style="color:#f92672">=&lt;/span> search_(_root, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>nullopt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Insert&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Pair&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair) { insert_(_root, pair); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Delete&lt;/span>(K key) { delete_(_root, key); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">InOrder&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>(Pair)&lt;span style="color:#f92672">&amp;gt;&lt;/span> func &lt;span style="color:#f92672">=&lt;/span> normal_print_func_) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in_order_(_root, func);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">[[nodiscard]]&lt;/span> size_t Size() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InOrder([&lt;span style="color:#f92672">&amp;amp;&lt;/span>size](std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span>) { &lt;span style="color:#f92672">++&lt;/span>size; });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">[[nodiscard]]&lt;/span> V Max() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> _root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> go_to_max_(temp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">[[nodiscard]]&lt;/span> V Min() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> _root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> go_to_min_(temp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>_pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> pairs &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Bob&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Jack&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Lucy&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">23&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Evan&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Gorge&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Lily&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Mono&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">90&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Rick&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">14&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Lance&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">76&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Molly&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">24&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Stan&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">11&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Scot&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#ae81ff">54&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Mint&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">37&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Biance&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">35&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Cower&amp;#34;&lt;/span>}, {&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Brick&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PairBSTree tree(pairs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Name of 9: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tree.Search(&lt;span style="color:#ae81ff">9&lt;/span>).value_or(&lt;span style="color:#e6db74">&amp;#34;nothing&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tree.Size() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// std::cout &amp;lt;&amp;lt; &amp;#34;Min: &amp;#34; &amp;lt;&amp;lt; tree.Min() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// std::cout &amp;lt;&amp;lt; &amp;#34;Max: &amp;#34; &amp;lt;&amp;lt; tree.Max() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.InOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.Delete(&lt;span style="color:#ae81ff">15&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Size: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> tree.Size() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.InOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> names_in_order;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree.InOrder([&lt;span style="color:#f92672">&amp;amp;&lt;/span>names_in_order](std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> pair) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pair.second &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; -- &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> names_in_order.push_back(pair.second);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>C++ std::function 之脱裤子放屁的优化</title><link>https://jekyulll.github.io/posts/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/</link><pubDate>Wed, 15 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-stdfunction-%E4%B9%8B%E8%84%B1%E8%A3%A4%E5%AD%90%E6%94%BE%E5%B1%81%E7%9A%84%E4%BC%98%E5%8C%96/</guid><description>&lt;p>看到一句话：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>std::function&lt;/code> 很强大，但是代价也很高，在创建函数对象的时候总是会有 &lt;code>new&lt;/code> 操作的。虽然通常情况下影响不是很高，但是总觉得这是没必要的。&lt;/p>
&lt;/blockquote>
&lt;p>于是草草找一下资料，看看有没有隐藏的性能优化。&lt;/p>
&lt;hr>
&lt;h3 id="stdfunction-的实现">&lt;code>std::function&lt;/code> 的实现&lt;/h3>
&lt;p>&lt;a href="https://zh.cppreference.com/w/cpp/utility/functional/function">&lt;code>std::function&lt;/code>&lt;/a> 是一个可变参类模板，是一个通用的函数包装器（Polymorphic function wrapper）。&lt;br>
通过类型擦除（type erasure）机制，将具体类型的可调用对象封装到一个统一的接口中。&lt;/p>
&lt;blockquote>
&lt;p>其实例可以存储、复制和调用任何可复制构造的可调用目标，包括普通函数、成员函数、类对象（重载了operator()的类的对象）、Lambda表达式等。是对C++现有的可调用实体的一种类型安全的包裹（相比而言，函数指针这种可调用实体，是类型不安全的）。 &amp;ndash; &lt;a href="https://zhuanlan.zhihu.com/p/560964284">STL源码分析之std::function&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> _Res, &lt;span style="color:#66d9ef">typename&lt;/span>... _ArgTypes&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">function&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>_Res(_ArgTypes...)&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> _Maybe_unary_or_binary_function&lt;span style="color:#f92672">&amp;lt;&lt;/span>_Res, _ArgTypes...&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> , &lt;span style="color:#66d9ef">private&lt;/span> _Function_base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> _Invoker_type &lt;span style="color:#f92672">=&lt;/span> _Res (&lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#66d9ef">const&lt;/span> _Any_data&lt;span style="color:#f92672">&amp;amp;&lt;/span>, _ArgTypes&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _Invoker_type _M_invoker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>std::function&lt;/code> 的内部有两个部分：&lt;/p>
&lt;ul>
&lt;li>一个指向实际存储区域的指针：存储实际的可调用对象（函数对象、lambda、函数指针等）。&lt;/li>
&lt;li>一个&lt;em>接口表&lt;/em>（vtable 等效机制）：存储操作函数（如调用函数、复制、销毁等）的地址。&lt;/li>
&lt;/ul>
&lt;p>其类型擦除通过接口表的方式实现，类似于虚函数机制，但它通常采用静态接口表和手动的动态分配来支持多种类型的可调用对象。&lt;/p>
&lt;hr>
&lt;h3 id="性能分析">性能分析&lt;/h3>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/370563773">关于std function和lambda function的性能调试 &amp;ndash;法号桑菜&lt;/a>。&lt;br>
&lt;a href="https://blog.demofox.org/2015/02/25/avoiding-the-performance-hazzards-of-stdfunction/">Avoiding The Performance Hazzards of std::function&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>There are two performance implications of using &lt;code>std::function&lt;/code> that might surprise you:&lt;/p>
&lt;ol>
&lt;li>When calling a &lt;code>std::function&lt;/code>, it does a virtual function call.&lt;/li>
&lt;li>When assigning a lambda with significant captures to a &lt;code>std::function&lt;/code>, it will do a dynamic memory allocation!&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>一是&lt;code>std::function&lt;/code> 会使用虚函数调用，有开销。&lt;/li>
&lt;li>二是将 lambda 赋给&lt;code>std::function&lt;/code>的时候，如果捕获内容较多，会需要额外的动态内存分配。&lt;/li>
&lt;/ul>
&lt;p>第二点其实说的就是：&lt;br>
&lt;code>std::function&lt;/code> 对小型的可调用对象会使用“&lt;strong>小对象优化&lt;/strong>（Small Object Optimization, SOO）”，避免动态分配堆内存。但如果对象超过了实现中的小对象优化阈值，则会触发堆分配（&lt;code>new&lt;/code> 操作）。&lt;/p></description></item><item><title>在 C++ 里实现 Golang 的 defer</title><link>https://jekyulll.github.io/posts/cpp-%E7%94%A8-c++-%E5%AE%9E%E7%8E%B0-golang-%E7%9A%84-defer/</link><pubDate>Wed, 15 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E7%94%A8-c++-%E5%AE%9E%E7%8E%B0-golang-%E7%9A%84-defer/</guid><description>&lt;p>利用 RAII 和 C++ 的析构函数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Defer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">explicit&lt;/span> Defer(std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> func) &lt;span style="color:#f92672">:&lt;/span> func_(std&lt;span style="color:#f92672">::&lt;/span>move(func)), active_(true) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 禁止复制
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Defer(&lt;span style="color:#66d9ef">const&lt;/span> Defer&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Defer&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Defer&lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 允许移动
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Defer(Defer&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> other) &lt;span style="color:#66d9ef">noexcept&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> func_(std&lt;span style="color:#f92672">::&lt;/span>move(other.func_)), active_(other.active_) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> other.active_ &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 析构函数中调用defer的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Defer() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (active_ &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> func_) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func_();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cancel&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> active_ &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> func_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> active_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define CONCAT_IMPL(x, y) x##y
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define CONCAT(x, y) CONCAT_IMPL(x, y)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define defer(func) Defer CONCAT(_defer_, __LINE__)(func)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Start of main function&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defer([]() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Deferred action 1&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defer([]() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Deferred action in scope&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Inside scope&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defer([]() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Deferred action 2&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;End of main function&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些宏的目的是为 &lt;code>defer&lt;/code> 提供一种易用的语法，同时确保每次使用 &lt;code>defer&lt;/code> 都会创建一个唯一的变量名，从而避免变量名冲突。&lt;/p></description></item><item><title>[转载] C++的POD以及如何判断是否POD</title><link>https://jekyulll.github.io/posts/cpp-%E8%BD%AC%E8%BD%BD-c++%E7%9A%84pod%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6pod/</link><pubDate>Thu, 09 Jan 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E8%BD%AC%E8%BD%BD-c++%E7%9A%84pod%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6pod/</guid><description>&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/17003601237">C++的POD以及如何判断是否POD - cheeto的文章 - 知乎&lt;/a>。&lt;/p>
&lt;hr>
&lt;p>在C++11及以后的版本中，POD类型（Plain Old Data）的定义被细化为两个核心概念：&lt;br>
&lt;strong>平凡类型&lt;/strong>（Trivial Type）和&lt;strong>标准布局类型&lt;/strong>（Standard Layout Type）。当类型为Trivial &amp;amp;&amp;amp; Standard Layout时才能被认为是POD。&lt;/p>
&lt;h3 id="平凡类型trivial-type">平凡类型（Trivial Type）&lt;/h3>
&lt;p>满足以下条件：&lt;/p>
&lt;ul>
&lt;li>默认构造函数：没有用户定义的构造函数，即使用默认构造函数。&lt;/li>
&lt;li>默认拷贝构造函数：没有用户定义的拷贝构造函数。&lt;/li>
&lt;li>默认析构函数：没有用户定义的析构函数。&lt;/li>
&lt;li>默认赋值操作符：没有用户定义的拷贝赋值和移动赋值操作符。&lt;/li>
&lt;/ul>
&lt;p>对于平凡类型，编译器会为其提供默认的构造、拷贝和析构行为，无需用户显式定义。&lt;/p>
&lt;p>比如说以下&lt;code>Trivial&lt;/code>，即使它有构造函数和析构函数 只要不是用户自定义而是&lt;code>default&lt;/code>也可以&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Trivial&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Trivial() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>; &lt;span style="color:#75715e">// 默认构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Trivial() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>; &lt;span style="color:#75715e">// 默认析构函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="标准布局类型standard-layout-type">标准布局类型（Standard Layout Type）&lt;/h3>
&lt;p>满足以下条件：&lt;/p>
&lt;ul>
&lt;li>无虚函数：它没有虚函数。&lt;/li>
&lt;li>无虚基类：它没有虚基类。&lt;/li>
&lt;li>成员变量顺序：它的成员变量是按声明顺序排列的。&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>直接用&lt;code>std::is_standard_layout_v&lt;/code>判断即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define Print(x) std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">safe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">unsafe_cons&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unsafe_cons(unsafe_cons &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">unsafe_vir&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">unsafe_tem&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Trivial&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Trivial() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>; &lt;span style="color:#75715e">// 默认构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Trivial() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>; &lt;span style="color:#75715e">// 默认析构函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">StandardLayout&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> a; &lt;span style="color:#75715e">// 1 byte
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> b; &lt;span style="color:#75715e">// 4 bytes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 用于检查是否为 POD 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">is_pod&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> value &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>is_trivial&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>is_standard_layout&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>is_trivially_default_constructible&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">test1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Print(is_pod&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(is_pod&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(is_pod&lt;span style="color:#f92672">&amp;lt;&lt;/span>Trivial&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(is_pod&lt;span style="color:#f92672">&amp;lt;&lt;/span>StandardLayout&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(std&lt;span style="color:#f92672">::&lt;/span>is_trivial&lt;span style="color:#f92672">&amp;lt;&lt;/span>Trivial&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(std&lt;span style="color:#f92672">::&lt;/span>is_trivial&lt;span style="color:#f92672">&amp;lt;&lt;/span>StandardLayout&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Print(std&lt;span style="color:#f92672">::&lt;/span>is_standard_layout_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>StandardLayout&lt;span style="color:#f92672">&amp;gt;&lt;/span>); &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的标准布局的判定反而没有这么严格&lt;/p></description></item><item><title>从场景解析 C++ shared_from_this</title><link>https://jekyulll.github.io/posts/cpp-%E4%BB%8E%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90-c++-shared_from_this/</link><pubDate>Thu, 09 Jan 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E4%BB%8E%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90-c++-shared_from_this/</guid><description>&lt;hr>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_44517656/article/details/114208041">智能指针之shared_ptr易错点05&lt;/a>。&lt;br>
&lt;a href="https://zhuanlan.zhihu.com/p/701343248">掌握C++ 智能指针的自我引用：深入解析 &lt;code>shared_from_this&lt;/code> 和 &lt;code>weak_from_this&lt;/code>&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/weixin_44834554/article/details/131589849">C++之shared_from_this用法以及类自引用this指针陷阱&lt;/a>。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>思考&lt;/strong>：&lt;/p>
&lt;blockquote>
&lt;p>设计一个树的节点的时候，如果使用智能指针：用一个&lt;code>std::vector&amp;lt;shared_ptr&amp;lt;TreeNode&amp;gt;&amp;gt;&lt;/code>来存储子节点，为避免循环引用，用&lt;code>weak_ptr&amp;lt;TreeNode&amp;gt;&lt;/code>来存储自身的父节点指针。&lt;br>
那添加子节点的时候，怎么把自身的&lt;code>shared_ptr&lt;/code>赋值给子节点存储的父节点指针呢？&lt;/p>
&lt;/blockquote>
&lt;h3 id="两个错误做法">两个错误做法：&lt;/h3>
&lt;ol>
&lt;li>使用&lt;code>std::make_shared&amp;lt;TreeNode&amp;lt;T&amp;gt;&amp;gt;(*this)&lt;/code>来创建一个新的&lt;code>shared_ptr&lt;/code>，然后赋值给子节点存储的父节点指针。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addChild&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TreeNode&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> child) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 make_shared 来创建子节点并设置父节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> child&lt;span style="color:#f92672">-&amp;gt;&lt;/span>setParent(std&lt;span style="color:#f92672">::&lt;/span>make_shared&lt;span style="color:#f92672">&amp;lt;&lt;/span>TreeNode&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>)); &lt;span style="color:#75715e">// 错误的做法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> children.push_back(child);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>std::make_shared&amp;lt;TreeNode&amp;lt;T&amp;gt;&amp;gt;(*this)&lt;/code> 时，实际上是对当前对象的 拷贝构造（调用拷贝构造函数）来创建一个新的 &lt;code>TreeNode&amp;lt;T&amp;gt;&lt;/code> 对象。这意味着你将当前节点的状态（但不是智能指针）拷贝到一个新的对象中，而新对象的生命周期由 &lt;code>std::shared_ptr&lt;/code> 管理。&lt;/p>
&lt;ol start="2">
&lt;li>使用 &lt;code>std::shared_ptr&amp;lt;TreeNode&amp;lt;T&amp;gt;&amp;gt; ptr(this)&lt;/code> 把裸指针 &lt;code>this&lt;/code> 包装为 &lt;code>shared_ptr&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>将 &lt;code>this&lt;/code> 传递给 &lt;code>std::shared_ptr&amp;lt;TreeNode&amp;lt;T&amp;gt;&amp;gt;&lt;/code> 会导致新创建的 &lt;code>shared_ptr&lt;/code> 管理一个裸指针，而裸指针的生命周期没有由智能指针控制。&lt;/p>
&lt;p>引出一个常规问题，从裸指针创建 &lt;code>shared_ptr&lt;/code> 的隐患：&lt;/p>
&lt;ul>
&lt;li>当 &lt;code>shared_ptr&lt;/code> 的引用计数归零时，它会释放它所管理的对象。如果裸指针在此时继续存在，它仍然会指向原来的内存地址。但这时该内存已被释放，裸指针成为了&lt;em>悬空指针&lt;/em>，也就是所谓的&lt;em>野指针&lt;/em>。&lt;/li>
&lt;li>如果裸指针指向的内存已经被释放（例如，该指针原本由 &lt;code>delete&lt;/code> 或 &lt;code>delete[]&lt;/code> 释放），然后你用这个裸指针创建 &lt;code>shared_ptr&lt;/code>，那么 &lt;code>shared_ptr&lt;/code> 仍然会管理这个已经释放的内存区域。这会导致访问已释放内存（悬空指针）或&lt;em>双重释放内存&lt;/em>的问题（如果 &lt;code>shared_ptr&lt;/code> 销毁时再次释放内存）。&lt;/li>
&lt;li>裸指针可能指向一个栈上的对象：如果裸指针指向一个栈上分配的对象，并且你用它创建 &lt;code>shared_ptr&lt;/code>，那么 &lt;code>shared_ptr&lt;/code> 会试图在引用计数归零时释放这个栈上对象的内存。然而，栈上对象的生命周期由栈帧的销毁来管理，而 &lt;code>shared_ptr&lt;/code> 并不清楚这一点。这将导致程序的未定义行为。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>案例&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TestB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	TestB(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TestB create&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f92672">~&lt;/span>TestB(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TestB destory&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TestB&lt;span style="color:#f92672">&amp;gt;&lt;/span> getSharedFromThis() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TestB&lt;span style="color:#f92672">&amp;gt;&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TestB&lt;span style="color:#f92672">&amp;gt;&lt;/span> ptr3(&lt;span style="color:#66d9ef">new&lt;/span> TestB());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>TestB&lt;span style="color:#f92672">&amp;gt;&lt;/span> ptr4 &lt;span style="color:#f92672">=&lt;/span> ptr3&lt;span style="color:#f92672">-&amp;gt;&lt;/span>getSharedFromThis();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ptr2 count: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> ptr3.use_count() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; ptr4 count: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> ptr4.use_count() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">//输出：ptr2 count: 1 ptr4 count: 1 然后会崩溃因为重复释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	cin.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如何会导致&lt;code>shared_ptr&lt;/code>指向同一个对象，但是不共享引用计数器？&lt;br>
是因为裸指针与&lt;code>shared_ptr&lt;/code>混用，如果我们用一个裸指针初始化或者赋值给&lt;code>shared_ptr&lt;/code>指针时，在&lt;code>shared_ptr&lt;/code>内部生成一个计数器，当另外一个&lt;code>shared_ptr&lt;/code>不用&lt;code>share_ptr&lt;/code>赋值或者初始化的话，再次将一个裸指针赋值给另外一个&lt;code>shared_ptr&lt;/code>时，又一次生成一个计数器，两个计数器不共享。&lt;/p></description></item><item><title>Redis 数据结构之超日志 HyperLogLog</title><link>https://jekyulll.github.io/posts/redis-redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B6%85%E6%97%A5%E5%BF%97-hyperloglog/</link><pubDate>Wed, 08 Jan 2025 10:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/redis-redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B6%85%E6%97%A5%E5%BF%97-hyperloglog/</guid><description>&lt;p>Redis 在 2.8.9 版本添加了 HyperLogLog （HLL）。&lt;br>
HyperLogLog 是一种高效的基数估算工具，通过概率算法和哈希化技术，在常数空间内提供了基数的估算。&lt;/p>
&lt;p>&lt;em>eg&lt;/em>.&lt;/p>
&lt;ul>
&lt;li>统计一个网站的独立用户数。&lt;/li>
&lt;li>统计一个日志中的独立 IP 数量。&lt;/li>
&lt;li>计算一个流中的独立事件数。&lt;/li>
&lt;/ul>
&lt;p>传统的做法是将所有元素存储在集合中，然后进行去重、计数。但当集合的元素数量非常大时，这种方法会占用大量内存，甚至无法存储所有数据。&lt;br>
HyperLogLog 有一定误差，但对于海量数据来说，它的内存开销极低且精度足够高，非常适合用于大数据处理、流量统计、去重计数等场景。&lt;/p>
&lt;p>Redis 中的 HyperLogLog 支持以下操作：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>PFADD&lt;/code>&lt;/strong>：将元素添加到 HyperLogLog 中，Redis 会对元素进行哈希处理，并更新相应的桶。&lt;/li>
&lt;li>&lt;strong>&lt;code>PFCOUNT&lt;/code>&lt;/strong>：返回一个或多个 HyperLogLog 键的基数估算。&lt;/li>
&lt;li>&lt;strong>&lt;code>PFMERGE&lt;/code>&lt;/strong>：合并多个 HyperLogLog 键的基数估算。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="核心思想">核心思想&lt;/h3>
&lt;p>HyperLogLog 使用概率算法，通过哈希化数据并记录哈希值的前导零数量来估算基数。&lt;/p>
&lt;h5 id="1-哈希函数与二进制表示">&lt;strong>1. 哈希函数与二进制表示&lt;/strong>&lt;/h5>
&lt;p>为了将集合中的元素映射为哈希值，HyperLogLog 使用了 &lt;strong>哈希函数&lt;/strong>。假设我们使用一个 &lt;strong>m-bit&lt;/strong> 的哈希函数，它会把输入数据映射到一个包含 m 位二进制数字的哈希值。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;ul>
&lt;li>假设我们将一个元素哈希成 &lt;code>10111001101100010101010101101010&lt;/code> 这样的 32 位二进制数字。&lt;/li>
&lt;li>这个哈希值的前导零数量就是我们关心的指标。对于这个例子，假设前导零的数量为 3。&lt;/li>
&lt;/ul>
&lt;h5 id="2-关键点记录前导零的数量">&lt;strong>2. 关键点：记录前导零的数量&lt;/strong>&lt;/h5>
&lt;p>HyperLogLog 并不直接存储每个哈希值，而是计算每个哈希值的前导零的数量，把这个值保存在一个桶（通过哈希值的某些位进行映射）中。&lt;/p>
&lt;h5 id="3-桶与桶编号">&lt;strong>3. 桶与桶编号&lt;/strong>&lt;/h5>
&lt;p>为了优化空间，HyperLogLog 使用多个桶来存储不同的哈希值。每个桶的索引是由哈希值的某些位生成的。假设我们有一个桶数量为 &lt;code>b&lt;/code> 的 HyperLogLog。我们将哈希值的前 &lt;code>log2(b)&lt;/code> 位作为桶的索引，其余的位用于计算前导零数量。&lt;/p>
&lt;ul>
&lt;li>例如，如果我们有 16 个桶（&lt;code>b = 16&lt;/code>），则桶的索引由哈希值的前 4 位决定（因为 &lt;code>log2(16) = 4&lt;/code>）。如果哈希值的前 4 位为 &lt;code>1100&lt;/code>，那么该哈希值将被映射到第 12 号桶（因为 &lt;code>1100&lt;/code> 二进制对应 12）。&lt;/li>
&lt;/ul>
&lt;h5 id="4-计算基数估算">&lt;strong>4. 计算基数估算&lt;/strong>&lt;/h5>
&lt;p>HyperLogLog 会计算所有桶中记录的前导零最大值的平均值。然后根据这个平均值来估算整个数据集的基数。&lt;br>
其数学公式如下：&lt;/p></description></item><item><title>Linux 大文件传输场景题</title><link>https://jekyulll.github.io/posts/linux-linux-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%9C%BA%E6%99%AF%E9%A2%98/</link><pubDate>Tue, 07 Jan 2025 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-linux-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%9C%BA%E6%99%AF%E9%A2%98/</guid><description>&lt;p>(考察linux网络编程、系统编程、网络协议、网络传输协议等知识)&lt;/p>
&lt;blockquote>
&lt;p>问：局域网内有A、B、C三台主机，A与B不知道相互之间的IP。A要向B传输一个1G的文件，怎么做？&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;ol>
&lt;li>大文件传输的优化：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>分块传输：将大文件分成多个小块（如4KB、8KB等），每次传输一块，避免占用过多内存。&lt;/li>
&lt;li>校验和（Checksum）：在每一块传输后进行数据校验，确保数据的完整性。&lt;/li>
&lt;li>带宽控制：通过控制每次发送的数据量来避免一次性传输过多数据，控制网络负载。&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>断点续传的实现：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>记录传输进度：客户端和服务器都需要记录已经成功传输的数据块或字节的位置。&lt;/li>
&lt;li>支持断点请求：客户端在恢复传输时，应该告知服务器从哪个位置开始传输。&lt;/li>
&lt;li>校验和和确认机制：每次传输数据块后，都应该进行确认，确保数据正确传送。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>步骤&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>使用局域网广播发现B的IP地址
由于A和B的IP地址不直接已知，A可以通过&lt;strong>局域网广播&lt;/strong>来找到B的IP地址。A可以向网络中的所有主机发送一个&lt;em>UDP广播消息&lt;/em>，所有主机都会接收到这个消息，B在接收到这个广播后，可以回复A，告知自己的IP地址。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>UDP广播&lt;/strong>：A可以通过发送一个UDP广播包到特定的端口，让局域网中的所有主机收到该消息。B可以通过监听这个端口，收到消息后回应自己的IP地址。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>使用TCP协议进行文件传输
一旦A得到了B的IP地址，就可以使用TCP协议进行文件传输。A通过TCP连接到B，建立数据通道，开始发送1GB的文件。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="1-udp广播发现b的ip地址">1. UDP广播发现B的IP地址&lt;/h3>
&lt;p>A使用UDP广播向局域网中的所有主机发送请求，B收到请求后会通过UDP回应自己的IP地址。&lt;/p>
&lt;h4 id="a端发送udp广播请求">A端：发送UDP广播请求&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;arpa/inet.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define BROADCAST_PORT 12345
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">send_broadcast_message&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sockfd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in&lt;/span> broadcast_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> broadcast_enable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Are you there, B? Please reply with your IP address.&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建UDP套接字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> sockfd &lt;span style="color:#f92672">=&lt;/span> socket(AF_INET, SOCK_DGRAM, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (sockfd &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Socket creation failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 允许广播
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &lt;span style="color:#f92672">&amp;amp;&lt;/span>broadcast_enable, &lt;span style="color:#66d9ef">sizeof&lt;/span>(broadcast_enable)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Setting broadcast option failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>broadcast_addr, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(broadcast_addr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> broadcast_addr.sin_family &lt;span style="color:#f92672">=&lt;/span> AF_INET;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> broadcast_addr.sin_port &lt;span style="color:#f92672">=&lt;/span> htons(BROADCAST_PORT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> broadcast_addr.sin_addr.s_addr &lt;span style="color:#f92672">=&lt;/span> htonl(INADDR_BROADCAST);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 发送广播消息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (sendto(sockfd, message, strlen(message), &lt;span style="color:#ae81ff">0&lt;/span>, (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>broadcast_addr, &lt;span style="color:#66d9ef">sizeof&lt;/span>(broadcast_addr)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Broadcast failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Broadcast message sent!&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> send_broadcast_message();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="b端接收udp广播并回应自己的ip">B端：接收UDP广播并回应自己的IP&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;arpa/inet.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define BROADCAST_PORT 12345
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define RESPONSE_PORT 12346
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">listen_for_broadcasts&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sockfd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr_in&lt;/span> server_addr, client_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> socklen_t client_len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(client_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> buffer[&lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建UDP套接字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> sockfd &lt;span style="color:#f92672">=&lt;/span> socket(AF_INET, SOCK_DGRAM, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (sockfd &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Socket creation failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>server_addr, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(server_addr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server_addr.sin_family &lt;span style="color:#f92672">=&lt;/span> AF_INET;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server_addr.sin_port &lt;span style="color:#f92672">=&lt;/span> htons(BROADCAST_PORT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server_addr.sin_addr.s_addr &lt;span style="color:#f92672">=&lt;/span> htonl(INADDR_ANY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 绑定UDP套接字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (bind(sockfd, (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>server_addr, &lt;span style="color:#66d9ef">sizeof&lt;/span>(server_addr)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Bind failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 接收广播消息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (true) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> recv_len &lt;span style="color:#f92672">=&lt;/span> recvfrom(sockfd, buffer, &lt;span style="color:#66d9ef">sizeof&lt;/span>(buffer), &lt;span style="color:#ae81ff">0&lt;/span>, (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>client_addr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>client_len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (recv_len &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perror(&lt;span style="color:#e6db74">&amp;#34;Failed to receive message&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer[recv_len] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Received message: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> buffer &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果消息包含特定请求，可以回复自己的IP地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string response &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;IP Address of B: &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response &lt;span style="color:#f92672">+=&lt;/span> inet_ntoa(client_addr.sin_addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sendto(sockfd, response.c_str(), response.length(), &lt;span style="color:#ae81ff">0&lt;/span>, (&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>client_addr, client_len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sent response with IP address: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> inet_ntoa(client_addr.sin_addr) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listen_for_broadcasts();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-使用tcp协议传输文件">2. 使用TCP协议传输文件&lt;/h3>
&lt;p>一旦A得到了B的IP地址，A就可以通过TCP连接与B进行文件传输。&lt;/p></description></item><item><title>分段锁技术详解及 C++ 实现</title><link>https://jekyulll.github.io/posts/cpp-%E5%88%86%E6%AE%B5%E9%94%81%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%E5%8F%8A-c++-%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 01 Jan 2025 14:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E5%88%86%E6%AE%B5%E9%94%81%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%E5%8F%8A-c++-%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>分段锁（Segmented Locking）是一种用于优化多线程访问共享资源时锁粒度的技术。它通过将资源分成多个小段，并为每段分配独立的锁，来减少锁的争用，从而提升并发性能。&lt;/p>
&lt;p>分段锁通过减少锁粒度，让多个线程可以同时访问不同的段，从而显著提高性能。这种方法常见于 &lt;strong>哈希表&lt;/strong>、&lt;strong>数据库索引&lt;/strong> 和其他高并发系统中。&lt;/p>
&lt;hr>
&lt;h4 id="基本原理">&lt;strong>基本原理&lt;/strong>&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>划分资源&lt;/strong>：
将容器划分为多个独立的段（&lt;code>segment&lt;/code>），每段可以包含一部分数据。例如，一个哈希表可以按哈希值将数据分配到多个桶（&lt;code>bucket&lt;/code>），每个桶代表一个段。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>独立加锁&lt;/strong>：
每个段都有一个独立的锁（如 &lt;code>std::mutex&lt;/code> 或 &lt;code>std::shared_mutex&lt;/code>），对该段的数据操作时，只需要锁定对应的段即可，其他段不受影响。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>映射规则&lt;/strong>：
通过某种映射规则（如哈希函数）将操作定位到特定的段。这种映射规则应尽可能均匀，以避免&lt;em>热点问题&lt;/em>（即某些段过于频繁被访问，导致锁竞争）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="适用场景">&lt;strong>适用场景&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>高并发读写&lt;/strong>：如多线程访问的大型哈希表、数据库索引。&lt;/li>
&lt;li>&lt;strong>热点数据分散&lt;/strong>：通过分段减少单点锁的争用，提升性能。&lt;/li>
&lt;li>&lt;strong>读多写少&lt;/strong>：可以结合 &lt;code>std::shared_mutex&lt;/code> 提供共享锁和独占锁，进一步优化读性能。&lt;/li>
&lt;/ul>
&lt;p>注：&lt;strong>负载不均风险&lt;/strong>：如果映射规则不合理，可能导致某些段成为热点(eg. 热点桶)，影响性能。&lt;/p>
&lt;hr>
&lt;p>下面通过一个线程安全的哈希表（&lt;code>ThreadSafeHashMap&lt;/code>）来展示分段锁的实现(用&lt;code>std::vector&lt;/code>简单模拟)。&lt;/p>
&lt;ol>
&lt;li>将哈希表分为多个桶（&lt;code>bucket&lt;/code>），每个桶独立管理其数据。&lt;/li>
&lt;li>使用哈希函数将键映射到对应的桶。&lt;/li>
&lt;li>为每个桶分配一个 &lt;code>std::mutex&lt;/code> 来保护数据。&lt;/li>
&lt;li>对于读操作，只锁定对应的桶，支持并行读取。&lt;/li>
&lt;li>对于写操作，也只锁定对应的桶，减少锁的范围。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;shared_mutex&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;thread&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> Key, &lt;span style="color:#66d9ef">typename&lt;/span> Value&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadSafeHashMap&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Bucket&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shared_mutex mtx; &lt;span style="color:#75715e">// 每个桶的独立锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>Key, Value&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Bucket&lt;span style="color:#f92672">&amp;gt;&lt;/span> buckets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t num_buckets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 哈希函数，将键映射到对应的桶
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> size_t &lt;span style="color:#a6e22e">hash&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Key&lt;span style="color:#f92672">&amp;amp;&lt;/span> key) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>hash&lt;span style="color:#f92672">&amp;lt;&lt;/span>Key&lt;span style="color:#f92672">&amp;gt;&lt;/span>{}(key) &lt;span style="color:#f92672">%&lt;/span> num_buckets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadSafeHashMap(size_t num_buckets &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> num_buckets(num_buckets) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buckets.resize(num_buckets);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 插入操作，按桶分段加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">insert&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Key&lt;span style="color:#f92672">&amp;amp;&lt;/span> key, &lt;span style="color:#66d9ef">const&lt;/span> Value&lt;span style="color:#f92672">&amp;amp;&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t index &lt;span style="color:#f92672">=&lt;/span> hash(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(buckets[index].mtx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buckets[index].data.push_back({key, value});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 查找操作，按桶分段加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Key&lt;span style="color:#f92672">&amp;amp;&lt;/span> key, Value&lt;span style="color:#f92672">&amp;amp;&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t index &lt;span style="color:#f92672">=&lt;/span> hash(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shared_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(buckets[index].mtx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> pair : buckets[index].data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pair.first &lt;span style="color:#f92672">==&lt;/span> key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#f92672">=&lt;/span> pair.second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 删除操作，按桶分段加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Key&lt;span style="color:#f92672">&amp;amp;&lt;/span> key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t index &lt;span style="color:#f92672">=&lt;/span> hash(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>unique_lock&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_mutex&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock(buckets[index].mtx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> bucket &lt;span style="color:#f92672">=&lt;/span> buckets[index].data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> bucket.begin(); it &lt;span style="color:#f92672">!=&lt;/span> bucket.end(); &lt;span style="color:#f92672">++&lt;/span>it) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first &lt;span style="color:#f92672">==&lt;/span> key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bucket.erase(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadSafeHashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 多线程插入数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t1([&lt;span style="color:#f92672">&amp;amp;&lt;/span>]() { map.insert(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;one&amp;#34;&lt;/span>); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t2([&lt;span style="color:#f92672">&amp;amp;&lt;/span>]() { map.insert(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;two&amp;#34;&lt;/span>); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">thread&lt;/span> t3([&lt;span style="color:#f92672">&amp;amp;&lt;/span>]() { map.insert(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;three&amp;#34;&lt;/span>); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t1.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t2.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t3.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 查找数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map.find(&lt;span style="color:#ae81ff">2&lt;/span>, value)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Found: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> value &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 删除数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> map.erase(&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>像 &lt;a href="https://github.com/uxlfoundation/oneTBB">Intel TBB&lt;/a> 等并发库提供了更加高效的线程安全容器。&lt;/p></description></item><item><title>简述如何解决哈希冲突？</title><link>https://jekyulll.github.io/posts/cpp-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</link><pubDate>Wed, 01 Jan 2025 12:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</guid><description>&lt;blockquote>
&lt;p>哈希冲突是指 &lt;strong>不同的输入&lt;/strong>（通常是不同的键）通过哈希函数计算后，得到相同的哈希值并被映射到相同的桶或位置。这是哈希算法的一个固有问题，通常发生在哈希表中。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h4 id="为什么会有哈希冲突">&lt;strong>为什么会有哈希冲突？&lt;/strong>&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>有限的哈希空间&lt;/strong>：&lt;br>
假设哈希函数将键映射到一个固定大小的数组中，哈希表的桶数有限，而键的数量可能很大（例如百万个不同的键），那么无论哈希函数设计得多么巧妙，都可能有多个键映射到同一个桶。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>哈希函数的碰撞&lt;/strong>：&lt;br>
哈希函数的设计决定了如何将键映射到哈希表的桶中。如果哈希函数不足够“分散”键值，导致多个键的哈希值相同，就会产生冲突。即使两个键的实际值不同，它们也可能因为哈希函数的限制而得到相同的哈希值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>键的分布不均匀&lt;/strong>：&lt;br>
如果数据（即键）在哈希表中的分布不均匀，某些桶可能会有大量的键，而其他桶则几乎没有。这通常是由于选择的哈希函数无法均匀地分布键值，导致哈希冲突在某些桶中更加集中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>哈希冲突的发生是不可避免的，因为：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>有限的输出空间&lt;/strong>：
哈希函数的输出通常是固定长度的（比如 32 位、64 位或更高），而实际的输入数据可以非常庞大。例如，输入可能是所有的整数、字符串或者更复杂的数据结构，数量远远超过了哈希值的种类。因此，总会有两个不同的输入数据被映射到相同的哈希值（即哈希冲突）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>抽象数据类型&lt;/strong>：
对于复杂的数据类型（如对象、结构体、字符串等），设计一个完美的哈希函数是非常困难的。在某些情况下，即使设计了高效的哈希算法，也很难保证哈希值的完全均匀分布，因此冲突不可避免。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="如何处理哈希冲突">&lt;strong>如何处理哈希冲突？&lt;/strong>&lt;/h3>
&lt;p>尽管哈希冲突不可避免，但我们可以采用多种方法来解决或减少冲突的影响：&lt;/p>
&lt;h4 id="1-链表法separate-chaining">1. &lt;strong>链表法（Separate Chaining）&lt;/strong>&lt;/h4>
&lt;p>每个桶（哈希表的一个位置）存储一个链表，所有映射到相同哈希值的元素都放在这个链表中。虽然哈希冲突发生，但可以通过遍历链表来解决。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>优点&lt;/strong>：简单易懂，适用于动态扩容。&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：性能取决于链表的长度，如果链表较长，查找、插入、删除的时间复杂度会退化为 &lt;code>O(n)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h4 id="2-开放地址法open-addressing">2. &lt;strong>开放地址法（Open Addressing）&lt;/strong>&lt;/h4>
&lt;p>在这种方法中，当哈希冲突发生时，程序会尝试在表中寻找另一个空的位置来存储数据。常见的解决方式包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>线性探测&lt;/strong>：检查当前位置之后的下一个位置，直到找到空位。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>二次探测&lt;/strong>：尝试检查当前位置之后的平方距离的其他位置，避免线性探测中可能出现的聚集问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>双重哈希&lt;/strong>：使用第二个哈希函数来决定探测的步长。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>优点&lt;/strong>：避免了链表法的额外内存开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缺点&lt;/strong>：当哈希表装载过高时，查找效率会下降。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="3-再哈希rehashing">3. &lt;strong>再哈希（Rehashing）&lt;/strong>&lt;/h4>
&lt;p>再哈希是通过扩展哈希表的大小并重新计算每个元素的哈希值来解决冲突。当哈希表装载因子过高时（即元素数量接近桶的数量），会触发再哈希过程。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>优点&lt;/strong>：能够有效减少冲突，提高性能。&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：再哈希时会涉及到大量的重新计算和内存分配，可能导致性能下降。&lt;/li>
&lt;/ul>
&lt;h4 id="4-使用平衡树如红黑树">4. &lt;strong>使用平衡树（如红黑树）&lt;/strong>&lt;/h4>
&lt;p>在哈希表中，如果某个桶的冲突过多，可以使用红黑树（或者其他平衡二叉树）来存储冲突的元素，这样可以在每个桶内保持较好的查找、插入性能。红黑树的查找、插入、删除时间复杂度为 &lt;code>O(log N)&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>优点&lt;/strong>：比链表法更高效，能够提供对数时间的操作。&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：相比链表法，维护平衡树需要更多的时间和内存。&lt;/li>
&lt;/ul></description></item><item><title>C++ 编译器返回值优化</title><link>https://jekyulll.github.io/posts/cpp-c++-%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 23 Dec 2024 08:42:29 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</guid><description>&lt;p>在 C++ 中，当函数返回一个对象时，编译器通常需要进行对象的拷贝或移动操作。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>SomeClass &lt;span style="color:#a6e22e">createObject&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeClass obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置 obj 的一些成员
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> obj; &lt;span style="color:#75715e">// 返回一个对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在没有优化的情况下，&lt;code>obj&lt;/code> 被返回时，编译器可能会执行一次拷贝构造或移动构造操作，甚至可能是两次（先拷贝到临时对象，再从临时对象拷贝到目标变量）。这些额外的拷贝或移动操作会导致性能下降。&lt;/p>
&lt;p>为了减少这种不必要的开销，现代 C++ 编译器通常会进行优化，减少返回值时的拷贝或移动，使用如 &lt;strong>RVO&lt;/strong> 和 &lt;strong>NRVO&lt;/strong> 的优化策略。&lt;/p>
&lt;h3 id="1-rvoreturn-value-optimization返回值优化">1. RVO（Return Value Optimization，返回值优化）&lt;/h3>
&lt;p>RVO（Return Value Optimization，返回值优化），编译器可以直接在目标变量的位置构造返回值，减少不必要的对象拷贝和内存开销。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>SomeClass &lt;span style="color:#a6e22e">createObject&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeClass obj; &lt;span style="color:#75715e">// 局部对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> obj; &lt;span style="color:#75715e">// 返回该对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在没有优化的情况下，&lt;code>obj&lt;/code> 被返回时，编译器可能会做两次操作：&lt;/p>
&lt;ol>
&lt;li>将 &lt;code>obj&lt;/code> 拷贝或移动到一个临时对象中。&lt;/li>
&lt;li>将临时对象拷贝或移动到调用者的目标变量。&lt;/li>
&lt;/ol>
&lt;p>RVO 的核心思想是，在函数返回临时对象时，编译器可以&lt;u>直接将返回值构造到调用者的接收变量中&lt;/u>，而无需通过中间的临时对象进行拷贝或移动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeClass obj &lt;span style="color:#f92672">=&lt;/span> createObject(); &lt;span style="color:#75715e">// RVO 优化将直接构造在 obj 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RVO 只适用于临时对象返回的场景，对于具名对象（有名称的局部对象），编译器一般不能直接应用 RVO。返回具名对象时，编译器会尝试应用 NRVO（Named Return Value Optimization，命名返回值优化），以减少不必要的拷贝或移动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>SomeClass &lt;span style="color:#a6e22e">createObject&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeClass obj; &lt;span style="color:#75715e">// 具名局部变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> obj; &lt;span style="color:#75715e">// 这里不能使用 RVO
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译器行为：&lt;/p></description></item><item><title>缓存的设计</title><link>https://jekyulll.github.io/posts/cpp-%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1/</link><pubDate>Sat, 21 Dec 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid><description>&lt;ol>
&lt;li>数据结构&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>std::unordered_map&lt;/code>：用于快速查找键值对。&lt;/li>
&lt;li>双向链表：与哈希表结合实现 LRU 缓存。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>淘汰策略&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>LRU&lt;/strong> (Least Recently Used)：删除最近最少使用的元素。&lt;/li>
&lt;li>&lt;strong>LFU&lt;/strong> (Least Frequently Used)：删除使用频率最低的元素。&lt;/li>
&lt;li>&lt;strong>FIFO&lt;/strong> (First In First Out)：删除最早进入缓存的元素。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>并发处理&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>读写锁&lt;/strong>（如std::shared_mutex）：允许多个读者或一个写者。&lt;/li>
&lt;li>&lt;strong>线程安全容器&lt;/strong>：可以使用库（如 TBB 或 Folly）提供的线程安全容器。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>高级优化&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>分片缓存&lt;/strong>：使用分片（sharding）将缓存划分成多个独立的部分，以减少锁争用。例如，使用键的哈希值对分片数量取模。&lt;/li>
&lt;li>&lt;strong>持久化&lt;/strong>：将缓存数据保存到磁盘（如使用 RocksDB 或 Redis），以便服务重启后恢复。&lt;/li>
&lt;li>&lt;strong>预加载&lt;/strong>：在服务启动时，预加载常用的数据到缓存中，减少冷启动时间。&lt;/li>
&lt;li>&lt;strong>分布式缓存&lt;/strong>：如果单机缓存不足，可以使用分布式缓存（如 Memcached 或 Redis）来扩展容量。&lt;/li>
&lt;li>&lt;strong>监控和调试&lt;/strong>：添加缓存命中率统计、日志记录和监控接口，以便分析性能和优化缓存策略。&lt;/li>
&lt;/ul></description></item><item><title>表格展示 MySQL 基础数据类型</title><link>https://jekyulll.github.io/posts/database-%E8%A1%A8%E6%A0%BC%E5%B1%95%E7%A4%BA-mysql-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Thu, 21 Nov 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/database-%E8%A1%A8%E6%A0%BC%E5%B1%95%E7%A4%BA-mysql-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>数据类型&lt;/th>
 &lt;th>描述&lt;/th>
 &lt;th>存储范围/格式&lt;/th>
 &lt;th>示例&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>INT（整数型）&lt;/td>
 &lt;td>存储整数，有不同的字节大小来适应不同范围的整数&lt;/td>
 &lt;td>有TINYINT（1字节，范围 - 128到127）、SMALLINT（2字节，范围 - 32768到32767）、MEDIUMINT（3字节）、INT（4字节，范围 - 2147483648到2147483647）、BIGINT（8字节）&lt;/td>
 &lt;td>&lt;code>age INT;&lt;/code>，可以存储像25这样的年龄值&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>FLOAT和DOUBLE（浮点型）&lt;/td>
 &lt;td>用于存储带有小数部分的数值，FLOAT精度较低，DOUBLE精度较高&lt;/td>
 &lt;td>FLOAT单精度浮点数，大约7位有效数字；DOUBLE双精度浮点数，大约15位有效数字&lt;/td>
 &lt;td>&lt;code>price FLOAT;&lt;/code>可以存储像9.99这样的价格值，对于更高精度的科学计算可能使用&lt;code>measurement DOUBLE;&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>DECIMAL&lt;/td>
 &lt;td>精确的小数值存储，常用于金融等对精度要求极高的领域&lt;/td>
 &lt;td>格式为DECIMAL(M,D)，M是数字总位数，D是小数点后的位数&lt;/td>
 &lt;td>&lt;code>amount DECIMAL(10,2);&lt;/code>可以精确存储像12345.67这样的金额，其中总共可以存储10位数字，小数点后2位&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>CHAR&lt;/td>
 &lt;td>定长字符串，存储固定长度的字符序列&lt;/td>
 &lt;td>定义时指定长度，如CHAR(10)，最多存储10个字符，不足部分用空格填充&lt;/td>
 &lt;td>&lt;code>code CHAR(5);&lt;/code>可以存储像&amp;rsquo;ABCD &amp;lsquo;（注意后面有空格）这样的字符串&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>VARCHAR&lt;/td>
 &lt;td>可变长字符串，根据实际存储的字符长度占用空间&lt;/td>
 &lt;td>定义最大长度，如VARCHAR(255)，实际存储多长就占用多少空间加上1 - 2字节用于记录长度&lt;/td>
 &lt;td>&lt;code>name VARCHAR(50);&lt;/code>可以存储像&amp;rsquo;John Doe&amp;rsquo;这样的名字，长度小于等于50个字符&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>TEXT&lt;/td>
 &lt;td>用于存储大量文本内容&lt;/td>
 &lt;td>有TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT，存储大小逐渐增大&lt;/td>
 &lt;td>&lt;code>description TEXT;&lt;/code>可以存储一篇短文或者产品描述&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>BLOB&lt;/td>
 &lt;td>存储二进制大型对象，如图像、音频等&lt;/td>
 &lt;td>有TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB，存储大小逐渐增大&lt;/td>
 &lt;td>&lt;code>image BLOB;&lt;/code>可以存储一张照片的二进制数据&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>DATE&lt;/td>
 &lt;td>存储日期，格式为YYYY - MM - DD&lt;/td>
 &lt;td>从1000 - 01 - 01到9999 - 12 - 31&lt;/td>
 &lt;td>&lt;code>birth_date DATE;&lt;/code>可以存储像'2000 - 01 - 01&amp;rsquo;这样的出生日期&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>TIME&lt;/td>
 &lt;td>存储时间，格式为HH:MM:SS&lt;/td>
 &lt;td>-&lt;/td>
 &lt;td>&lt;code>start_time TIME;&lt;/code>可以存储像'09:00:00&amp;rsquo;这样的开始时间&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>DATETIME&lt;/td>
 &lt;td>存储日期和时间，格式为YYYY - MM - DD HH:MM:SS&lt;/td>
 &lt;td>从1000 - 01 - 01 00:00:00到9999 - 12 - 31 23:59:59&lt;/td>
 &lt;td>&lt;code>order_time DATETIME;&lt;/code>可以存储像'2024 - 01 - 01 10:30:00&amp;rsquo;这样的订单时间&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>TIMESTAMP&lt;/td>
 &lt;td>存储日期和时间戳，会受到时区影响&lt;/td>
 &lt;td>从1970 - 01 - 01 00:00:00 UTC到2038 - 01 - 19 03:14:07 UTC&lt;/td>
 &lt;td>&lt;code>update_time TIMESTAMP;&lt;/code>用于记录更新时间，在不同时区设置下可能会有变化&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table></description></item><item><title>Linux 进程优先级</title><link>https://jekyulll.github.io/posts/linux-linux-%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</link><pubDate>Mon, 04 Nov 2024 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-linux-%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</guid><description>&lt;h5 id="图解linux进程优先级httpsmpweixinqqcoms__bizmzkyndiynzu4mgmid2247484435idx1snb6f30489cf388f1024d6883abb8237c8chksmc1d84682f6afcf94c1af14678d5401d558d2b728f0e6c853dbe4efe02c12dfa147369ceee13frd">&lt;a href="https://mp.weixin.qq.com/s?__biz=MzkyNDIyNzU4Mg==&amp;amp;mid=2247484435&amp;amp;idx=1&amp;amp;sn=b6f30489cf388f1024d6883abb8237c8&amp;amp;chksm=c1d84682f6afcf94c1af14678d5401d558d2b728f0e6c853dbe4efe02c12dfa147369ceee13f#rd">图解Linux进程优先级&lt;/a>&lt;/h5>
&lt;p>&lt;em>实时优先级&lt;/em>用于实时应用程序，如硬实时任务和实时控制系统，而&lt;em>普通优先级&lt;/em>用于非实时应用程序。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>实时进程&lt;/strong>：动态优先级为0-99的进程，采用&lt;em>实时调度算法&lt;/em>调度。&lt;/li>
&lt;li>&lt;strong>普通进程&lt;/strong>：动态优先级为100-139的进程，采用&lt;em>完全公平调度算法&lt;/em>调度。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzkyNDIyNzU4Mg==&amp;amp;mid=2247484458&amp;amp;idx=1&amp;amp;sn=e4e64c006d4d822c6e7c184ab50540c1&amp;amp;chksm=c1d846bbf6afcfad20af0a7132eca1e3fd3c765ea5d4ee4134985b2b03f2461c207239fcc208#rd">Linux进程调度之完全公平调度（压箱底的干货分享）&lt;/a>。完全公平调度，CFS (Completely Fair Scheduler) 。&lt;/p>
&lt;p>&lt;strong>nice值&lt;/strong>：是用于调整普通进程优先级的参数。范围：&lt;code>-20&lt;/code>-&lt;code>19&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>task_struct {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> prio; 			&lt;span style="color:#75715e">// prio（动态优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> static_prio;	&lt;span style="color:#75715e">// static_prio（静态优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> normal_prio;	&lt;span style="color:#75715e">// normal_prio（归一化优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> rt_priority; 	&lt;span style="color:#75715e">// rt_priority（实时优先级）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>&lt;code>prio&lt;/code>（动态优先级）&lt;br>
动态优先级，有效优先级，调度器最终使用的优先级数值，范围0-139，值越小，优先级越高。&lt;/li>
&lt;li>&lt;code>static_prio&lt;/code>（静态优先级）&lt;br>
静态优先级，采用&lt;code>SCHED_NORMAL&lt;/code>和&lt;code>SCHED_BATCH&lt;/code>调度策略的进程（即普通进程）用于计算动态优先级的，范围100-139。
prio = static_prio = nice + DEFAULT_PRIO = nice + 120&lt;/li>
&lt;li>&lt;code>normal_prio&lt;/code>（归一化优先级）&lt;br>
用于计算&lt;code>prio&lt;/code>的中间变量，不需要太关心。&lt;/li>
&lt;li>&lt;code>rt_priority&lt;/code>（实时优先级）&lt;br>
实时优先级，采用&lt;code>SCHED_FIFO&lt;/code>和&lt;code>SCHED_RR&lt;/code>调度策略进程（即实时进程）用于计算动态优先级，范围0-99。
prio = MAX_RT_PRIO - 1 - rt_prio = 100 - 1 - rt_priority;&lt;/li>
&lt;/ol>
&lt;p>实时优先级数值越大，得到的动态优先级数值越小，优先级越高。&lt;/p>
&lt;p>&lt;code>ps -elf&lt;/code>命令查看进程优先级。&lt;code>PRI&lt;/code>：进程优先级，数值越小，优先级越高。（并非动态优先级）&lt;code>NI&lt;/code>：nice值。&lt;/p>
&lt;p>&lt;code>SCHED_FIFO&lt;/code>（先进先出调度）和&lt;code>SCHED_RR&lt;/code>（时间片轮转调度），这些策略可以通过&lt;code>sched_setscheduler()&lt;/code>系统调用（头文件&lt;code>&amp;lt;sched.h&amp;gt;&lt;/code>）来设置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sched_param&lt;/span> param;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置优先级为最高优先级
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> param.sched_priority &lt;span style="color:#f92672">=&lt;/span> sched_get_priority_max(SCHED_FIFO);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 设置调度策略为SCHED_FIFO
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (sched_setscheduler(getpid(), SCHED_FIFO, &lt;span style="color:#f92672">&amp;amp;&lt;/span>param) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cerr &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;无法设置实时调度策略&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Linux 文件系统与虚拟文件系统</title><link>https://jekyulll.github.io/posts/linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 04 Nov 2024 20:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h1 id="linux-文件系统">Linux 文件系统&lt;/h1>
&lt;p>&lt;strong>文件描述符&lt;/strong>(File Descriptor，FD)(win里一般称为文件句柄)是操作系统中用于标识和管理已打开文件或I/O资源的整数值。&lt;br>
当进程请求打开一个文件或资源时，操作系统为该资源分配一个文件描述符，并将其返回给进程。进程随后使用该文件描述符来进行读写操作。
是一个进程级别的概念。&lt;/p>
&lt;ul>
&lt;li>继承：在创建子进程时，文件描述符可以在父子进程之间共享（例如通过 fork()）。&lt;/li>
&lt;li>复制：通过系统调用 dup() 或 dup2() 可以复制文件描述符，使它们引用同一个文件或资源。&lt;/li>
&lt;/ul>
&lt;p>文件描述符不仅用于操作文件，还可以指向：&lt;/p>
&lt;ul>
&lt;li>管道（Pipes）：用于进程间通信。&lt;/li>
&lt;li>套接字（Sockets）：用于网络通信。&lt;/li>
&lt;li>设备文件：例如硬盘、串口等设备。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>文件分配表&lt;/strong>(File Allocation Table, FAT)。&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1jy4y1K73r/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">何为文件索引节点?文件与磁盘的爱恨情仇。&lt;/a>。&lt;br>
&lt;a href="https://ruanyifeng.com/blog/2011/12/inode.html">阮一峰的个人网站&lt;/a>。&lt;br>
&lt;strong>inode&lt;/strong>（索引节点）。&lt;a href="https://ruanyifeng.com/blog/2011/12/inode.html">理解inode&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>文件储存在硬盘上，硬盘的最小存储单位叫做&amp;quot;扇区&amp;quot;（Sector）。每个扇区储存512字节（相当于0.5KB）。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个&amp;quot;块&amp;quot;（block）。这种由多个扇区组成的&amp;quot;块&amp;quot;，是文件存取的最小单位。&amp;ldquo;块&amp;quot;的大小，最常见的是4KB，即连续八个 sector组成一个 block。
文件数据都储存在&amp;quot;块&amp;quot;中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为&amp;quot;索引节点&amp;rdquo;。&lt;br>
可以用&lt;code>stat&lt;/code>命令，查看某个文件的inode信息。
inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是&lt;strong>inode区&lt;/strong>（inode table），存放inode所包含的信息。
Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>超级块&lt;/strong>（Superblock）位于每个文件系统的开头，提供了操作系统如何解释和管理该文件系统的元数据。(记录各个inode?)&lt;/p>
&lt;p>&lt;strong>软链接和硬链接：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>软链接是一个独立的文件，它包含了另一个文件或目录的路径。它类似于 Windows 系统中的快捷方式。&lt;/li>
&lt;li>硬链接是文件的一个直接引用（或者说是指针），它与原文件共享相同的inode。删除原文件后，硬链接仍然有效，因为它直接引用了文件的数据；文件只有当所有硬链接都被删除后，数据才会被清除。inode信息中有一项叫做&amp;quot;链接数&amp;quot;，记录指向该inode的文件名总数。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>linux软件更新过程：软件更新变得简单：系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h1 id="linux-虚拟文件系统">Linux 虚拟文件系统&lt;/h1>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/3815712411">linux I/O原理、监控、和调优思路&lt;/a>。&lt;br>
&lt;a href="https://zhuanlan.zhihu.com/p/681048030">图解Linux虚拟文件系统(VFS)之关系篇&lt;/a>。&lt;/p>
&lt;p>&lt;strong>虚拟文件系统&lt;/strong>（Virtual File System，VFS）：它提供了一个统一的接口，使得用户和应用程序可以通过相同的方式访问不同类型的文件系统。&lt;/p>
&lt;blockquote>
&lt;p>通过VFS用户可以使用相同的系统调用（如&lt;code>open&lt;/code>、&lt;code>read&lt;/code>、&lt;code>write&lt;/code>等）来访问不同类型的文件系统，包括本地文件系统（如ext4、XFS等）、网络文件系统（如NFS、CIFS等）以及虚拟文件系统（如procfs、sysfs等）。&lt;/p>
&lt;/blockquote>
&lt;p>VFS由以下几个主要组件组成：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>虚拟文件系统接口&lt;/strong>：VFS定义了一组通用的文件系统操作接口。&lt;/li>
&lt;li>&lt;strong>超级块(super_block)&lt;/strong>：每个文件系统都有一个超级块，它包含了文件系统的元数据信息，如文件系统类型、块大小、inode表等，超级块提供了对文件系统的整体描述和管理。&lt;/li>
&lt;li>&lt;strong>目录项(dentry)&lt;/strong>：Directory Entry，用于表示文件系统中的目录和文件，dentry包含了目录和文件对应的inode指针、层级关系(parent)等。
&lt;blockquote>
&lt;p>dentry结构体的主要作用是提供文件系统层次结构的表示，它们通过形成一个树状结构来组织目录和文件，每个dentry都有一个唯一的路径名，可以通过遍历dentry树来找到特定文件或目录。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> dentry {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> dentry &lt;span style="color:#f92672">*&lt;/span>d_parent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> qstr d_name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>d_inode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> dentry_operations &lt;span style="color:#f92672">*&lt;/span>d_op;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> super_block &lt;span style="color:#f92672">*&lt;/span>d_sb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> list_head d_child;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> list_head d_subdirs;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>&lt;strong>文件节点(inode)&lt;/strong>：inode是文件系统中的一个数据结构，用于存储文件或目录的元数据信息，如文件大小、权限、所有者等，每个文件或目录都对应一个唯一的inode。&lt;/li>
&lt;li>&lt;strong>文件对象(file)&lt;/strong>：file是表示打开文件的数据结构，它包含了对应的inode指针、当前读写位置等信息，通过file可以进行文件的读写操作。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>索引节点&lt;/strong>(index node, inode)，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。&lt;/li>
&lt;li>&lt;strong>目录项&lt;/strong>(directory entry, dentry)，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>ramfs&lt;/strong>是一种基于内存的文件系统。它将所有的文件数据存储在内存（RAM）中，而不是像传统的文件系统那样存储在磁盘等外部存储设备上。&lt;/p></description></item><item><title>事务 Transaction 的基础特性</title><link>https://jekyulll.github.io/posts/database-%E4%BA%8B%E5%8A%A1transaction%E7%9A%84%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 04 Nov 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/database-%E4%BA%8B%E5%8A%A1transaction%E7%9A%84%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/</guid><description>&lt;p>&lt;strong>事务&lt;/strong>（Transaction）是数据库管理系统执行过程中的一个逻辑单位，它由一个或多个数据库操作组成，这些操作要么全部执行成功，要么全部不执行，以保证数据的一致性和完整性。&lt;br>
&lt;strong>ACID&lt;/strong> 是事务的四个重要特性：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>原子性&lt;/strong>（Atomicity）;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>一致性&lt;/strong>（Consistency）;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>隔离性&lt;/strong>（Isolation）；不同的隔离级别：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>读未提交&lt;/strong>（Read Uncommitted）：最低的隔离级别。一个事务可以读取另一个未提交事务的数据。
&lt;ul>
&lt;li>可能会出现&lt;strong>脏读&lt;/strong>（Dirty Read）的情况。
&lt;blockquote>
&lt;p>脏读是指一个事务读取了另一个尚未提交的事务修改的数据。eg.事务 T1 修改了一条记录但尚未提交，事务 T2 在这个时候读取了这条被修改的记录。如果 T1 后来回滚了，那么 T2 读取的数据就是无效的、“脏” 的数据。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>读已提交&lt;/strong>（Read Committed）：
&lt;ul>
&lt;li>可能会出现&lt;strong>不可重复读&lt;/strong>（Non - Repeatable Read）的问题。
&lt;blockquote>
&lt;p>不可重复读是指在一个事务内，多次读取同一数据，由于其他事务的修改操作，导致每次读取的结果不同。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>可重复读&lt;/strong>（Repeatable Read）：
&lt;ul>
&lt;li>可能会出现幻读（Phantom Read）的情况。
&lt;blockquote>
&lt;p>当一个事务（T1）按照一定的条件进行数据读取操作时，第一次读取没有发现满足条件的某些行（记录）。但是在这个事务还没有结束的时候，另一个事务（T2）插入（或删除）了一些满足（或原本满足）T1 查询条件的行。当 T1 再次按照相同的条件进行读取时，就会发现比第一次读取时更多（或更少）的符合条件的行，这些 “凭空出现” 或 “突然消失” 的行就像 “幻觉” 一样，所以被称为幻读。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>串行化&lt;/strong>（Serializable）：最高的隔离级别。牺牲了数据库的并发性能。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>持久性&lt;/strong>（Durability）。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>CPU 的五级流水线</title><link>https://jekyulll.github.io/posts/system-cpu-%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/</link><pubDate>Wed, 09 Oct 2024 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/system-cpu-%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/</guid><description>&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/382372072">现代C++的内存模型&lt;/a>。&amp;ndash;神文&lt;br>
&lt;a href="https://zhuanlan.zhihu.com/p/682286231">自底向上理解memory_order&lt;/a>。&lt;br>
&lt;a href="https://blog.csdn.net/sinat_38293503/article/details/134612152">大白话C++之：一文搞懂C++多线程内存模型(Memory Order)&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>时钟周期&lt;/em>也称为&lt;em>振荡周期&lt;/em>，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。时钟周期表示了&lt;em>SDRAM&lt;/em>所能运行的最高频率。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>如果没有Cache，CPU每执行一条指令，都要去内存取下一条，而执行一条指令也就几个时钟周期（几ns），而取指令却要上百个时钟周期，这将导致CPU大部分时间都在等待状态，进而导致执行效率低下。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>C++ 内存模型（Memory Model）定义了程序在多线程环境中如何访问和共享内存，它为程序的正确性、并发性和可移植性提供了保证。C++ 内存模型主要通过原子操作、内存序列（Memory Ordering）、同步和锁等机制来规范线程之间的内存访问行为。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h1 id="cpu-的五级流水线">CPU 的五级流水线&lt;/h1>
&lt;blockquote>
&lt;p>CPU 将指令执行分解成5个部分，分别是：IF 取指令，ID 译码，EX 执行，MEM 访问内存，WB 写回。&lt;/p>
&lt;/blockquote>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>内存顺序模型&lt;/th>
 &lt;th>描述&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>memory_order_seq_cst&lt;/td>
 &lt;td>顺序一致(sequentially consistent ordering)，只有该值满足sC顺序一致性，原子操作默认使用该值。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>memory_order_relaxed&lt;/td>
 &lt;td>松散(relaxed ordering)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>memory_order_consume&lt;/td>
 &lt;td>获取发布(acquire-release ordering)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>memory_order_acquire&lt;/td>
 &lt;td>获取发布(acquire-release ordering)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>memory_order_release&lt;/td>
 &lt;td>获取发布(acquire-release ordering)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>memory_order_acq_rel&lt;/td>
 &lt;td>获取发布(acquire-release ordering)&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>与编译器优化有关：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//reordering 重排示例代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> A &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, B &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A &lt;span style="color:#f92672">=&lt;/span> B &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//(1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> B &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//(2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// g++ -std=c++11 -O2 -S test.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 编译器重排后的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 注意第一句汇编，已经将B最初的值存到了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 寄存器eax，而后将该eax的值加1，再赋给A
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">movl&lt;/span> &lt;span style="color:#66d9ef">B&lt;/span>(%rip), %eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">movl&lt;/span> &lt;span style="color:#66d9ef">$1&lt;/span>, &lt;span style="color:#66d9ef">B&lt;/span>(%rip) &lt;span style="color:#75715e">// B = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">addl&lt;/span> &lt;span style="color:#66d9ef">$1&lt;/span>, %eax &lt;span style="color:#75715e">// A = B + 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">movl&lt;/span> %eax, &lt;span style="color:#66d9ef">A&lt;/span>(%rip)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Invention示例代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 原始代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span>( cond ) x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 优化后代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>r1 &lt;span style="color:#f92672">=&lt;/span> x;&lt;span style="color:#75715e">// read what&amp;#39;s there
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>;&lt;span style="color:#75715e">// oops: optimistic write is not conditional
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span>( &lt;span style="color:#f92672">!&lt;/span>cond)&lt;span style="color:#75715e">// check if we guessed wrong
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> r1;&lt;span style="color:#75715e">// oops: back-out write is not SC
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于内存读写来说，读写顺序需要严格按照代码顺序，即要求如下（符号&lt;code>&amp;lt;p&lt;/code>表示程序代码顺序，符号&lt;code>&amp;lt;m&lt;/code>表示内存的读写顺序）：&lt;/p></description></item><item><title>C++ 中 tuple 是如何实现的？</title><link>https://jekyulll.github.io/posts/cpp-c++-%E4%B8%AD-tuple-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</link><pubDate>Sat, 28 Sep 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E4%B8%AD-tuple-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</guid><description>&lt;p>&lt;code>tuple&lt;/code>本身就是一种结构体，但是是一个模板类。利用&lt;code>形参包&lt;/code>(Parameter pack)。&lt;a href="https://zhuanlan.zhihu.com/p/715025973">C++ std::tuple的原理及简易实现&lt;/a>，靠着模板元的递归实现的，相当抽象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span>...Args&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 当元组中没有元素时，递归结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>() &lt;span style="color:#66d9ef">noexcept&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> tuple &lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#66d9ef">noexcept&lt;/span> {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> tuple &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> tuple &lt;span style="color:#f92672">&amp;amp;&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 当元组中有一个或多个元素时，将第一个元素的类型分离出来，并通过继承，将剩下的元素作为另一个元组处理。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> head, &lt;span style="color:#66d9ef">typename&lt;/span>...Args&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>head, Args...&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> tuple&lt;span style="color:#f92672">&amp;lt;&lt;/span>Args...&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> base_ &lt;span style="color:#f92672">=&lt;/span> tuple&lt;span style="color:#f92672">&amp;lt;&lt;/span>Args...&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> head_, &lt;span style="color:#66d9ef">typename&lt;/span>...Args_&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> tuple(head_ &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>val, Args_ &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>...args) &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head_val_(std&lt;span style="color:#f92672">::&lt;/span>forward&lt;span style="color:#f92672">&amp;lt;&lt;/span>head_&lt;span style="color:#f92672">&amp;gt;&lt;/span>(val)), base_(std&lt;span style="color:#f92672">::&lt;/span>forward&lt;span style="color:#f92672">&amp;lt;&lt;/span>Args_&lt;span style="color:#f92672">&amp;gt;&lt;/span>(args)...) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tuple_val_&lt;span style="color:#f92672">&amp;lt;&lt;/span>head&lt;span style="color:#f92672">&amp;gt;&lt;/span> head_val_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://zh.cppreference.com/w/cpp/language/class_template_argument_deduction">类模板实参推导（CTAD）(C++17 起)&lt;/a>。&lt;/p></description></item><item><title>C++ 的四种类型转换</title><link>https://jekyulll.github.io/posts/cpp-c++-%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><pubDate>Sat, 28 Sep 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>&lt;p>思考了一下&lt;code>reinterpret_cast&lt;/code>和强转的区别？这段非常易懂：&lt;br>
C 语言的类型转换实际上包含各种转换方式，是 &lt;code>static_cast&lt;/code> 跟 &lt;code>reinterpret_cast&lt;/code> 等的父操作。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一类是从逻辑意义上读取原有的值，然后到新的变量类型生成一个新值。（可以称为&lt;strong>显式类型转换&lt;/strong>，简称显转）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一类是完全保持原有值的内存表达方式，用新的变量类型来解读这段内存区域。（可以称为&lt;strong>强制类型转换&lt;/strong>，简称强转）&lt;br>
这两个用法实际的动作完全不同，但在 C 语言中是同一种写法。所以到了C++，就把前一种写法写成 &lt;code>static_cast&lt;/code>，后一种写法写成 &lt;code>reinterpret_cast&lt;/code>。&lt;br>
&lt;code>reinterpret_cast&lt;/code> 仅作用于编译时，可以保证不改变内存区域的内容。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dynamic_cast：这是 C 里面不存在的转型方式，用来在带有虚函数的“动态对象”继承树里进行指针或引用的类型转换。比如，假设我们有对象基类 &lt;code>Shape&lt;/code> 和派生类 &lt;code>Circle&lt;/code> 和 &lt;code>Rectangle&lt;/code>：如果有 &lt;code>Shape&lt;/code> 指针 &lt;code>ptr&lt;/code>，我们可以使用 &lt;code>dynamic_cast&amp;lt;Circle*&amp;gt;(ptr)&lt;/code> 尝试把它转型成 &lt;code>Circle*&lt;/code>。系统会进行需要的类型检查，并在转型成功时返回一个非空指针，返回空指针则表示失败（如当 &lt;code>ptr&lt;/code> 实际指向的不是 &lt;code>Circle&lt;/code>，而是 &lt;code>Rectangle&lt;/code>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>static_cast：这是一种在很多认为较安全的场景下的“静态”转型方式。你可以使用它在不同的数值类型之间进行转换，如从 &lt;code>long&lt;/code> 到 &lt;code>int&lt;/code>，或者从 &lt;code>long long&lt;/code> 到 &lt;code>double&lt;/code>——当转换有可能有精度损失时，就不能使用隐式类型转换，而得明确使用转型了。你也可以使用它把一个 &lt;code>void*&lt;/code> 转成一个实际类型的指针（如 &lt;code>int*&lt;/code>）。你还可以用它把基类的指针转成派生类的指针，前提条件是你能确认这个基类的指针确实指向一个派生类的对象。显然，对于这最后一种场景 static_cast 不如 dynamic_cast 安全，但由于不需要进行运行期的检查，它的性能比 &lt;code>dynamic_cast&lt;/code> 要高，在很多情况下是个空操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>const_cast：这种转型方式潜在就不那么安全了。它的目的是去掉一个指针或引用类型的 &lt;code>const&lt;/code> 或 &lt;code>volatile&lt;/code> 修饰，如从 &lt;code>const char*&lt;/code> 转换到 &lt;code>char*&lt;/code>。这种转型的一种常见用途是把一个 C++ 的指针传递到一个 &lt;code>const&lt;/code> 不正确的 C 接口里去，比如 C 接口在该用 &lt;code>const char*&lt;/code> 时使用了 &lt;code>char*&lt;/code>。注意这种转型只是为了“欺骗”类型系统，让代码能通过编译。如果你通过 &lt;code>const_cast&lt;/code> 操作指针或引用去修改一个 &lt;code>const&lt;/code> 对象，这仍然是错误的，是未定义行为，可能会导致奇怪的意外结果。&lt;/p></description></item><item><title>对 C++ 左值、右值、智能指针的思考</title><link>https://jekyulll.github.io/posts/cpp-%E5%AF%B9-c++-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%80%9D%E8%80%83/</link><pubDate>Thu, 19 Sep 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E5%AF%B9-c++-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%80%9D%E8%80%83/</guid><description>&lt;h5 id="左值右值函数传参">左值右值、函数传参：&lt;/h5>
&lt;ol>
&lt;li>&lt;strong>传值（按值传递）&lt;/strong>
如果函数的参数是通过按值传递的，传入一个右值时，编译器会生成一个临时对象，并将该临时对象复制或移动到函数内部的局部变量中。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>复制：对于不可移动的类型（例如基础类型 int），右值会被复制。&lt;/li>
&lt;li>移动：对于可以移动的类型（例如拥有移动构造函数的类），右值将会被移动，从而避免复制的开销。移动操作是一个高效的浅拷贝操作，将资源的所有权从右值转移到函数内部的局部变量中。&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>&lt;strong>传引用（按引用传递）&lt;/strong>&lt;br>
2.1 传左值引用
&lt;code>void foo(const std::string&amp;amp; s);&lt;/code> 当函数接受一个const 左值引用时，如果传入一个右值，编译器会生成一个临时对象并将它绑定到左值引用上。这时不会发生复制或移动，函数内部会直接使用右值的临时对象。这个临时对象的生命周期会被延长到函数结束。
2.2 传右值引用
&lt;code>void foo(std::string&amp;amp;&amp;amp; s);&lt;/code> 当函数接受一个右值引用时，右值引用参数可以直接绑定到右值，因此不会发生复制。通常情况下，右值引用用于转移资源的所有权，函数内部可以自由地操作该右值引用的内存内容。&lt;/li>
&lt;/ol>
&lt;h6 id="stdmove-与-智能指针">std::move 与 智能指针&lt;/h6>
&lt;p>&lt;code>std::move()&lt;/code> 本身并不会移动数据，它只是将对象的左值强制转换为右值引用，从而允许对象使用移动构造函数或移动赋值运算符。实际的“移动”行为是在这些函数中实现的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>std::move() 可以传入普通指针（如 int*）。传入指针时并不会产生任何有实际意义的“移动”行为，由于指针只是指向某个内存地址的变量(而不负责管理资源)，所以“移动”一个指针只是简单地转移其地址值，并没有实际涉及资源的所有权转移。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当 &lt;code>std::move&lt;/code> 传入智能指针（如 &lt;code>std::unique_ptr&lt;/code> 或 &lt;code>std::shared_ptr&lt;/code>）时，与传入普通指针相比，它会产生实际的资源转移，这是智能指针的移动语义带来的结果。&lt;/p>
&lt;ul>
&lt;li>&lt;code>std::unique_ptr&lt;/code> 是独占所有权的智能指针，意味着它独自管理动态分配的对象。不能复制 &lt;code>std::unique_ptr&lt;/code>，但可以通过移动将所有权转移给另一个 &lt;code>std::unique_ptr&lt;/code>。被移动的 &lt;code>std::unique_ptr&lt;/code> 会变为 &lt;code>nullptr&lt;/code>。&lt;/li>
&lt;li>&lt;code>std::move&lt;/code> + &lt;code>std::shared_ptr&lt;/code>：将 &lt;code>std::shared_ptr&lt;/code> 的引用计数和所有权从一个对象转移到另一个。被移动的 &lt;code>shared_ptr&lt;/code> 变为 &lt;code>nullptr&lt;/code>，但原来共享的资源只会在最后一个 &lt;code>shared_ptr&lt;/code> 销毁时释放。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>void process(std::unique_ptr&amp;lt;int&amp;gt;&amp;amp;&amp;amp; ptr) {
 std::cout &amp;lt;&amp;lt; &amp;#34;Value: &amp;#34; &amp;lt;&amp;lt; *ptr &amp;lt;&amp;lt; std::endl;
}
std::unique_ptr&amp;lt;int&amp;gt; p1 = std::make_unique&amp;lt;int&amp;gt;(42);
process(std::move(p1)); // 使用 std::move 将所有权转移给 process 函数
&lt;/code>&lt;/pre>&lt;p>&lt;strong>当 &lt;code>std::unique_ptr&lt;/code> 作为参数传入函数时：&lt;/strong>&lt;/p></description></item><item><title>C++ 模板类型推导</title><link>https://jekyulll.github.io/posts/cpp-morden-c++-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</link><pubDate>Sun, 01 Sep 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-morden-c++-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</guid><description>&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/649667647">一篇文章学完 Effective Modern C++：条款 &amp;amp; 实践&lt;/a>：&lt;/p>
&lt;h2 id="条款1-模板参数类型推导引用折叠">条款1： 模板参数类型推导，引用折叠&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> f(T&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> param);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">27&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> cx &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> rx &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 左值的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>f(x); &lt;span style="color:#75715e">// T 的类型为 int&amp;amp;, paramType 为 int&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>f(cx); &lt;span style="color:#75715e">// T 的类型为 const int&amp;amp;, paramType 为 const int&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>f(rx); &lt;span style="color:#75715e">// T 的类型为 const int&amp;amp;, paramType 为 const int&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 右值的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>f(&lt;span style="color:#ae81ff">27&lt;/span>) &lt;span style="color:#75715e">// T 的类型为 int, paramType 为 int&amp;amp;&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于指向 &lt;code>const&lt;/code> 对象的 &lt;code>const&lt;/code> 指针的传递，仅有指针本身的常量性会被忽略：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> f(T param);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> ptr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Fun with pointers&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>f(ptr); &lt;span style="color:#75715e">// T 和 param 的类型均为 const char*
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：&lt;/p></description></item><item><title>C++ 的三五法则是什么？</title><link>https://jekyulll.github.io/posts/cpp-c++-%E7%9A%84%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 26 Aug 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-%E7%9A%84%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88/</guid><description>&lt;p>三五法则（Rule of Three/Five/Zero）。&lt;/p>
&lt;p>“三法则”主要适用于 C++98/03 标准下的资源管理。在使用动态内存或其他资源时，如果类需要显式地管理资源，通常需要实现以下三个特殊成员函数：&lt;/p>
&lt;ol>
&lt;li>拷贝构造函数（Copy Constructor）：用于复制对象时分配新资源。&lt;/li>
&lt;li>拷贝赋值运算符（Copy Assignment Operator）：用于对象赋值时释放旧资源并分配新资源。&lt;/li>
&lt;li>析构函数（Destructor）：用于对象销毁时释放资源。&lt;/li>
&lt;li>&lt;/li>
&lt;/ol>
&lt;p>随着 C++11 引入了移动语义和右值引用，&amp;ldquo;五法则&amp;quot;扩展了“三法则”，增加了两个新的特殊成员函数：&lt;/p>
&lt;ol>
&lt;li>移动构造函数（Move Constructor）：用于移动对象时“窃取”资源，而不是复制。&lt;/li>
&lt;li>移动赋值运算符（Move Assignment Operator）：用于对象赋值时“窃取”资源，而不是复制。&lt;/li>
&lt;/ol></description></item><item><title>C++ 17 编译期 if</title><link>https://jekyulll.github.io/posts/cpp-c++-17-%E7%BC%96%E8%AF%91%E6%9C%9F-if/</link><pubDate>Sat, 10 Aug 2024 18:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/cpp-c++-17-%E7%BC%96%E8%AF%91%E6%9C%9F-if/</guid><description>&lt;p>&lt;a href="https://www.bilibili.com/video/BV1Eb42177a8/?spm_id_from=333.1007.tianma.1-1-1.click&amp;amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">C++17编译期if&lt;/a>：&lt;code>constexpr&lt;/code>。&lt;/p>
&lt;p>用例：不加&lt;code>constexpr&lt;/code>会编译出错，因为必有一种情况是语法错误的。如果&lt;code>T&lt;/code>为&lt;code>X&lt;/code>类型，则内部没有&lt;code>y_func()&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> f(T t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// 判断类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_same_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, X&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		t.x_func();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	} &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#75715e">// 此处若为 &amp;#34;舍弃语句&amp;#34;，不会参加编译。但会检查语法错误(但不会检查模板的实例化)。而预处理器if(#if)如果舍弃，完全不检查。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>		t.y_func();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回类型推导：C++14后可以用&lt;code>auto&lt;/code>作为函数返回值，但所有表达式必须推导出相同的返回类型(不能在不同情况下返回不同的类型，例如&lt;code>int&lt;/code>和&lt;code>float&lt;/code>)。但如果在判断的地方使用&lt;code>constexpr&lt;/code>，能通过编译(因为是在编译期判断的)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> (...) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1.0f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>OpenGL 初学笔记 -- Cherno + LearnOpenGL</title><link>https://jekyulll.github.io/posts/opengl-%E8%8F%9C--opengl-%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0----cherno-+-learnopengl/</link><pubDate>Mon, 29 Jul 2024 21:05:47 +0800</pubDate><guid>https://jekyulll.github.io/posts/opengl-%E8%8F%9C--opengl-%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0----cherno-+-learnopengl/</guid><description>&lt;p>&lt;img src="https://jekyulll.github.io/images/ayanami_header.jpg" alt="hearder">&lt;/p>
&lt;p>这两个月学习了一下OpenGL。从Cherno的教学视频开始学习，看完后开始看LearnOpenGL，应该是很常见的学习路径。&lt;br>
在此以新手视角，记录一下学习中在工程方面遇到的一些坑（数学和底层方面就不打算开口丢人了）。&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/@TheCherno">Cherno主页&lt;/a> | &lt;a href="https://learnopengl.com/">LearnOpenGL&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="1-直接选择-64-位">&lt;strong>1.&lt;/strong> 直接选择 64 位&lt;/h2>
&lt;p>Cherno视频是2017及之前的，为了兼容性，教程里32位。而LearnOpenGL写到后面是64位，还要用Assimp库，默认是编译成64位。建议直接x64，像我这样闷头跟着写的话要把 GLEW 和 GLFW 的静态库全换一遍，或者去折腾CMake。&lt;/p>
&lt;hr>
&lt;h2 id="2-glew-glad-glfw">&lt;strong>2.&lt;/strong> GLEW, GLAD, GLFW&lt;/h2>
&lt;p>这三个比较常用。两个教程的选择都是 GLEW + GLFW，其中 GLEW 和 GLAD 定位相似，都是用于访问OpenGL函数。可以先看看自己喜欢哪一个，免得后面想换再费功夫。&lt;/p>
&lt;hr>
&lt;h2 id="3-texture-的实现----小心析构函数">&lt;strong>3.&lt;/strong> &lt;code>Texture&lt;/code> 的实现 &amp;ndash; 小心析构函数&lt;/h2>
&lt;p>LearnOpenGL中的&lt;code>Texture&lt;/code>只是一个存储数据的结构体：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Texture&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GLuint id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aiString path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而Cherno将&lt;code>Texture&lt;/code>创建为类，构造函数中直接完成加载图片的操作，并且在析构函数里调用&lt;code>glDeleteTextures&lt;/code>。&lt;br>
如果无脑缝代码就完蛋了，因为LearnOpenGL在&lt;code>Model::loadMaterialTextures&lt;/code>函数中创建了&lt;code>Texture&lt;/code>的临时对象并返回，会调用析构函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&lt;/span> loadMaterialTextures(aiMaterial&lt;span style="color:#f92672">*&lt;/span> mat, aiTextureType type, string typeName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&lt;/span> textures;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> textures;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以选择：&lt;/p>
&lt;ol>
&lt;li>修改Texture类的实现（比如把）glDeleteTextures单独调用；&lt;/li>
&lt;li>修改Model类中加载纹理的实现，例如传入Texture的引用；&lt;/li>
&lt;li>使用指针。我选择了使用智能指针（相对应的地方全要改）：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 顺便把参数改成 `aiTextureType`(Assimp定义的用于表示Texture不同类型的枚举)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 优化掉LearnOpenGL里那个丑陋的字符串处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> Model&lt;span style="color:#f92672">::&lt;/span>loadMaterialTextures(aiMaterial&lt;span style="color:#f92672">*&lt;/span> mat, aiTextureType type)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> textures;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (GLuint i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> mat&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetTextureCount(type); i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aiString str;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mat&lt;span style="color:#f92672">-&amp;gt;&lt;/span>GetTexture(type, i, &lt;span style="color:#f92672">&amp;amp;&lt;/span>str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> canSkip &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>textures_loaded.size(); j&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (textures_loaded[j]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>path &lt;span style="color:#f92672">==&lt;/span> str)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> textures.push_back(textures_loaded[j]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> canSkip &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>canSkip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string filename &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string(str.C_Str());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filename &lt;span style="color:#f92672">=&lt;/span> directory &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> filename;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&lt;/span> texture &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>make_shared&lt;span style="color:#f92672">&amp;lt;&lt;/span>Texture&lt;span style="color:#f92672">&amp;gt;&lt;/span>(filename); &lt;span style="color:#75715e">// 教程里此处调用了TextureFromFile()来初始化texture，但可以用Texture的构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> texture&lt;span style="color:#f92672">-&amp;gt;&lt;/span>type &lt;span style="color:#f92672">=&lt;/span> type; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> texture&lt;span style="color:#f92672">-&amp;gt;&lt;/span>path &lt;span style="color:#f92672">=&lt;/span> str;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> textures.push_back(texture);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>textures_loaded.push_back(texture);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> textures;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同理，小心其他类里的析构函数（例如Shader类可能会在析构里调用glDeleteProgram）。&lt;/p></description></item><item><title>C++ / Golang / 游戏开发 / TA 学习路线汇总</title><link>https://jekyulll.github.io/posts/means/</link><pubDate>Sun, 02 Jun 2024 19:46:34 +0800</pubDate><guid>https://jekyulll.github.io/posts/means/</guid><description>&lt;!-- -- 2024年6月2日23:56:19
收藏的路线越来越多，有点乱。单列一个文件，想到的时候汇总一下。 -->
&lt;h1 id="c">C++&lt;/h1>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/649667647">一篇文章学完 Effective Modern C++：条款 &amp;amp; 实践&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/14264391441">深入理解C++内存管理：指针、引用和内存分配&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/274189552/answer/3578048970">CPU的核心数和线程数量是什么关系？ - texttime vage的回答 - 知乎&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://space.bilibili.com/28615855/channel/collectiondetail?sid=43297">合集·现代 C++ 语言核心特性解析&lt;/a>。&lt;br>
&lt;a href="https://changkun.de/modern-cpp/zh-cn/01-intro/">现代 C++ 教程：高速上手 C++ 11/14/17/20&lt;/a>。&lt;/p>
&lt;p>小鹏的教程：&lt;a href="https://space.bilibili.com/263032155/channel/collectiondetail?sid=599074">合集·现代C++项目实战&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/290102232/answer/2094675219">校招C++大概学习到什么程度？ - 程序员内功修炼的回答 - 知乎&lt;/a>。八股文组合拳。&lt;/p>
&lt;p>陈皓（左耳朵耗子）的一些博客：&lt;br>
&lt;a href="https://blog.csdn.net/haoel/article/details/1948051">C++ 虚函数表解析&lt;/a>。&lt;br>
&lt;a href="https://haoel.blog.csdn.net/article/details/3081328">C++ 对象的内存布局（上）&lt;/a>。&lt;br>
&lt;a href="https://haoel.blog.csdn.net/article/details/2886">跟我一起写 Makefile（一）&lt;/a>。&lt;br>
&lt;a href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://github.com/Light-City/CPlusPlusThings">C++那些事 CPlusPlusThings&lt;/a>。&lt;br>
&lt;a href="https://light-city.github.io/stories_things/">C++那些事 中文&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">现代C++教程 2023&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">CUDA C++ Programming Guide&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/394704611/answer/1245846184">如何成为linux服务端C++开发专家? - 不谙世事的吴同学的回答 - 知乎&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/527327054">c++17 多态内存资源(PMR)&lt;/a>。&lt;br>
&lt;a href="https://zhuanlan.zhihu.com/p/452697297">内存管理：设计Arena&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1Se411D7y4/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a">这本书加深了我对C++的理解 | C++ Core Guidelines解析&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_42136255/article/details/133815129">深入理解Asan:内存错误检测工具与实践&lt;/a>。&lt;/p>
&lt;!-- [C++翻译阶段中的编码转换-执行字符集与源字符集](https://www.bilibili.com/video/BV1yof2Y4EPF/?spm_id_from=333.1007.tianma.2-1-4.click&amp;vd_source=9b0b9cbfd8c349b95b4776bd10953f3a)。 -->
&lt;p>&lt;a href="https://www.zhihu.com/question/428340896/answer/2913419725">为什么C/C++等少数编程语言要区分左右值？ - 腾讯技术工程的回答 - 知乎&lt;/a>。非常牛逼。讲得很深，从C语言的发展、寄存器讲起。&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/670821214">13.纤程（Fiber）与协程（Coroutine）&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://baijiahao.baidu.com/s?id=1719486804831856788&amp;amp;wfr=spider&amp;amp;for=pc">深入并发之线程、进程、纤程、协程、管程与死锁、活锁｜详解&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/33979489/answer/1854635802">从操作系统内存管理来说，malloc申请一块内存的背后原理是什么？ - 编程指北的回答 - 知乎&lt;/a>。&lt;/p></description></item><item><title/><link>https://jekyulll.github.io/posts/cpp-%E4%BA%8B%E5%8A%A1%E6%80%A7%E5%86%85%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jekyulll.github.io/posts/cpp-%E4%BA%8B%E5%8A%A1%E6%80%A7%E5%86%85%E5%AD%98/</guid><description>&lt;!-- +++
date = '2025-03-10T12:05:47+08:00'
draft = false
title = '【AI】使用普通的互斥锁实现读写锁'
author = 'JekYUlll'
lastmod = '2025-03-10T12:05:47+08:00'
tags = ['cpp','algorithm']
categories = ['cpp']
+++ -->
&lt;p>// TODO&lt;/p></description></item></channel></rss>